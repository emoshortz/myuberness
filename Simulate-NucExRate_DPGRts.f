      program Simulate
      
      implicit none
c 
c This program is to test the mechanics of adding a tubulin to the lattice
c
c variables:
c	state(i,j) is the lattice. 1 = GTP-tub, 0=emtpy, -1=GDP=tub
c	ev(i,j,k) returns the kth event number at site i,j
c 	nev(i,j) keeps the number of possible events at site i,j
c	evtype(i,j,k) returns the type of event at i,j: k=1 -> addition, k=2 -> dissoc, k=3 -> gtp hydrolysis, k=4 -> nucleotide exchange
c   xloc(k), yloc(k) return the lattice positions of a particular event k 
c 	addstate(i,j) = 1 if there is a possible addition event at i,j; it is 0 otherwise
c   dissocstate(i,j): 1-add, 2-1lat, 3-1long (gtp), 4-1long (gdp), 5-1each (GTP), 6-1 each gdp, 7-gtp hydro, 8-slow

      integer i,j,state(13,2000),totev
      integer evtype(13,2000,4),ev(13,2000,4),addstate(13,2000)
      integer hydrostate(13,2000),substate(13,2000)
      integer xloc(20000),yloc(20000),evno,nrecyc,recyc(20000)
      integer ntub,ontub,nev(13,2000),maxlen,k,l,xo,yo,xom,xop,yom,yop
      logical qinit,done,qdebug
   	  integer dissocstate(13,2000),dist(13,2000),dep(13,2000)   
	  integer temp,kk,x,y,jj,ll,n
	  integer test,event(20000),revmap(20000)
	  integer mono,di,tri,tet,pent,hex,hept,oct,ennea,dec
	  integer nhydro,lmax,corner_y,corner_n
	  double precision k_on,conc,GDP,K_lat,K_long,K_both,k_hyd,time
	  double precision K_thr_long,K_thr_lat,K_all,k_ne
	  double precision evtime(20000)
	  double precision get_evtime
c For seam multiplier
      double precision seammult(13,2000)
      
      double precision dummy
      logical depoly,poly		!to see whether depolymerization has started
      
c For depoly slope calculations...
      double precision length_d(300),time_d(300),tmlngth_d(300),tm_dsq(300)
      integer count_d,count_eqd
      double precision math_dt,pretm,tmlngth_dsm,tm_dsm,lngth_dsm,tm_dsqsm,rate_d
      
c For growth slope calculations...
      integer count_p,count_eqp
      double precision time_p(800),length_p(800),tmlngth_p(800),tm_psq(800)
      double precision tmlngth_psm,tm_psqsm,rate_p
      
c Initialization for depolymerization...      
      depoly=.false.
      count_d=0
      tmlngth_dsm=0
      tm_dsm=0
      lngth_dsm=0
      tm_dsqsm=0
      
c Initialization for growth...
      poly=.true.
      count_p=0
      tmlngth_psm=0
      tm_psqsm=0
	  
c initialize: no events to recycle and number of tubulin starts at 1
      time=0.
      maxlen=2000
      nrecyc = 0
      ntub = 1
      ontub = 0   !Old number of tubulin
      qinit=.TRUE.
      xo=7
      yo=100
c initialize: put a MTstub in the lattice, 5 tall on each protofilament
      do i=1,13
         do j=1,2000
            ev(i,j,1) = 0
            ev(i,j,2) = 0
            ev(i,j,3) = 0
            ev(i,j,4) = 0 !new for nuc ex
            nev(i,j)=0
            state(i,j)=0
            addstate(i,j) = 0
            dissocstate(i,j)=0
            dep(i,j)=9
            seammult(i,j)=1.0
         end do
      end do
      
      do i=1,13
         do j=98,102
            dep(i,j)=0
            state(i,j) = 1
            dissocstate(i,j)=8
         end do
      end do

      conc=10.0E-6
c      GDP=8.2
c      k_on=2.E6
c allowing K_lat for non-crashing purposes (hopefully)...
      K_lat=1.0
c      K_long=82.7E-6
c      K_both=3.4E-6
c      K_thr_long=2.7E-10
c      K_thr_lat=1.3E-7
c      K_all=1.1E-18
      GDP=12.2
      k_on=4.0E6
c      K_long=1.5E-7
      K_long=1.11E-3
c      K_both=4.0E-6
      K_both=3.72E-6
c      K_thr_long=1.1E-18	! guess
      K_thr_long=2.7E-11	! guess
c      K_thr_lat=1.1E-18
      K_thr_lat=1.24E-8
      K_all=1.1E-18
c      k_hyd=1.
      k_hyd=1.1E-18
      k_ne=0.2				!new for nuc ex (estimated, but still dummy)
c      k_ne=0.5

      write(6,*) 'rates',k_on*conc,k_on*K_lat,k_on*K_long,k_on*K_both
      call random_seed

c initializing counters for different n-mers      
      mono=0
      di=0
      tri=0
      tet=0
      pent=0
      hex=0
      hept=0
      oct=0
      ennea=0
      dec=0
      
c initializing counter for hydrolysis events
      nhydro=0
C
C create new events, adding on top
      do i=1,13
         if (i.lt.13) then
            addstate(i,103) = 1
            dissocstate(i,103) = 3
            nev(i,103) = 1
         else
            addstate(i,103) = 2
            dissocstate(i,103) = 5
            nev(i,103)=1
         endif
      end do
C
C create new events, adding on bottom
c      do i=1,13
c         if (i.eq.1) then
c            addstate(i,97) = 1
c            dissocstate(i,97) = 5
c            nev(i,97) = 1
c         else
c            addstate(i,97) = 1
c            dissocstate(i,97) = 3
c            nev(i,97)=1
c         endif
c      end do
c manually put list of possible events
      totev = 0
      do i=1,13
         j=103
c         do j=97,103,6
            totev = totev+1
            ev(i,j,1) = totev
            evtime(totev) = get_evtime(1,k_on,conc,
     @                       GDP,K_lat,K_long,K_both,k_hyd,
     @                       K_thr_long,K_thr_lat,K_all,k_ne,seammult(i,j))
            event(totev) = totev
            revmap(totev) = totev
            xloc(totev) = i
            yloc(totev) = j
c         end do
      end do

      
      do i=1,totev
         write(6,*) 'evtimes ',i,evtime(event(i)),event(i),revmap(i)
      end do
      
      call build_min_heap(event,revmap,evtime,totev)

      do i=1,totev
         write(6,*) 'evtimes ',i,evtime(event(i)),event(i),revmap(i)
      end do
            
c do fastest event
      done = .false.
      qdebug = .true.
      kk=0
      jj=0
      do while (.not.done)
      kk=kk+1
      
c For getting depolymerization rates...
      if (ntub.eq.350) then		!starting at 350 to allow for hydrolysis to occur & occasional dissociation
         !do once, shouldnt revert back
         write(6,*) 'start shrinking'
         depoly=.true.
         poly=.false.
         conc=1.1E-18   	!conc cannot be zero, error will occur
c         K_both=9.0E-6		!for testing...
         k_hyd=200   		!make everything GDP before dissociating, thus having pure GDP dissociations
         k_ne=1.1E-18		!nucleotide exchange rate cannot be zero, error will occur
      endif
            
      if (ntub.lt.1) then
      	write(6,*) 'zero or negative ntub'
      	stop
      endif

c      do i=1,totev
c         write(6,*) 'evtimes before recalc',i,evtime(event(i)),event(i),revmap(i)
c      end do
            
c      write(6,*) 'crude test, recalc all evtimes'
c Going to count all corner events
      corner_y=0
      corner_n=0
      
      do i=1, totev
c         write(6,*) 'xloc,yloc for event',xloc(event(i)),yloc(event(i)),i
         if (event(i).eq.ev(xloc(event(i)),yloc(event(i)),1)) then
c            write(6,*) 'is addition event'
            evtime(event(i)) = get_evtime(1,k_on,conc,
     @                       GDP,K_lat,K_long,K_both,k_hyd,
     @                       K_thr_long,K_thr_lat,K_all,k_ne,
     @                       seammult(xloc(event(i)),yloc(event(i))))
c Counting all empty subunits     
            if (dissocstate(xloc(event(i)),yloc(event(i))).eq.5) then
               if (xloc(event(i)).eq.1) then
c                  write(6,*) 'looking at row 1'
                  if (state(13,yloc(event(i))+2).ne.0) then
                     if ((dissocstate(13,yloc(event(i))+2).eq.3).or.
     @                  (dissocstate(13,yloc(event(i))+2).eq.4)) then
c                        write(6,*) 'dont add corner for: ',xloc(event(i)),yloc(event(i))
                     else
c                        write(6,*) 'add corner for: ',xloc(event(i)),yloc(event(i))
                        corner_n=corner_n+1
                     endif
                  elseif (state(xloc(event(i))+1,yloc(event(i))).ne.0) then
                     if ((dissocstate(xloc(event(i))+1,yloc(event(i))).eq.3).or.
     @                  (dissocstate(xloc(event(i))+1,yloc(event(i))).eq.4)) then
c                        write(6,*) 'dont add corner for: ',xloc(event(i)),yloc(event(i))
                     else
c                        write(6,*) 'add corner for: ',xloc(event(i)),yloc(event(i))
                        corner_n=corner_n+1
                     endif
                  endif
               elseif (xloc(event(i)).eq.13) then
c                  write(6,*) 'looking at row 13'
                  if (state(xloc(event(i))-1,yloc(event(i))).ne.0) then
                     if ((dissocstate(xloc(event(i))-1,yloc(event(i))).eq.3).or.
     @                  (dissocstate(xloc(event(i))-1,yloc(event(i))).eq.4)) then
c                        write(6,*) 'dont add corner for: ',xloc(event(i)),yloc(event(i))
                     else
c                        write(6,*) 'add corner for: ',xloc(event(i)),yloc(event(i))
                        corner_n=corner_n+1
                     endif
                  elseif (state(1,yloc(event(i))-1).ne.0) then
                     if ((dissocstate(1,yloc(event(i))-1).eq.3).or.
     @                  (dissocstate(1,yloc(event(i))-1).eq.4)) then
c                        write(6,*) 'dont add corner for: ',xloc(event(i)),yloc(event(i))
                     else
c                        write(6,*) 'add corner for: ',xloc(event(i)),yloc(event(i))
                        corner_n=corner_n+1
                     endif
                  endif
               else
c                  write(6,*) 'not looking at seam'
                  if (state(xloc(event(i))-1,yloc(event(i))).ne.0) then
                     if ((dissocstate(xloc(event(i))-1,yloc(event(i))).eq.3).or.
     @                  (dissocstate(xloc(event(i))-1,yloc(event(i))).eq.4)) then
c                        write(6,*) 'dont add corner for: ',xloc(event(i)),yloc(event(i))
                     else
c                        write(6,*) 'add corner for: ',xloc(event(i)),yloc(event(i))
                        corner_n=corner_n+1
                     endif
                  elseif (state(xloc(event(i))+1,yloc(event(i))).ne.0) then
                     if ((dissocstate(xloc(event(i))+1,yloc(event(i))).eq.3).or.
     @                  (dissocstate(xloc(event(i))+1,yloc(event(i))).eq.4)) then
c                        write(6,*) 'dont add corner for: ',xloc(event(i)),yloc(event(i))
                     else
c                        write(6,*) 'add corner for: ',xloc(event(i)),yloc(event(i))
                        corner_n=corner_n+1
                     endif
                  endif
               endif
            endif
         elseif (event(i).eq.ev(xloc(event(i)),yloc(event(i)),2)) then
c            write(6,*) 'is dissoc event'
            evtime(event(i)) = get_evtime(dissocstate(xloc(event(i)),yloc(event(i))),k_on,conc,
     @                       GDP,K_lat,K_long,K_both,k_hyd,
     @                       K_thr_long,K_thr_lat,K_all,k_ne,
     @                       seammult(xloc(event(i)),yloc(event(i))))
c Counting all present subunits     
            if ((dissocstate(xloc(event(i)),yloc(event(i))).eq.5).or.
     @         (dissocstate(xloc(event(i)),yloc(event(i))).eq.6)) then
               corner_y=corner_y+1
            endif
         elseif (event(i).eq.ev(xloc(event(i)),yloc(event(i)),3)) then
c            write(6,*) 'is hydro event'
            evtime(event(i)) = get_evtime(7,k_on,conc,
     @                       GDP,K_lat,K_long,K_both,k_hyd,
     @                       K_thr_long,K_thr_lat,K_all,k_ne,
     @                       seammult(xloc(event(i)),yloc(event(i))))
         elseif (event(i).eq.ev(xloc(event(i)),yloc(event(i)),4)) then								!new for nuc ex
c            write(6,*) 'is nucleotide exchange event'
            evtime(event(i)) = get_evtime(9,k_on,conc,
     @                       GDP,K_lat,K_long,K_both,k_hyd,
     @                       K_thr_long,K_thr_lat,K_all,k_ne,
     @                       seammult(xloc(event(i)),yloc(event(i))))
         else
            write(6,*) 'bad event retrieval',i,event(i),xloc(event(i)),yloc(event(i)),
     @                    ev(xloc(event(i)),yloc(event(i)),1),ev(xloc(event(i)),yloc(event(i)),2),
     @                    ev(xloc(event(i)),yloc(event(i)),3),ev(xloc(event(i)),yloc(event(i)),4)	!new for nuc ex
            stop
         endif
      end do
c Write out totals for corner interactions      
      if (poly) then
         do n=1,4000
            if (kk.eq.n*12.5) then   
               write(6,*) 'corner_y = ',corner_y,'corner_n = ',corner_n
            endif
         enddo
      endif
      
      if (depoly) then
         if ((ntub.le.300).and.(ntub.ge.14)) then
            write(6,*) 'corner_yd = ',corner_y,'corner_nd = ',corner_n
         endif
      endif

      call build_min_heap(event,revmap,evtime,totev)

c      do i=1,totev
c         write(6,*) 'evtimes after recalc',i,evtime(event(i)),event(i),revmap(i)
c      end do

      time = time+evtime(event(1))
      x = xloc(event(1))
      y = yloc(event(1))
      if ( (x.lt.1).or.(x.gt.13).or.(y.lt.1).or.(y.gt.2000) ) then
         write(6,*) 'Grew too wide/tall: x,y= ',x,y
         write(6,*) 'event info: ',event(1)
        write(6,*) 'position of event',xloc(event(1)),yloc(event(1))
        write(6,*) 'event,x,y,ev(x,y,1),ev(x,y,2),ev(x,y,3),ev(x,y,4)',
     @             event(1),x,y,ev(x,y,1),ev(x,y,2),ev(x,y,3),ev(x,y,4)				!new for nuc ex
     			do jj=1,totev
     			temp=event(jj)
         		write(6,'(A,I4,F10.6,4I4)') 'times ',
     @ jj,evtime(temp),event(jj),revmap(jj),xloc(temp),yloc(temp)
      			end do
         
         write(6,'(13A)') '  1 ',' 2 ',' 3 ',' 4 ',' 5 ',' 6 ',' 7 ',
     @                     ' 8 ',' 9 ',' 10',' 11',' 12',' 13'
         do ll=120,80,-1
            write(6,'(13I3)') state(1,ll),state(2,ll),state(3,ll),
     @ state(4,ll),state(5,ll),state(6,ll),state(7,ll),state(8,ll),
     @ state(9,ll),state(10,ll),state(11,ll),state(12,ll),state(13,ll)
         end do
         stop
      endif
      
      if (event(1).eq.ev(x,y,1)) then
         if (dissocstate(x,y).ne.2) then
            write(6,'(A,8I4)') 'Adding subunit at ',x,y,ntub,event(1),
     @ ev(x,y,1),ev(x,y,2),ev(x,y,3),ev(x,y,4),dissocstate(x,y)				!new for nuc ex
            evno = event(1)
            call AddTub(ntub,ontub,evno,xloc,yloc,state,nrecyc,recyc,
     @                  totev,addstate,evtype,nev,ev,maxlen,xo,yo,
     @                  qinit,dissocstate,event,revmap,
     @					evtime,k_on,conc,
     @                        GDP,K_lat,K_long,K_both,k_hyd,
     @                        K_thr_long,K_thr_lat,K_all,dist,qdebug,dep,seammult,k_ne)
c     		    if (qdebug) then
             do n=1,4000
                if (kk.eq.n*500) then
     			do jj=1,totev
     			temp=event(jj)
         		write(6,'(A,I4,F10.6,4I4)') 'times ',
     @ jj,evtime(temp),event(jj),revmap(jj),xloc(temp),yloc(temp)
      			end do
      			endif
      	     enddo
         else
            write(6,*) 'dstate=2, recycle to avoid lateral additions'
            time = time-evtime(event(1))
            evtime(ev(x,y,1))=10.
            call update(event,revmap,ev(x,y,1),evtime(ev(x,y,1)),evtime,totev)
            write(6,*) 'times(ev(x,y,1))',x,y,evtime(ev(x,y,1)),dissocstate(x,y)
            
         endif
      elseif (event(1).eq.ev(x,y,2)) then
         evno = event(1)
         write(6,'(A,7I4)') 'Losing subunit at ',x,y,ntub,event(1),
     @ ev(x,y,1),ev(x,y,2),ev(x,y,3),ev(x,y,4)							!new for nuc ex
         call Subtub(ntub,ontub,evno,xloc,yloc,state,nrecyc,recyc,
     @      			totev,addstate,nev,ev,maxlen,qinit,xo,yo,
     @ 			dissocstate,test,temp,event,evtime,revmap,k_on,conc,
     @                         GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @          K_thr_lat,K_all,dist,qdebug,dep,seammult,k_ne)
c     		    if (qdebug) then
             do n=1,4000
                if (kk.eq.n*500) then
     			do jj=1,totev
     			temp=event(jj)
         		write(6,'(A,I4,F10.6,4I4)') 'times ',
     @ jj,evtime(temp),event(jj),revmap(jj),xloc(temp),yloc(temp)
      			end do
      			endif
      		 enddo
      elseif (event(1).eq.ev(x,y,3)) then
         write(6,'(A,7I4)') 'Hydrolyzing subunit at ',x,y,ntub,event(1),
     @ ev(x,y,1),ev(x,y,2),ev(x,y,3),ev(x,y,4)								!new for nuc ex
         evno = event(1)
      call HydroTub(ntub,evno,xloc,yloc,state,nrecyc,recyc,
     @					  totev,addstate,nev,ev,maxlen,
     @ 					dissocstate,dep,k_on,conc,event,revmap,evtime,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @          K_thr_lat,K_all,dist,xo,yo,qdebug,seammult,k_ne)
c hydrolysis event counter
                nhydro=nhydro+1
c     		    if (qdebug) then
             do n=1,4000
                if (kk.eq.n*500) then
     			do jj=1,totev
     			temp=event(jj)
         		write(6,'(A,I4,F10.6,4I4)') 'times ',
     @ jj,evtime(temp),event(jj),revmap(jj),xloc(temp),yloc(temp)
      			end do
      			endif
      		 enddo
      elseif (event(1).eq.ev(x,y,4)) then										!new for nuc ex
         write(6,'(A,7I4)') 'Nucleotide exchange at ',x,y,ntub,event(1),
     @   ev(x,y,1),ev(x,y,2),ev(x,y,3),ev(x,y,4)
         evno = event(1)
         call NucEx(evno,xloc,yloc,state,nrecyc,recyc,
     @				   totev,nev,ev,maxlen,dissocstate,
     @ 				   event,revmap,evtime)
c         if (qdebug) then
         do n=1,4000
            if (kk.eq.n*500) then
     	       do jj=1,totev
     	          temp=event(jj)
                  write(6,'(A,I4,F10.6,4I4)') 'times ',
     @            jj,evtime(temp),event(jj),revmap(jj),xloc(temp),yloc(temp)
      		   end do
         	endif
         enddo
      	 
c         stop
      else 
        write(6,*) 'you messed up'
        write(6,*) 'position of event',xloc(event(1)),yloc(event(1))
        write(6,*) 'event,x,y,ev(x,y,1),ev(x,y,2),ev(x,y,3),ev(x,y,4)',
     @             event(1),x,y,ev(x,y,1),ev(x,y,2),ev(x,y,3),ev(x,y,4)				!new for nuc ex
     			do jj=1,totev
     			temp=event(jj)
         		write(6,'(A,I4,F10.6,4I4)') 'times ',
     @ jj,evtime(temp),event(jj),revmap(jj),xloc(temp),yloc(temp)
      			end do
       stop
      endif
      
      write(6,*) 'step number ',kk,'time = ',time,'ntub = ',ntub
      
      dummy=ntub/1625.0
      
      if (depoly) then
         if ((ntub.le.300).and.(ntub.ge.14)) then
            write(6,*) 'wanted2 = ',time,ntub,dummy
            count_d=count_d+1
            if (ntub.eq.300) then
               math_dt=0
               pretm=time
            elseif (ntub.eq.299) then
               math_dt=time-pretm
               pretm=time
            else
               math_dt=math_dt+(time-pretm)
               pretm=time
            endif
            time_d(count_d)=math_dt
            length_d(count_d)=dummy
         endif
      endif      
      
c Microsoft likes no more than 800 pts.
      if (poly) then
         do n=1,4000
            if (kk.eq.n*12.5) then
               write(6,*) 'wanted = ',time,ntub,dummy
               count_p=count_p+1
               time_p(count_p)=time
               length_p(count_p)=dummy
            endif
         enddo
      endif
      
      if (kk.eq.20000) then
         done=.true.
         write(6,*) 'SuperDone'

c For depolymerization rates...
         if (depoly) then
            do count_eqd=1,count_d
               !to get xy...
               tmlngth_d(count_eqd)=time_d(count_eqd)*length_d(count_eqd)
               !to get x^2...
               tm_dsq(count_eqd)=time_d(count_eqd)*time_d(count_eqd)
            enddo
            do count_eqd=1,count_d
               !to get sum(xy)...
               tmlngth_dsm=tmlngth_dsm+tmlngth_d(count_eqd)
               !to get sum(x)...
               tm_dsm=tm_dsm+time_d(count_eqd)
               !to get sum(y)...
               lngth_dsm=lngth_dsm+length_d(count_eqd)
               !to get sum(x^2)...
               tm_dsqsm=tm_dsqsm+tm_dsq(count_eqd)
            enddo
            
            !Rate is given in um/min (since time is in seconds, have to multiply by 60)
            rate_d=(((count_d*tmlngth_dsm)-(tm_dsm*lngth_dsm))/
     @             ((count_d*tm_dsqsm)-(tm_dsm*tm_dsm)))*60.0
            write(6,*) 'rate_d =',rate_d
c         else
c            write(6,*) 'rate_d = null'
         endif
         
c For growth rates...
         if (poly) then
            do count_eqp=1,count_p
               !to get xy
               tmlngth_p(count_eqp)=time_p(count_eqp)*length_p(count_eqp)
               !to get x^2
               tm_psq(count_eqp)=time_p(count_eqp)*time_p(count_eqp)
            enddo
            do count_eqp=1,count_p
               !to get sum(xy)
               tmlngth_psm=tmlngth_psm+tmlngth_p(count_eqp)
               !to get sum(x^2)
               tm_psqsm=tm_psqsm+tm_psq(count_eqp)
            enddo
            
            !Rate is given in um/min (since time is in seconds, have to multiply by 60)
            rate_p=(tmlngth_psm/tm_psqsm)*60.0
            write(6,*) 'rate_p =',rate_p
         endif

c         write(6,*) 'The number of different n-mers are:'
c         write(6,*) 'mono = ',mono
c         write(6,*) 'di = ',di
c         write(6,*) 'tri = ',tri
c         write(6,*) 'tet = ',tet
c         write(6,*) 'pent = ',pent
c         write(6,*) 'hex = ',hex
c         write(6,*) 'hept = ',hept
c         write(6,*) 'oct = ',oct
c         write(6,*) 'ennea = ',ennea
c         write(6,*) 'dec = ',dec
         
c         write(6,*) 'The number of hydrolysis events, nhydro = ',nhydro
      endif
      
      if (poly) then
      do n=1,4000
      if (kk.eq.n*500) then
                write(6,*) 'Printing configuration'
      			write(6,'(13A)') '  1 ',' 2 ',' 3 ',' 4 ',' 5 ',' 6 ',' 7 ',
     @                     ' 8 ',' 9 ',' 10',' 11',' 12',' 13'
            lmax = int(ntub/13)+112
         	do ll=lmax,102,-1
            	write(6,'(13I3)') state(1,ll),state(2,ll),state(3,ll),
     @ 	state(4,ll),state(5,ll),state(6,ll),state(7,ll),state(8,ll),
     @ 	state(9,ll),state(10,ll),state(11,ll),state(12,ll),state(13,ll)
       	 end do
       	 write(6,*) ''
       	  do ll=lmax,102,-1
     		write(6,'(13I3)') dissocstate(1,ll),dissocstate(2,ll),
     @		dissocstate(3,ll),
     @ 		dissocstate(4,ll),dissocstate(5,ll),dissocstate(6,ll),
     @		dissocstate(7,ll),
     @ 		dissocstate(8,ll),dissocstate(9,ll),dissocstate(10,ll),
     @		dissocstate(11,ll),
     @ 		dissocstate(12,ll),dissocstate(13,ll)
          end do
         write(6,*) ''
         	do ll=lmax,102,-1
     		write(6,'(13I3)') addstate(1,ll),addstate(2,ll),
     @		addstate(3,ll),
     @ 	addstate(4,ll),addstate(5,ll),addstate(6,ll),
     @		addstate(7,ll),
     @ 	addstate(8,ll),addstate(9,ll),addstate(10,ll),
     @	addstate(11,ll),
     @ 	addstate(12,ll),addstate(13,ll)
         end do
        write(6,*) ''
         	do ll=lmax,102,-1
     		write(6,'(13I3)') dep(1,ll),dep(2,ll),
     @		dep(3,ll),
     @ 	dep(4,ll),dep(5,ll),dep(6,ll),
     @		dep(7,ll),
     @ 	dep(8,ll),dep(9,ll),dep(10,ll),
     @	dep(11,ll),
     @ 	dep(12,ll),dep(13,ll)
         end do
        write(6,*) ''
        write(6,*) ''
        do ll=lmax,102,-1
     		write(6,'(13F5.1)') seammult(1,ll),seammult(2,ll),
     @		seammult(3,ll),
     @ 		seammult(4,ll),seammult(5,ll),seammult(6,ll),
     @		seammult(7,ll),
     @ 		seammult(8,ll),seammult(9,ll),seammult(10,ll),
     @		seammult(11,ll),
     @ 		seammult(12,ll),seammult(13,ll)
          end do
      endif
      enddo
      endif
      
      if (depoly) then
      if ((ntub.le.300).and.(ntub.ge.14)) then
                write(6,*) 'Printing configuration'
      			write(6,'(13A)') '  1 ',' 2 ',' 3 ',' 4 ',' 5 ',' 6 ',' 7 ',
     @                     ' 8 ',' 9 ',' 10',' 11',' 12',' 13'
            lmax = int(ntub/13)+112
         	do ll=lmax,102,-1
            	write(6,'(13I3)') state(1,ll),state(2,ll),state(3,ll),
     @ 	state(4,ll),state(5,ll),state(6,ll),state(7,ll),state(8,ll),
     @ 	state(9,ll),state(10,ll),state(11,ll),state(12,ll),state(13,ll)
       	 end do
       	 write(6,*) ''
       	  do ll=lmax,102,-1
     		write(6,'(13I3)') dissocstate(1,ll),dissocstate(2,ll),
     @		dissocstate(3,ll),
     @ 		dissocstate(4,ll),dissocstate(5,ll),dissocstate(6,ll),
     @		dissocstate(7,ll),
     @ 		dissocstate(8,ll),dissocstate(9,ll),dissocstate(10,ll),
     @		dissocstate(11,ll),
     @ 		dissocstate(12,ll),dissocstate(13,ll)
          end do
         write(6,*) ''
         	do ll=lmax,102,-1
     		write(6,'(13I3)') addstate(1,ll),addstate(2,ll),
     @		addstate(3,ll),
     @ 	addstate(4,ll),addstate(5,ll),addstate(6,ll),
     @		addstate(7,ll),
     @ 	addstate(8,ll),addstate(9,ll),addstate(10,ll),
     @	addstate(11,ll),
     @ 	addstate(12,ll),addstate(13,ll)
         end do
        write(6,*) ''
         	do ll=lmax,102,-1
     		write(6,'(13I3)') dep(1,ll),dep(2,ll),
     @		dep(3,ll),
     @ 	dep(4,ll),dep(5,ll),dep(6,ll),
     @		dep(7,ll),
     @ 	dep(8,ll),dep(9,ll),dep(10,ll),
     @	dep(11,ll),
     @ 	dep(12,ll),dep(13,ll)
         end do
        write(6,*) ''
        write(6,*) ''
        do ll=lmax,102,-1
     		write(6,'(13F5.1)') seammult(1,ll),seammult(2,ll),
     @		seammult(3,ll),
     @ 		seammult(4,ll),seammult(5,ll),seammult(6,ll),
     @		seammult(7,ll),
     @ 		seammult(8,ll),seammult(9,ll),seammult(10,ll),
     @		seammult(11,ll),
     @ 		seammult(12,ll),seammult(13,ll)
          end do
       endif
       endif      
      
c      write(6,*) 'total number of tubulins',ntub
      end do
      
      stop
      end
C
C +++++++++++++++++++++++++++++++++++++++++++
C
      subroutine AddTub(ntub,ontub,evno,xloc,yloc,state,nrecyc,recyc,
     @                  totev,addstate,evtype,nev,ev,maxlen,xo,yo,
     @                  qinit,dissocstate,event,revmap,
     @					times,k_on,conc,
     @                       GDP,K_lat,K_long,K_both,k_hyd,
     @                  K_thr_long,K_thr_lat,K_all,dist,qdebug,dep,seammult,k_ne)
c
c
      implicit none
c
c i/o variables
      integer evno,xloc(*),yloc(*),state(13,*),ntub,ontub,xo,yo
      integer nrecyc,recyc(*),totev,addstate(13,*),maxlen
      integer evtype,nev(13,*),ev(13,maxlen,4)
      logical qinit,Qcorn,qhole,Qeight,Qsurround
      integer dissocstate(13,maxlen),dist(13,maxlen)
      integer temp,ll
      double precision times(*)
      integer event(*)
      integer revmap(*)
      double precision get_evtime
      double precision k_on,conc,GDP,K_lat,K_long,K_both,K_hyd
      double precision K_thr_long,K_thr_lat,K_all,k_ne
      double precision seammult(13,*)
      logical qdebug
      integer dep(13,*)
      
      
c
c local variables
      integer i,j,k,kk,ih,jh,iv,jv,dh,dv,dd
      integer hdist,vdist,ddist,mindist,itest,jtest
      integer temph,tempv,tempd
      logical qchange,qtaken,qempty
      logical QFound
c
c begin computation
      i=xloc(evno)
      j=yloc(evno)
      nev(i,j)=nev(i,j)-1

      Qcorn=.FALSE.
      Qsurround=.FALSE.

      state(i,j) = 1
      ontub=ntub
      ntub=ntub+1
      ev(i,j,1)=0
      
c      write(6,*) 'Recycle old event number - the below specific for ADD'
      nrecyc = nrecyc+1
      recyc(nrecyc) = evno
c here we have to call min heapify
	  temp=event(1)
	  event(1)=event(totev)
	  event(totev)=temp
	  revmap(event(totev))=totev
	  revmap(event(1))=1
	  times(event(totev))=1d15
	  totev=totev-1
	  call min_heapify(event,revmap,times,1,totev)
      call hpsort(nrecyc,recyc)

      if ( (i.ne.1).and.(i.ne.13) ) then      
         if (dissocstate(i,j).eq.2) then
      	    if ((state(i-1,j).ne.0).AND.(state(i+1,j).ne.0)) then
      		   qhole=.true.
      		   write(6,*)'adding into H-hole'
      		   stop
      	   endif
         endif
      endif
      if (i.eq.1) then
         if ( (dissocstate(i,j).eq.2).and.(state(i+1,j).ne.0) ) then
            if (state(13,j+1).ne.0) then
               qhole=.true.
               write(6,*) 'adding into H-hole, pf#1, lower'
               stop
            endif
            if (state(13,j+2).ne.0) then
               qhole=.true.
               write(6,*) 'adding into H-hole, pf#1, upper'
               stop
            endif
         endif
      endif
      if (i.eq.13) then
         if ( (dissocstate(i,j).eq.2).and.(state(i-1,j).ne.0) ) then
            if (state(1,j-1).ne.0) then
               qhole=.true.
               write(6,*) 'adding into H-hole, pf#13, upper'
               stop
            endif
            if (state(1,j-2).ne.0) then
               qhole=.true.
               write(6,*) 'adding into H-hole, pf#13, lower'
            endif
         endif
      endif
      if ((dissocstate(i,j).eq.3).or.(dissocstate(i,j).eq.4)) then
      if ((state(i,j-1).ne.0).AND.(state(i,j+1).ne.0)) then
      		qhole=.true.
      		write(6,*)'adding into V-hole'
      		stop
      	endif
      endif
      
c check neighbor state to assign dissociation type

		
      
c      write(6,*) 'Add new events, first look for new adds',i,j
c first do horizontal
      if (i.eq.13) then 

         call AddTo13(i,j,dissocstate,state,addstate,dep,nev,totev,
     @                   xloc,yloc,ev,nrecyc,recyc,times,k_on,conc,
     @                   GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                   K_thr_lat,K_all,event,revmap,seammult,ntub,k_ne)     		
      
      elseif (i.eq.1) then

         call AddTo1(i,j,dissocstate,state,addstate,dep,nev,totev,
     @                   xloc,yloc,ev,nrecyc,recyc,times,k_on,conc,
     @                   GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                   K_thr_lat,K_all,event,revmap,seammult,ntub,k_ne)     		
      
      endif         
         
      if ( (i.ne.1).and.(i.ne.13) ) then
c         write(6,*) 'Not at the seam'
         do k=i-1,i+1,2
            if (state(k,j).ne.0) then
c               if (qdebug) write(6,*) 'this site is already taken: ',k,j
               if (dissocstate(i,j).eq.2) then
                  if (k.eq.(i-1)) then
                     dep(i,j)=3
                  else
                     dep(i,j)=4
                  endif
c Having some nucleotide exchange fun here...
	           elseif ((dissocstate(i,j).eq.5).or.(dissocstate(i,j).eq.6)) then
			      Qcorn=.true.
c			      write(6,*) 'Qcorn=true, dissocstate= ',dissocstate(i,j)
		       elseif ((dissocstate(i,j).eq.10).or.(dissocstate(i,j).eq.11).or.
     @	              (dissocstate(i,j).eq.12).or.(dissocstate(i,j).eq.13)) then						!
		          Qsurround=.true.																		!
c		          write(6,*) 'Qsurround=true, dissocstate= ',dissocstate(i,j)							!
		          if (addstate(i,j).ne.3) then															!
		             write(6,*) 'addstate not 3 for adding into dtype 10/12'							!
		             stop																				!
		          endif																				!
	           elseif ((dissocstate(i,j).eq.3).or.(dissocstate(i,j).eq.4)) then
c	              write(6,*) 'dissocstate=3/4',i,j
c Stoping nucleotide exchange fun here...	           
	           else
	              write(6,*) 'dissocstate eq 8?'
	              stop
	           endif
               addstate(k,j)=addstate(k,j)+1
            else
c               write(6,*) 'we have a possible addition at site: ',k,j
               if (addstate(k,j).eq.0) then
                  if ( (k.ne.0).and.(k.ne.14) ) then
C
C THIS TEST SHOULD NOT BE NECESSARY, should alwayd be true
C
c                     write(6,*) 'New addition at site: ',k,j
                     addstate(k,j)=addstate(k,j)+1
                     dissocstate(k,j)=2

                     call AddNewAdditionEvent(k,j,addstate,totev,nev,ev,nrecyc,recyc,
     @                               xloc,yloc,times,k_on,conc,GDP,K_lat,
     @                               K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                               K_all,event,revmap,seammult,k_ne)            

                  endif
                     			  
               else
c                  write(6,*) 'Already an addition at site: ',k,j
                  addstate(k,j)=addstate(k,j)+1
                  
                  temp=0

c Have some nucleotide exchange fun here...               
                  if (dissocstate(k,j).eq.3) then
                     if ( (state(k,j-1).ne.0).and.(state(k,j+1).ne.0) ) then
                        write(6,*) 'Weird dissocstate = 3, possible loop forming around ',k,j
                        stop
                     else
               	        temp=5
               	     endif
                  elseif (dissocstate(k,j).eq.4) then
                     if ( (state(k,j-1).ne.0).and.(state(k,j+1).ne.0) ) then
                        write(6,*) 'Weird dissocstate = 4, possible loop forming around ',k,j
                        stop
                     else
               	        temp=6
               	     endif
                  elseif (dissocstate(k,j).eq.2) then
                     if (k.eq.13) then
                        write(6,*) 'making a weird hole site across seam at 13'
c                        stop
                     endif
c                  write(6,*) 'making hole in Add Tub'
                     temp=2
                  elseif (dissocstate(k,j).eq.5) then												!
               	     temp=12																		!
               	  elseif (dissocstate(k,j).eq.6) then
               	     temp=13
                  elseif ((dissocstate(k,j).eq.10).or.(dissocstate(k,j).eq.11)) then				!
                     write(6,*) 'forming a loop around',k,j,'?'										!
                     stop																			!
                  elseif ((dissocstate(k,j).eq.12).or.(dissocstate(k,j).eq.13).or.
     @                   (dissocstate(k,j).eq.8)) then					!
                     write(6,*) 'bad dissocstate',dissocstate(k,j),'for',k,j						!
                     stop																			!
C
C CHANGES Above REFLECT NEW STUFF - may need to test across seam?
C
                  endif
c Stop nucleotide exchange fun here...
              
                  dissocstate(k,j)=temp
               endif
            endif
         end do
      endif
C
C Added endif above to close block
C
c now do vertical
      k=j-1
      if ( ((i.ne.1).and.(i.ne.13)) ) then
         if (k.gt.102) then
            if (state(i,k).ne.0) then
c               write(6,*) 'this site is already taken: ',i,k
C
C THE TEST BELOW SHOULD BE UNNECSESSARY
C
	           if ( (dissocstate(i,k).eq.0).and.(k.gt.102) ) then
			      write(6,*)'have founder elsewhere'
			      stop
		       endif

c Have some nucleotide exchange fun here...
               if ((dissocstate(i,j).eq.3).or.(dissocstate(i,j).eq.4)) then
                  dep(i,j)=2
		       elseif ((dissocstate(i,j).eq.5).or.(dissocstate(i,j).eq.6)) then
c		    if (.not.qcorn) write(6,*) 'weird corner'
			      Qcorn=.true.
c			      write(6,*) 'Qcorn=true, dissocstate= ',dissocstate(i,j)
		       elseif ((dissocstate(i,j).eq.10).or.(dissocstate(i,j).eq.11).or.
     @                (dissocstate(i,j).eq.12).or.(dissocstate(i,j).eq.13)) then					!
		          Qsurround=.true.																	!
c		          write(6,*) 'Qsurround=true, dissocstate= ',dissocstate(i,j)
c		    write(6,*) 'marker3: Qsurround=true'													!
	           elseif (dissocstate(i,j).eq.2) then
	           else
	              write(6,*) 'dissocstate eq 8?'
	              stop
	           endif
c Stop nucleotide exchange fun here...	           
	           addstate(i,k)=addstate(i,k)+1
            else
c               write(6,*) 'we have a possible addition at site: ',i,k
               if (addstate(i,k).eq.0) then
c                  write(6,*) 'New addition at site: ',i,k
                  addstate(i,k)=addstate(i,k)+1
                  dissocstate(i,k)=3

                  call AddNewAdditionEvent(i,k,addstate,totev,nev,ev,nrecyc,recyc,
     @                               xloc,yloc,times,k_on,conc,GDP,K_lat,
     @                               K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                               K_all,event,revmap,seammult,k_ne)            
                  
               else
c                  write(6,*) 'Already an addition at site: ',i,k
                  addstate(i,k)=addstate(i,k)+1
                  temp=0

c Have nucleotide exchange fun here...                  
                  if (dissocstate(i,k).eq.2) then
                     if ( (state(i-1,k).ne.0).and.(state(i+1,k).ne.0) ) then
                        write(6,*) 'Weird dissocstate = 2, possible loop forming around ',i,k
                        stop
                     else
                        temp=5
                     endif
                  elseif (dissocstate(i,k).eq.3) then
c               write(6,*) 'making weird stru in Addtub vert1'
                     temp=3
                  elseif (dissocstate(i,k).eq.4) then
                     temp=4
                  elseif (dissocstate(i,k).eq.5) then												!
                     temp=10																		!
                  elseif (dissocstate(i,k).eq.6) then
                     temp=11
                  elseif ((dissocstate(i,k).eq.12).or.(dissocstate(i,k).eq.13)) then				!
                     write(6,*) 'forming a loop around',i,k,'?'										!
                     stop																			!
                  elseif ((dissocstate(i,k).eq.10).or.(dissocstate(i,k).eq.11).or.
     @                   (dissocstate(i,k).eq.8)) then					!
                     write(6,*) 'bad dissocstate',dissocstate(i,k),'for',i,k						!
                     stop																			!
                  else
                     write(6,*) 'OOPS - non exhaustive dissoc check',dissocstate(i,k)
                     stop
                  endif
c Stop nucleotide exchange fun here...                  
                  dissocstate(i,k) = temp
               
               
               endif
            endif   
         else
c            write(6,*) 'looking down from add on top row, set dep'
            if (dissocstate(i,j).eq.3) then
               dep(i,j)=2
            elseif (dissocstate(i,j).eq.5) then
c               write(6,*) 'sort corner out for dep'
               if (state(i-1,j).ne.0) then
                  dep(i,j)=8
               else
                  dep(i,j)=7
               endif
            endif
         endif
      endif
      
      k=j+1
c         write(6,*) 'looking up, before seam check'
      if ( (i.ne.1).and.(i.ne.13) ) then
c         write(6,*) 'looking up, not at seam'
         if (state(i,k).ne.0) then
c               write(6,*) 'this site is already taken: ',i,k
            if ( (dissocstate(i,k).eq.0).and.(k.lt.98) ) then
		       write(6,*)'have founder elsewhere'
			   stop
	        endif
c Have some nucleotide exchange fun here...
            if ((dissocstate(i,j).eq.3).or.(dissocstate(i,j).eq.4)) then
               dep(i,j)=1
		    elseif ((dissocstate(i,j).eq.5).or.(dissocstate(i,j).eq.6)) then
c				if (.not.qcorn) write(6,*) 'weird corner'
			   Qcorn=.true.
c			   write(6,*) 'Qcorn=true, dissocstate= ',dissocstate(i,j)
			elseif ((dissocstate(i,j).eq.10).or.(dissocstate(i,j).eq.11).or.
     @             (dissocstate(i,j).eq.12).or.(dissocstate(i,j).eq.13)) then						!
			   Qsurround=.true.																		!
c               write(6,*) 'Qsurround=true, dissocstate= ',dissocstate(i,j)
	        elseif (dissocstate(i,j).eq.2) then
	        else
c	           write(6,*) 'dissocstate eq 8?'
	        endif
c Stop nucleotide exchange fun here...	        
	        addstate(i,k)=addstate(i,k)+1

               
         else
c            write(6,*) 'we have a possible addition at site: ',i,k
            if (addstate(i,k).eq.0) then
c               if (qdebug) write(6,*) 'New addition at site: ',i,k
               addstate(i,k)=addstate(i,k)+1
C
C HOW CAN I=13 here?
               if ( (i.eq.13).and.(state(1,k-2).eq.0) ) then 
                  dissocstate(i,k)=3
               elseif ( (i.eq.13).and.(state(1,k-2).ne.0) ) then
                  dissocstate(i,k)=1
               else
                  dissocstate(i,k)=3
               endif

               call AddNewAdditionEvent(i,k,addstate,totev,nev,ev,nrecyc,recyc,
     @                               xloc,yloc,times,k_on,conc,GDP,K_lat,
     @                               K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                               K_all,event,revmap,seammult,k_ne)            

            else
c                  if (qdebug) write(6,*) 'Already an addition at site: ',i,k
               addstate(i,k)=addstate(i,k)+1
               temp=0

c Start nucleotide exchange fun here...                  
               if (dissocstate(i,k).eq.2) then
                  if ( (state(i-1,k).ne.0).and.(state(i+1,k).ne.0) ) then
                     if ((dissocstate(i,j).eq.12).or.(dissocstate(i,j).eq.13)) then
                        temp=12
                     else
                        write(6,*) 'Weird dissocstate = 2, possible loop forming around ',i,k
                        stop
                     endif
                  else
                     temp=5
                  endif
               elseif (dissocstate(i,k).eq.3) then
c                     write(6,*) 'making weird stru in Addtub vert1'
                  temp=3
               elseif (dissocstate(i,k).eq.4) then
                  temp=4
               elseif (dissocstate(i,k).eq.5) then													!
                  temp=10																			!
               elseif (dissocstate(i,k).eq.6) then
                  temp=11
               elseif ((dissocstate(i,k).eq.12).or.(dissocstate(i,k).eq.13)) then					!
                     write(6,*) 'forming a loop around',i,k,'?'										!
                     stop																			!
               elseif ((dissocstate(i,k).eq.10).or.(dissocstate(i,k).eq.11).or.
     @                (dissocstate(i,k).eq.8)) then					!
                     write(6,*) 'bad dissocstate',dissocstate(i,k),'for',i,k						!
                     stop																			!
               else
                  write(6,*) 'OOPS - non exhaustive dissoc check2',dissocstate(i,k)
                  stop
               endif
c Stop nucleotide exchange fun here...               
                  
               dissocstate(i,k)=temp
                  
            endif
               
         endif
      endif

c      write(6,*) 'before Qsurround'
      
            if (Qsurround) then
C
C CHANGES GO HERE - need to customize for first layer
C
               if (j.eq.103) then
                  if (i.eq.1) then
                     write(6,*) 'adding into Qsurround, first layer, pf1'
                     stop
                  elseif (i.eq.13) then
                     write(6,*) 'adding into Qsurround, first layer, pf13'
                     stop
                   else
C
C the stuff below is probably needlessly duplicated. if i filter out the seam 1st row takes care of itself
C          
c                      write(6,*) 'adding into Qsurround, not at seam'
c Start nucleotide exchange fun here...                      
                      if ((dissocstate(i,j).eq.12).or.(dissocstate(i,j).eq.13)) then				!
c End nucleotide exchange fun here...                      
                         if (state(i,j+1).eq.0) then							                            ! Empty ABOVE
                            call EIemptyabove(i,j,dep,dissocstate,addstate,state,times,event,revmap,ev,totev,nev,
     @                              nrecyc,recyc,xloc,yloc,k_on,conc,
     @                              GDP,K_lat,K_long,K_both,K_hyd,K_thr_long,K_thr_lat,K_all,seammult,k_ne) 
                         else
                            write(6,*) 'Qsurround, first row, not empty above'
                            stop
                         endif
                      else
                         write(6,*) 'Qsurround, not dstate=12'
                         stop
                      endif
                   endif
               endif
               
               if (j.gt.103) then
c               write(6,*) 'Qsurround, not near template'
c Start nucleotide exchange fun here...               
               if ((dissocstate(i,j).eq.12).or.(dissocstate(i,j).eq.13)) then						!
c End nucleotide exchange fun here...               
c                  write(6,*) 'marker9: Qsurround 12 Empty above/below'												!
                  if (state(i,j+1).eq.0) then							                            ! Empty ABOVE
c                     write(6,*) 'seammult b4 eiempty',seammult(i-1,j)
                     call EIemptyabove(i,j,dep,dissocstate,addstate,state,times,event,revmap,ev,totev,nev,
     @                              nrecyc,recyc,xloc,yloc,k_on,conc,
     @                              GDP,K_lat,K_long,K_both,K_hyd,K_thr_long,K_thr_lat,K_all,seammult,k_ne)
                  elseif (state(i,j-1).eq.0) then							                        ! Empty BELOW
                     call EIemptybelow(i,j,dep,dissocstate,addstate,state,times,event,revmap,ev,totev,nev,
     @                              nrecyc,recyc,xloc,yloc,k_on,conc,
     @                              GDP,K_lat,K_long,K_both,K_hyd,K_thr_long,K_thr_lat,K_all)
                  else																				!
                     write(6,*) 'adding to type 12/13, no empties'         							!
                     stop																			!
                  endif																				!
c Start nucleotide exchange fun here...                  
               elseif ((dissocstate(i,j).eq.10).or.(dissocstate(i,j).eq.11)) then					!
c End nucleotide exchange fun here...               
c                  write(6,*) 'marker10: Qsurround 10 Empty left/right'												!
                  if (state(i-1,j).eq.0) then														! Empty LEFT
                     call EIemptyleft(i,j,dep,dissocstate,addstate,state,times,event,revmap,ev,totev,nev,
     @                              nrecyc,recyc,xloc,yloc,k_on,conc,
     @                              GDP,K_lat,K_long,K_both,K_hyd,K_thr_long,K_thr_lat,K_all,seammult,k_ne)
                  elseif (state(i+1,j).eq.0) then													! Empty Right
                     call EIemptyright(i,j,dep,dissocstate,addstate,state,times,event,revmap,ev,totev,nev,
     @                              nrecyc,recyc,xloc,yloc,k_on,conc,
     @                              GDP,K_lat,K_long,K_both,K_hyd,K_thr_long,K_thr_lat,K_all,seammult,k_ne)
                  else																				!
                     write(6,*) 'adding to type 10/11, no empties'         							!
                     stop																			!
                  endif																				!
               endif
               endif !
            endif
            
            if (QCORN) then
     
               if (j.gt.102) then
                  if (state(i,j-1).ne.0) then			!added June 13: originally would just look down.
                     iv=i
                     jv=j-1
                  else
                     iv=i
                     jv=j+1
                  endif
                  if ( (i.ne.1).and.(i.ne.13) ) then
                     if (state(i-1,j).ne.0) then
                        ih=i-1
                        jh=j
                     else
                        ih=i+1
                        jh=j
                     endif
                  elseif (i.eq.1) then
c                     write(6,*) 'i=1, top corner'
                     if (state(2,j).ne.0) then
                        ih=2
                        jh=j
                     else
                        ih=13
                        jh=j+1
                     endif
                  elseif (i.eq.13) then
c                     write(6,*) 'i=13, top corner'
                     if (state(12,j).ne.0) then
                        ih=12
                        jh=j
                     else
                        ih=1
                        jh=j-1
                     endif
                  endif
               endif
               if (j.lt.98) then
                  iv=i
                  jv = j+1
                  if ( (i.ne.1).and.(i.ne.13) ) then
                     if (state(i-1,j).ne.0) then
                        ih=i-1
                        jh=j
                     else
                        ih=i+1
                        jh=j
                     endif
                  elseif (i.eq.1) then
c                     write(6,*) 'i=1, bot corner'
                     if (state(2,j).ne.0) then
                        ih=2
                        jh=j
                     else
                        ih=13
                        jh=j+1
                     endif
                  elseif (i.eq.13) then
c                     write(6,*) 'i=13, bot corner'
                     if (state(12,j).ne.0) then
                        ih=12
                        jh=j
                     else
                        ih=1
                        jh=j-1
                     endif
                  endif
               endif
c		       write(6,*) 'this is the diagonal',ih,jv
		       
		       dh=dissocstate(ih,jh)
		       dv=dissocstate(iv,jv)
		       dd=dissocstate(ih,jv)

c               write(6,*) 'QCORN'
c               write(6,*) 'dissocstates before (h,v,d): ',dissocstate(ih,jh),dissocstate(iv,jv),dissocstate(ih,jv)
c               write(6,*) 'deps before (h,v,d): ',dep(ih,jh),dep(iv,jv),dep(ih,jv)
               
               temph=dh
               tempv=dv
               tempd=dd

		       if ( (jv.eq.102).or.(jv.eq.98) ) then
		          if (jv.eq.102) then 
c		             write(6,*) 'making corner on first layer, top',ih,jh,dissocstate(ih,jh)
		             if (ih.gt.i) then
		                dep(i,j)=7
		                if (dissocstate(ih,jh).lt.5)  dep(ih,jh)=8
		             else
		                dep(i,j) = 8
		                if (dissocstate(ih,jh).lt.5)  dep(ih,jh)=7
		             endif
		          endif
c		          if (jv.eq.98) write(6,*) 'making corner on first layer, bot',ih,jh,dissocstate(ih,jh)
		          temph = dissocstate(ih,jh)
C
C CHANGED the logic below: 5 -> 12, 6->13
C
		          if (dissocstate(ih,jh).eq.3) then
		             dissocstate(ih,jh)=5
		          elseif (dissocstate(ih,jh).eq.4) then
		             dissocstate(ih,jh)=6
		          elseif (dissocstate(ih,jh).eq.5) then
		             dissocstate(ih,jh)=12
		          elseif (dissocstate(ih,jh).eq.6) then
		             dissocstate(ih,jh)=13		          
		          elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then
		             dissocstate(ih,jh)=8
		          else
		             write(6,*) 'bad dissocstate on top layer corner add',dissocstate(ih,jh)
		          endif

                  if (temph.ne.dissocstate(ih,jh)) then
c                     write(6,*) 'update dissoc times', ih,jh,dissocstate(ih,jh)
c                     dissocstate(ih,jh)=temph
                     times(ev(ih,jh,2))=get_evtime(dissocstate(ih,jh),k_on,conc,GDP,
     @                                       K_lat,K_long,K_both,k_hyd,
     @                                       K_thr_long,K_thr_lat,K_all,k_ne,seammult(ih,jh))
c                     write(6,*) 'ev(ih,jh,2)',ev(ih,jh,2)
                     call update(event,revmap,ev(ih,jh,2),times(ev(ih,jh,2)),times,totev)
c                     write(6,*) 'times(ev(ih,jh,2))',ih,jh,times(ev(ih,jh,2)),dissocstate(ih,jh)
                  endif


		       else   ! the above is for first top/bottom layers
		       
		          if (dd.ge.8) then
C
C CHANGED HERE, check other subs for new arguments and elim conc_di if necessary
C Do I need to worry about seam?
C
c		          write(6,*) 'dd surrounded'
                     call QCornDiagSurround (i,j,ih,jh,iv,jv,temph,tempv,tempd,dep,dissocstate,state)
			      elseif ((dh.lt.5).AND.(dv.lt.5)) then
			         if ((dd.eq.5).OR.(dd.eq.6)) then
c			         write(6,*) 'Corner/diagonal 5 or 6'
                        call QCornDiagFiveSix (i,j,ih,jh,iv,jv,temph,tempv,tempd,dep,dissocstate,state)
				     elseif (dd.lt.5) then
c				     write(6,*) 'all subunits of dissocstate lt 5'
				        call QCornAllLTFive (i,j,ih,jh,iv,jv,temph,tempv,tempd,dep,dissocstate,state)
				     endif
			      elseif ((dh.ge.5).AND.(dv.ge.5)) then
c			      write(6,*) 'adding into 5-5 corner'
                     call QCornFiveFiveCorner (i,j,ih,jh,iv,jv,temph,tempv,tempd,dep,dissocstate,state)
			      else
c			      write(6,*) 'adding to 5/not 5 corner'
			         call QCornFiveNotFive (i,j,ih,jh,iv,jv,temph,tempv,tempd,dep,dissocstate,state)
			      endif
c   Update...	
                  if (j.gt.103) then
                     if (temph.ne.dh) then                  
                        dissocstate(ih,jh)=temph
                        times(ev(ih,jh,2))=get_evtime(dissocstate(ih,jh),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(ih,jh))
c Adding code to check for double GDP for dstate 11.
                        if (temph.eq.11) then
                           if ((state(ih,jh).eq.-1).and.(state(ih,jh-1).eq.-1)) then
c                              write(6,*) 'double GDP, recalculate times'
                              times(ev(ih,jh,2))=times(ev(ih,jh,2))*GDP
                           else
c                              write(6,*) 'single GDP, do nothing'
                           endif
                        endif
cccccccccccccccccccccccccccccccccccccccccccccccccccc
                        call update(event,revmap,ev(ih,jh,2),times(ev(ih,jh,2)),times,totev)
                     endif
                     if (tempv.ne.dv) then                  
                        dissocstate(iv,jv)=tempv
                        times(ev(iv,jv,2))=get_evtime(dissocstate(iv,jv),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(iv,jv))
c Adding code to check for double GDP for dstate 11.
                        if (tempv.eq.11) then
                           if ((state(iv,jv).eq.-1).and.(state(iv,jv-1).eq.-1)) then
c                              write(6,*) 'double GDP, recalculate times'
                              times(ev(iv,jv,2))=times(ev(iv,jv,2))*GDP
                           else
c                              write(6,*) 'single GDP, do nothing'
                           endif
                        endif
cccccccccccccccccccccccccccccccccccccccccccccccccccc
                        call update(event,revmap,ev(iv,jv,2),times(ev(iv,jv,2)),times,totev)
                     endif
                     if (tempd.ne.dd) then                  
                        dissocstate(ih,jv)=tempd
                        times(ev(ih,jv,2))=get_evtime(dissocstate(ih,jv),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(ih,jv))
c Adding code to check for double GDP for dstate 11.
                        if (tempd.eq.11) then
                           if ((state(ih,jv).eq.-1).and.(state(ih,jv-1).eq.-1)) then
c                              write(6,*) 'double GDP, recalculate times'
                              times(ev(ih,jv,2))=times(ev(ih,jv,2))*GDP
                           else
c                              write(6,*) 'single GDP, do nothing'
                           endif
                        endif
cccccccccccccccccccccccccccccccccccccccccccccccccccc
                        call update(event,revmap,ev(ih,jv,2),times(ev(ih,jv,2)),times,totev)
                     endif
c                     write(6,*) 'dissocstates after (h,v,d): ',dissocstate(ih,jh),dissocstate(iv,jv),
c     @            dissocstate(ih,jv)
c                     write(6,*) 'deps after (h,v,d): ',dep(ih,jh),dep(iv,jv),dep(ih,jv)
                  endif
               endif  
            endif
            
c            write(6,*) 'after Qcorn'
      if ( (i.ne.1).and.(i.ne.13) ) then
c
c look up to see if we can hydrolyze gtp
      if (state(i,j+1).ne.0) then
c         write(6,*) 'there is a new hydrolysis at site: ',i,j
         call AddNewHydroEvent(i,j,addstate,totev,nev,ev,nrecyc,recyc,
     @                               xloc,yloc,times,k_on,conc,GDP,K_lat,
     @                               K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                               K_all,event,revmap,seammult,k_ne)            
      end if       		
c
c look down to see if down can hydrolyze gtp

c Have some nucleotide exchange fun here...      
      if ((state(i,j-1).eq.1).and.(j.gt.103)) then
c            write(6,*) 'there is a new hydrolysis at site: ',i,j-1
            call AddNewHydroEvent(i,j-1,addstate,totev,nev,ev,nrecyc,recyc,
     @                               xloc,yloc,times,k_on,conc,GDP,K_lat,
     @                               K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                               K_all,event,revmap,seammult,k_ne)
      elseif ((state(i,j-1).eq.-1).and.(j.gt.103)) then
c         write(6,*) 'already hydrolyzed at: ',i,j-1
      endif
c Stop nucleotide exchange fun here...      

c below is dissociation portion
c	  write(6,*) 'new dissociation: ',i,j
      call AddNewDissocEvent(i,j,addstate,totev,nev,ev,nrecyc,recyc,
     @                               xloc,yloc,times,k_on,conc,GDP,K_lat,
     @                               K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                               K_all,event,revmap,seammult,k_ne)
      endif
      
c Checking subunit below to see if Nuc Ex event needs to be removed...								!new for nuc ex
      if (j.gt.103) then
c         write(6,*) 'subunit below is not in template'
         if (state(i,j-1).eq.-1) then
c            write(6,*) 'subunit below has proper state for NucEx removal: ',state(i,j-1)
            if (ev(i,j-1,4).ne.0) then
c               write(6,*) 'NucEx to be removed at ',i,j-1,ev(i,j-1,4)
               call RemoveNucExEvent(i,j-1,nrecyc,recyc,revmap,
     @                            ev,nev,event,times,totev)
            else
               write(6,*) 'bad event/state?',i,j-1,ev(i,j-1,4)
               stop
            endif
         else
c            write(6,*) 'subunit below doesnt have proper state for NucEx removal: ',state(i,j-1)
            if (ev(i,j-1,4).ne.0) then
               write(6,*) 'bad event/state?',i,j-1,ev(i,j-1,4)
               stop
            else
c               write(6,*) 'no event to remove'
            endif
         endif
      else
c         write(6,*) 'subunit below is in template, do nothing'
      endif
      
      return
      end
    
C
C +++++
C
      subroutine UpdateEmptyUp(state,i,j,addstate,dissocstate,event,revmap,
     @                         totev,nev,ev,nrecyc,recyc,xloc,yloc,
     @                         times,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,seammult,k_ne)
      
      integer state(13,*),addstate(13,*),dissocstate(13,*),i,j
      integer event(*),revmap(*)
      integer totev,nrecyc,recyc(*),xloc(*),yloc(*),nev(13,*),ev(13,2000,*)
      
      double precision k_on,conc,GDP,K_lat,K_long,K_both,k_hyd,k_ne
      double precision K_thr_long,K_thr_lat,K_all,times(*)
      double precision seammult(13,*)
      
         Qadd=.false.      

c         write(6,*) 'the site above is not taken',i,j+1
         if (addstate(i,j+1).gt.0) then
c            write(6,*) 'already an addition at ',i,j+1
            addstate(i,j+1)=addstate(i,j+1)+1
            if (dissocstate(i,j+1).eq.2) then
               if ((dissocstate(i,j).ge.12).and.(addstate(i,j+1).gt.2)) then
                  dissocstate(i,j+1)=12
               else
                  dissocstate(i,j+1)=5
               endif
            else
               write(6,*) 'need to treat other possible dstates'
               stop
            endif
         else
c            write(6,*) 'new addition at ',i,j+1
            addstate(i,j+1) = addstate(i,j+1)+1
            dissocstate(i,j+1) = 3
            
            totev=totev+1
            nev(i,j+1)=nev(i,j+1)+1
c call get_evtime here
            if (nrecyc.eq.0) then
               xloc(totev)=i
               yloc(totev)=j+1
               ev(i,j+1,1)=totev
            else
               ev(i,j+1,1)=recyc(1)
			   xloc(recyc(1))=i
			   yloc(recyc(1))=j+1
			   if (nrecyc.gt.1) then
			      recyc(1)=recyc(nrecyc)
			      call hpsort(nrecyc-1,recyc)
			   endif
			   nrecyc=nrecyc-1
            endif
c            write(6,*) 'just before times'   
                  
            times(ev(i,j+1,1))=get_evtime(1,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(i,j+1))
    
    		event(totev)=ev(i,j+1,1)
    	    revmap(ev(i,j+1,1))=totev
    	
  			call build_min_heap(event,revmap,times,totev)

         endif
      
      return
      end
C
C +++++
C
      subroutine UpdateEmptyDo(state,i,j,addstate,dissocstate)
      
      integer state(13,*),addstate(13,*),dissocstate(13,*),i,j

c         write(6,*) 'the site below is not taken',i,j-1
         if (addstate(i,j-1).eq.0) then
c            write(6,*) 'new addition at ',i,j-1
            addstate(i,j-1) = addstate(i,j-1)+1
            dissocstate(i,j-1) = 3
         else
c            write(6,*) 'already an addition at ',i,j-1
            addstate(i,j-1)=addstate(i,j-1)+1
            if (dissocstate(i,j-1).eq.12) then
               dissocstate(i,j-1)=8
               write(6,*) 'this is making a weird hole'
               stop
            elseif (dissocstate(i,j-1).eq.5) then
               dissocstate(i,j-1)=10
            elseif (dissocstate(i,j-1).eq.2) then
               dissocstate(i,j-1)=5
            else
               write(6,*) 'need to treat other possible dstates'
               stop
            endif
         endif

      return
      end
C
C +++++
C
      subroutine UpdateEmptyLe(state,i,j,addstate,dissocstate,Qadd)
      
      integer state(13,*),addstate(13,*),dissocstate(13,*),i,j
      logical Qadd
      
      

c         write(6,*) 'the site left is not taken',i-1,j
         if (addstate(i-1,j).gt.0) then
            Qadd=.false.
c            write(6,*) 'already an addition at ',i-1,j
            addstate(i-1,j)=addstate(i-1,j)+1
c Start nucleotide exchange fun here...            
            if ((dissocstate(i-1,j).eq.10).or.(dissocstate(i-1,j).eq.11)) then
               dissocstate(i-1,j)=8
            elseif (dissocstate(i-1,j).eq.6) then
               dissocstate(i-1,j)=13
            elseif (dissocstate(i-1,j).eq.5) then
               dissocstate(i-1,j)=12
            elseif (dissocstate(i-1,j).eq.4) then
               dissocstate(i-1,j)=6
            elseif (dissocstate(i-1,j).eq.3) then
               dissocstate(i-1,j)=5
            elseif (dissocstate(i-1,j).eq.2) then
c               write(6,*) 'leave dstate at 2, creating hole'
            else
               write(6,*) 'need to treat other possible dstates'
               stop
            endif
c End nucleotide exchange fun here...            
         else
            Qadd=.true.
c            write(6,*) 'new addition at ',i-1,j
            addstate(i-1,j) = addstate(i-1,j)+1
            dissocstate(i-1,j) = 2
         endif

      return
      end
C
C +++++
C
      subroutine UpdateEmptyRi(state,i,j,addstate,dissocstate,Qadd)
      
      integer state(13,*),addstate(13,*),dissocstate(13,*),i,j
      logical Qadd

c         write(6,*) 'the site right is not taken',i+1,j
         if (addstate(i+1,j).gt.0) then
            Qadd=.false.
            addstate(i+1,j)=addstate(i+1,j)+1
c Start nucleotide exchange fun here...            
            if ((dissocstate(i+1,j).eq.10).or.(dissocstate(i+1,j).eq.11)) then
               dissocstate(i+1,j)=8
            elseif (dissocstate(i+1,j).eq.6) then
               dissocstate(i+1,j)=13
            elseif (dissocstate(i+1,j).eq.5) then
               dissocstate(i+1,j)=12
            elseif (dissocstate(i+1,j).eq.4) then
               dissocstate(i+1,j)=6
            elseif (dissocstate(i+1,j).eq.3) then
               dissocstate(i+1,j)=5
            elseif (dissocstate(i+1,j).eq.2) then
c               write(6,*) 'leave dstate at 2, creating hole'
            else
               write(6,*) 'need to treat other possible dstates'
               stop
            endif
c End nucleotide exchange fun here...            
         else
            Qadd=.true.
c            write(6,*) 'new addition at ',i+1,j
            addstate(i+1,j)=addstate(i+1,j)+1
            dissocstate(i+1,j) = 2
         endif

      return
      end
      
    
    
           subroutine SubTub(ntub,ontub,evno,xloc,yloc,state,nrecyc,recyc,
     @      			totev,addstate,nev,ev,maxlen,qinit,xo,yo,
     @ 			dissocstate,test,temp,event,times,revmap,k_on,conc,
     @          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,
     @          dist,qdebug,dep,seammult,k_ne)
     
      implicit none
c
c i/o variables
      integer evno,xloc(*),yloc(*),state(13,*),ntub,ontub
      integer nrecyc,recyc(*),totev,addstate(13,*),maxlen
      integer nev(13,*),ev(13,maxlen,4)
      integer xo,yo
      integer dissocstate(13,maxlen)
      integer test
      integer event(*)
      integer revmap(*)
      integer dist(13,maxlen)
      integer dep(13,maxlen)
      double precision times(*)
      double precision get_evtime
      double precision k_on,conc,GDP,K_lat,K_long,K_both,k_hyd
      double precision K_thr_long,K_thr_lat,K_all,k_ne
      double precision seammult(13,*)
c	  logical variable
	  logical qinit,QCORN,qwipe,qhole,qdebug,Qsurround
	  
c local variables
      integer i,j,k,kk,index,ii,jj,count,imin,jmin,mindist,ll
      integer ih,jv,iv,jh,dh,dv,dd
      integer temph,tempv,tempd
      integer temph1,tempv1,tempd1
      integer temph2,tempv2,tempd2
      integer temph3,tempv3,tempd3
      double precision xop,xom,yop,yom
      integer nremove,nlist,xspec,yspec,xspec2,yspec2,xspec3,yspec3,mm,nn
      integer xrem(13*maxlen),yrem(13*maxlen),icount,odissoc(13,maxlen),odep(13,maxlen)
c Temporary variable
	  integer temp,jjj,iii,itaken
	  logical qlisted(13,maxlen),qlisted1(13,maxlen),qlisted2(13,maxlen),qspec,qfound
      
c begin computation
c      write(6,*) 'Inside SubTub'
	  i=xloc(evno)
      j=yloc(evno)
      qwipe=.false.
      qhole=.false.
c      write(6,*) 'nrecyc',nrecyc
c      do kk=1,nrecyc
c         write(6,*) 'nrecyc-beginning',kk,recyc(kk)
c      end do
c
c 
c      write(6,*) 'Losing tub at ',i,j,'totev= ',totev
c       			do kk=1,totev
c         			write(6,*) 'times ',kk,times(event(kk)),event(kk),revmap(kk)
c      				end do

c
c		 capture founder dissociating
c   Need to save some old values needed for subunit wiping before is reinitialized.
      odissoc(i,j) = dissocstate(i,j)							!Saves original dissocstate
      odep(i,j) = dep(i,j)										!Saves original dependency
      ontub = ntub												!Saves original number of tubulin
c      write(6,*) 'First thing to do: vacate the site'
      state(i,j) = 0
      ntub=ntub-1
      ev(i,j,2)=0
      dep(i,j)=9
      QCORN=.FALSE.
      Qsurround=.false.

c      write(6,*) 'Recycle old event number',evno,totev,event(1)
      nrecyc = nrecyc+1
      recyc(nrecyc) = evno
      
      temp=event(1)
	  event(1)=event(totev)
	  event(totev)=temp
	  revmap(event(totev))=totev
	  revmap(event(1))=1
	  times(event(totev))=1d15
	  totev=totev-1
	  
	  call min_heapify(event,revmap,times,1,totev)
      				
	  call hpsort(nrecyc,recyc)
c      write(6,*) 'after hpsort'
      
c Remove hydrolysis event if the site has one (for dstates 10/11).
      if (ev(i,j,3).ne.0) then
c         write(6,*) 'Lose Hydrolysis at : ',i,j,ev(i,j,3)
         call RemoveHydroEvent(i,j,nrecyc,recyc,revmap,ev,nev,
     @                        addstate,event,times,totev)
      endif
      
c Remove NucEx event if the site has one...(no way to know state-wise once state is set to 0 above)	!new for nuc ex
      if (ev(i,j,4).ne.0) then
c         write(6,*) 'NucEx to be removed at ',i,j,ev(i,j,4)
         call RemoveNucExEvent(i,j,nrecyc,recyc,revmap,
     @                            ev,nev,event,times,totev)
      endif
c Checking subunit below to see if Nuc Ex event needs to be added...								!new for nuc ex
      if (j.gt.103) then
c         write(6,*) 'subunit below is not in template'
         if (state(i,j-1).eq.-1) then
c            write(6,*) 'subunit has proper state for NucEx addition: ',state(i,j-1)
            if (ev(i,j-1,4).eq.0) then
c               write(6,*) 'NucEx to be added at ',i,j-1,ev(i,j-1,4)
               call AddNewNucExEvent(i,j-1,totev,nev,ev,nrecyc,recyc,xloc,
     @                            yloc,times,k_on,conc,GDP,K_lat,K_long,
     @                            K_both,k_hyd,K_thr_long,K_thr_lat,K_all,
     @                            event,revmap,seammult,k_ne)
            else
               write(6,*) 'bad event/state?',i,j-1,ev(i,j-1,4)
               stop
            endif
         elseif (state(i,j-1).eq.1) then
c            write(6,*) 'subunit doesnt have proper state for NucEx addition: ',state(i,j-1)
            if (ev(i,j-1,4).ne.0) then
               write(6,*) 'bad event?',i,j-1,ev(i,j-1,4)
               stop
            else
c               write(6,*) 'no event to add'
            endif
         elseif (state(i,j-1).eq.0) then
c            write(6,*) 'going to see origins of dissociation'
            if (dissocstate(i,j).eq.2) then
c               write(6,*) 'dstate=2, should be empty below'
            else
               write(6,*) 'either bad state or need to put in more conditions'
               stop
            endif
         endif
      else
c         write(6,*) 'subunit below is in template, do nothing'
      endif      
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc      
      
      if (i.eq.1) then
C
C CHANGE HERE - make sure nev gets subtracted in SubFrom routines
C
         call SubFrom1(ntub,i,j,state,addstate,dissocstate,dep,ev,nev,
     @                    nrecyc,recyc,event,revmap,totev,times,k_on,
     @                    conc,GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,seammult,k_ne)
     
      elseif (i.eq.13) then
      
         call SubFrom13(ntub,i,j,state,addstate,dissocstate,dep,ev,nev,
     @                    nrecyc,recyc,event,revmap,totev,times,k_on,
     @                    conc,GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,seammult,k_ne)
     
      endif
      
      nev(i,j)=nev(i,j)-1
c      write(6,*) 'Location of event: ',i,j
c      write(6,*) 'addstate of i,j',addstate(i,j)

      
c Have some nucleotide exchange fun here...

c      if (state(i,j-1).eq.-1) state(i,j-1)=1
c      if (dissocstate(i,j).eq.4) then
c         dissocstate(i,j)=3
c      elseif (dissocstate(i,j).eq.6) then
c         dissocstate(i,j)=5
c      elseif (dissocstate(i,j).eq.11) then															!
c         dissocstate(i,j)=10																		!
c      elseif (dissocstate(i,j).eq.13) then															!
c         dissocstate(i,j)=12																		!
c      endif																							!

c End nucleotide exchange fun here...
      
C
C PUT IN QSURROUND
C
      if ((dissocstate(i,j).eq.5).OR.(dissocstate(i,j).eq.6)) then
      	QCORN=.TRUE.
c      	write(6,*) 'DISSOCIATING CORNER'
      elseif ((dissocstate(i,j).eq.10).or.(dissocstate(i,j).eq.11).or.								!
     @       (dissocstate(i,j).ge.12)) then															!
         Qsurround=.true.																			!
c         write(6,*) 'dissociating 10-13'															!
c         write(6,*) 'marker1112'																	!
c         stop																						!
      elseif (dissocstate(i,j).ge.8) then
      	write(6,*) 'dissociating type 8'
      	stop
      endif
      
      
c	write(6,*) 'Take off old events if necessary'
	
	  if ( (i.ne.1).and.(i.ne.13) ) then
      
      if (QCORN) then
c         if (qdebug) write(6,*) 'getting diagonal to',i,j
         
            if (addstate(i,j).eq.2) then
c               write(6,*) 'only 2 neighbs'
               if (state(i-1,j).ne.0) then
                  ih=i-1
               else
                  ih=i+1
               endif
               if (state(i,j-1).ne.0) then
                  jv=j-1
               else
                  jv=j+1
               endif
            elseif (addstate(i,j).eq.3) then
               write(6,*) 'three neighbs, add check to test if BOTH diags occupied'
               if (state(i,j+1).eq.0) then
                  jv=j-1
                  if (state(i-1,jv).eq.0) then
                     ih=i+1
                  else
                     ih=i-1
                  endif
               elseif (state(i,j-1).eq.0) then
                  jv=j+1
                  if (state(i-1,jv).eq.0) then
                     ih=i+1
                  else
                     ih=i-1
                  endif
               elseif (state(i-1,j).eq.0) then
                  ih=i+1
                  if (state(ih,j-1).eq.0) then
                     jv=j+1
                  else
                     jv=j-1
                  endif
               elseif (state(i+1,j).eq.0) then
                  ih=i-1
                  if (state(ih,j-1).eq.0) then
                     jv=j+1
                  else
                     jv=j-1
                  endif
               endif
            elseif (addstate(i,j).eq.4) then
c               write(6,*) 'four neighbs'
               if (odep(i,j).eq.0) then
                  write(6,*) 'Stop! Removing founder!'
                  stop
               endif
               if (odep(i,j).eq.1) then
                  jv=j+1
                  if (dep(i-1,j).eq.6) then
                     ih=i-1
                  elseif (dep(i+1,j).eq.5) then
                     ih=i+1
                  else
                     write(6,*) 'Subunit not in a square?!'
                     stop
                  endif
               endif
               if (odep(i,j).eq.2) then
                  jv=j-1
                  if (dep(i-1,j).eq.7) then
                     ih=i-1
                  elseif (dep(i+1,j).eq.8) then
                     ih=i+1
                  else
                     write(6,*) 'Subunit not in a square?!'
                     stop
                  endif
               endif
               if (odep(i,j).eq.3) then
                  ih=i-1
                  if (dep(i,j-1).eq.5) then
                     jv=j-1
                  elseif (dep(i,j+1).eq.8) then
                     jv=j+1
                  else
                     write(6,*) 'Subunit not in a square?!'
                     stop
                  endif
               endif
               if (odep(i,j).eq.4) then
                  ih=i+1
                  if (dep(i,j-1).eq.6) then
                     jv=j-1
                  elseif (dep(i,j+1).eq.7) then
                     jv=j+1
                  else
                     write(6,*) 'Subunit not in a square?!'
                     stop
                  endif
               endif
               if (odep(i,j).eq.5) then
                  ih=i-1
                  jv=j+1
               endif
               if (odep(i,j).eq.6) then
                  ih=i+1
                  jv=j+1
               endif
               if (odep(i,j).eq.7) then
                  ih=i+1
                  jv=j-1
               endif
               if (odep(i,j).eq.8) then
                  ih=i-1
                  jv=j-1
               endif
               if (odep(i,j).eq.9) then
                  write(6,*) 'Subunit has no dependency?! Dep = ',dep(i,j)
                  stop
               endif
            else
               write(6,*) 'bad neighb calc in dissoc corner'
               stop
            endif
            iv=i
            jh=j
         
c         if (qdebug) write(6,*) 'diagonal to',i,j,' is ',ih,jv
         
         
C        (QFound)
C        Subtracting from a corner with founder in relevant square.

c
c LR chopped out all founder related corner stuff
c            write(6,*) 'corner NOT founder subtub'
c            write(6,*) 'dissocstates before, h,v,d: ',dissocstate(ih,jh),dissocstate(iv,jv),dissocstate(ih,jv)
c            write(6,*) 'deps before (h,v,d): ',dep(ih,jh),dep(iv,jv),dep(ih,jv)

            dh = dissocstate(ih,jh)
            dv = dissocstate(iv,jv)
            dd = dissocstate(ih,jv)
            
            temph=dh
            tempv=dv
            tempd=dd

C        .not.(QFound)
C        Subtracting from a corner with founder not in relevant square.         
            if ((ih.gt.i).and.(jv.gt.j)) then														!Subtracting from lower left
c               write(6,*) 'sub from lower left, no founder (SubLowLef)'
               call SubLowLef(dep,dissocstate,state,ih,jh,iv,jv,temph,tempv,tempd)       
            elseif ((ih.gt.i).and.(jv.lt.j)) then													!Subtracting from upper left
               if (j.eq.103) then
c                  write(6,*) 'special case, on the top row' !only worry about right neighbor
                  if (dissocstate(i+1,j).eq.8) then
                     if (state(i+1,j).eq.1) then
                        temph=10
                     else
                        temph=11
                     endif
                     dep(i+1,j)=7
                  elseif (dissocstate(i+1,j).eq.5) then
c                     write(6,*) 'set dissoc of right neighb to 3'
                     temph = 3
                     dep(i+1,j) = 2
                  elseif (dissocstate(i+1,j).eq.6) then
c                     write(6,*) 'set dissoc of right neighb to 4'
                     temph = 4
                     dep(i+1,j) = 2
                  elseif (dissocstate(i+1,j).eq.12) then
c                     write(6,*) 'set dissoc of right neighb to 5'
                     temph = 5
                     dep(i+1,j) = 7
                  elseif (dissocstate(i+1,j).eq.13) then
c                     write(6,*) 'set dissoc of right neighb to 6'
                     temph = 6
                     dep(i+1,j) = 7
                  else
                     write(6,*) 'bizarre dissocstate to the right'
                     stop
                  endif
                  
               else
c                  write(6,*) 'sub from upper left, no founder (SubUppLef)'
                  call SubUppLef(dep,dissocstate,state,ih,jh,iv,jv,temph,tempv,tempd) 
               endif
            elseif ((ih.lt.i).and.(jv.gt.j)) then													!Subtracting from lower right
c               write(6,*) 'sub from lower right, no founder (SubLowRig)'
               call SubLowRig(dep,dissocstate,state,ih,jh,iv,jv,temph,tempv,tempd)       
            else																					!Subtracting from upper right
c               write(6,*) 'sub from upper right, no founder (SubUppRig)'
c               call SubUppRig(dep,dissocstate,state,ih,jh,iv,jv,temph,tempv,tempd) 
c check neighbors
               if (j.eq.103) then
c                  write(6,*) 'special case, on the top row' !only worry about right neighbor
                  if (dissocstate(i-1,j).eq.8) then
                     if (state(i-1,j).eq.1) then
                        temph=10
                     else
                        temph=11
                     endif
                     dep(i-1,j)=8
                  elseif (dissocstate(i-1,j).eq.5) then
c                     write(6,*) 'set dissoc of le neighb to 3'
                     temph = 3
                     dep(i-1,j) = 2
                  elseif (dissocstate(i-1,j).eq.6) then
c                     write(6,*) 'set dissoc of le neighb to 4'
                     temph = 4
                     dep(i-1,j) = 2
                  elseif (dissocstate(i-1,j).eq.12) then
c                     write(6,*) 'set dissoc of le neighb to 5'
                     temph = 5
                     dep(i-1,j) = 8
                  elseif (dissocstate(i-1,j).eq.13) then
c                     write(6,*) 'set dissoc of le neighb to 6'
                     temph = 6
                     dep(i-1,j) = 8
                  else
                     write(6,*) 'bizarre dissocstate to the le'
                     stop
                  endif
               else
c                  write(6,*) 'sub from upper right, no founder (SubUppRig)'                  
                  call SubUppRig(dep,dissocstate,state,ih,jh,iv,jv,temph,tempv,tempd) 
               endif
            endif
         
c            write(6,*) 'dissocstates after, h,v,d: ',dissocstate(ih,jh),dissocstate(iv,jv),dissocstate(ih,jv)
c            write(6,*) 'deps after (h,v,d): ',dep(ih,jh),dep(iv,jv),dep(ih,jv)

            if (temph.ne.dh) then
c               write(6,*) 'new dissocstate for H-neighb'
               dissocstate(ih,jh)=temph
c      		   write(6,*) 'resetting dissocstate of H-neighb to ',dissocstate(ih,jh)
               times(ev(ih,jh,2))=get_evtime(dissocstate(ih,jh),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(ih,jh))
               if (temph.eq.11) then
c                  write(6,*) 'DoubleDP check'
                  if ((state(ih,jh).eq.-1).and.(state(ih,jh-1).eq.-1)) then
c                     write(6,*) '2x DP'
                     times(ev(ih,jh,2))=GDP*times(ev(ih,jh,2))
                  else
c                     write(6,*) '1x DP'
                  endif
               endif
               call update(event,revmap,ev(ih,jh,2),times(ev(ih,jh,2)),times,totev)
            endif
            if (tempv.ne.dv) then
c               write(6,*) 'new dissocstate for V-neighb'
               dissocstate(iv,jv)=tempv
      		   if (dissocstate(iv,jv).eq.2) then
c                  write(6,*) 'for SubLowLef/SubLowRig'
c                  write(6,*) 'dstate now 2 for ',iv,jv
c                  write(6,*) 'before update'
c                  write(6,*) 'times: ',times(ev(iv,jv,2))
               endif
c      		   write(6,*) 'resetting dissocstate of V-neighb to ',dissocstate(iv,jv)
               times(ev(iv,jv,2))=get_evtime(dissocstate(iv,jv),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(iv,jv))
               call update(event,revmap,ev(iv,jv,2),times(ev(iv,jv,2)),times,totev)
               if (dissocstate(iv,jv).eq.2) then
c                  write(6,*) 'for SubLowLef/SubLowRig'
c                  write(6,*) 'dstate now 2 for ',iv,jv
c                  write(6,*) 'after update'
c                  write(6,*) 'times: ',times(ev(iv,jv,2))
               endif
            endif
            if (tempd.ne.dd) then
c               write(6,*) 'new dissocstate for D-neighb'
               dissocstate(ih,jv)=tempd
c      		   write(6,*) 'resetting dissocstate of D-neighb to ',dissocstate(ih,jv)
               times(ev(ih,jv,2))=get_evtime(dissocstate(ih,jv),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(ih,jv))
c Need to add test for double GDP if dstate=11.
               if (tempd.eq.11) then
                  if ((state(ih,jv).eq.-1).and.(state(ih,jv-1).eq.-1)) then
c                     write(6,*) 'double GDP, recalculate times'
                     times(ev(ih,jv,2))=times(ev(ih,jv,2))*GDP
                  else
c                     write(6,*) 'single GDP, do nothing'
                  endif
               endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
               call update(event,revmap,ev(ih,jv,2),times(ev(ih,jv,2)),times,totev)
            endif
      endif
C
C CHANGED HERE - added the Qsurround stuff, only worry about 1 < j < 13 first
      if (Qsurround) then
         if (i.eq.1) then
            write(6,*) 'Qsurround in subtub, i=1'
            stop
         elseif (i.eq.13) then
            write(6,*) 'Qsurround in subtub, i=13'
            stop
         else

            temph1=0
            temph2=0
            temph3=0
            tempv1=0
            tempv2=0
            tempv3=0
         
            if ((dissocstate(i,j).eq.10).or.(dissocstate(i,j).eq.11)) then
c            write(6,*) 'dissociating from 10/11'
               if ((state(i+1,j+1).ne.0).and.(state(i+1,j-1).ne.0).and.(state(i+1,j).ne.0)) then
c               write(6,*) 'removing from left'
                  call SubLefSurround (i,j,dep,dissocstate,state,temph1,temph2,temph3,tempv1,tempv2,times,
     @                         event,revmap,ev,totev,nev,nrecyc,recyc,index,temp,k_on,conc,
     @                         GDP,K_lat,K_long,K_both,K_hyd,K_thr_long,K_thr_lat,K_all,seammult,k_ne)
               elseif ((state(i-1,j+1).ne.0).and.(state(i-1,j-1).ne.0).and.(state(i-1,j).ne.0)) then
c               write(6,*) 'removing from right'
                  call SubRigSurround (i,j,dep,dissocstate,state,temph1,temph2,temph3,tempv1,tempv2,times,
     @                         event,revmap,ev,totev,nev,nrecyc,recyc,index,temp,k_on,conc,
     @                         GDP,K_lat,K_long,K_both,K_hyd,K_thr_long,K_thr_lat,K_all,seammult,k_ne)
               endif
            elseif ((dissocstate(i,j).eq.12).or.(dissocstate(i,j).eq.13)) then
c            write(6,*) 'dissociating from 12/13'
               if ((state(i-1,j-1).ne.0).and.(state(i+1,j-1).ne.0).and.(state(i,j-1).ne.0)) then
c               write(6,*) 'removing from top'
                  call SubTopSurround (i,j,dep,dissocstate,state,temph1,temph2,tempv1,tempv2,tempv3,times,
     @                         event,revmap,ev,totev,nev,nrecyc,recyc,index,temp,k_on,conc,
     @                         GDP,K_lat,K_long,K_both,K_hyd,K_thr_long,K_thr_lat,K_all,seammult,k_ne)
               elseif ((state(i-1,j+1).ne.0).and.(state(i+1,j+1).ne.0).and.(state(i,j+1).ne.0)) then
c               write(6,*) 'removing from bottom'
                  call SubBotSurround (i,j,dep,dissocstate,state,temph1,temph2,tempv1,tempv2,tempv3,times,
     @                         event,revmap,ev,totev,nev,nrecyc,recyc,index,temp,k_on,conc,
     @                         GDP,K_lat,K_long,K_both,K_hyd,K_thr_long,K_thr_lat,K_all)
               endif
            endif
         
               
         endif
      endif
C
C CHANGE HERE - check across seam??
C
c first do horizontal
c      write(6,*) 'b4 horix checks', totev
      do k=i-1,i+1,2
      
         if (state(k,j).ne.0) then
         
c         write(6,*) 'this site is already taken: ',k,j,dissocstate(k,j)
            addstate(k,j)=addstate(k,j)-1
               
         else
c            if (qdebug) write(6,*) 'Site is unoccupied: ',k,j,ev(k,j,1)
            if (addstate(k,j).eq.1) then
               if (ev(k,j,1).ne.0)	then
c                  if (qdebug) write(6,*) 'Lose Addition at : ',k,j,ev(k,j,1),totev
      			  addstate(k,j)=addstate(k,j)-1
      			  dissocstate(k,j)=0
                  call RemoveAdditionEvent(k,j,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)

      		   else
      			  write(6,*) 'trouble1'
      			  stop
      		   endif
      		else 
c      		   write(6,*) 'Was two more neighbors at : ',k,j,
c     @                      dissocstate(k,j)
               addstate(k,j)=addstate(k,j)-1
                  
               temp=0
C
C CHANGED HERE - dstate 10,12 - how come Emily does not have 6?
C               
c Have some nucleotide exchange fun here...
               if (dissocstate(k,j).eq.2) then
               	  temp=2
               elseif(dissocstate(k,j).eq.3) then
                  temp=3
               elseif (dissocstate(k,j).eq.4) then
                  temp=4
               elseif (dissocstate(k,j).eq.5) then
               	  temp=3
               elseif (dissocstate(k,j).eq.6) then
                  temp=4
               elseif (dissocstate(k,j).eq.10) then													!
                  if ((state(k,j-1).ne.0).and.(state(k,j+1).ne.0)) then								!
               	     temp=3																			!
                  else																				!
                  	 temp=5																			!
                  endif																				!
               elseif (dissocstate(k,j).eq.11) then													!
                  if ((state(k,j-1).ne.0).and.(state(k,j+1).ne.0)) then								!
               	     temp=4																			!
                  else																				!
                  	 temp=6																			!
                  endif
               elseif (dissocstate(k,j).eq.12) then													!
                  temp=5																			!
               elseif (dissocstate(k,j).eq.13) then
                  temp=6
               elseif (dissocstate(k,j).eq.8) then													!
                  write(6,*) 'possible loop forming around ',k,j									!
                  stop																				!              	
               else
               	  temp=0
               	  write(6,*) 'dissociation state equals garbage',dissocstate(k,j)
               	  stop
               endif
c Stop nucleotide exchange fun here...               
               
c               write(6,*) 'updating dissocstate',k,j,dissocstate(k,j)
               dissocstate(k,j) = temp

            endif
         endif
      end do
      			
c now do vertical
C
C CHANGES HERE - check pf 1 or 13
C
	  k=j-1
c      write(6,*) 'before looking down',totev
	  if (k.gt.102) then
	  if (state(i,k).eq.0) then
c               write(6,*) 'this site is not taken: ',i,k,addstate(i,k)
         temp=addstate(i,k)
         if (temp.ge.2) then
            addstate(i,k)=addstate(i,k)-1
c i put test here because temp was already used in line 665 to delineate neighbor status               	
            test=0
c Have some nucleotide exchange fun here...
            if (dissocstate(i,k).eq.2) then
               test=2
            elseif (dissocstate(i,k).eq.3) then
               test=3
            elseif (dissocstate(i,k).eq.4) then
               test=4
            elseif ((dissocstate(i,k).eq.5).or.(dissocstate(i,k).eq.6)) then
               test=2 
            elseif (dissocstate(i,k).eq.10) then													!
               test=5																				!
            elseif (dissocstate(i,k).eq.11) then
               test=6
            elseif (dissocstate(i,k).eq.12) then													!
               if ((state(i-1,k).ne.0).and.(state(i+1,k).ne.0)) then								!
                  test=2																			!
               else																					!
                  test=5																			!
               endif																				!
            elseif (dissocstate(i,k).eq.13) then													!
               if ((state(i-1,k).ne.0).and.(state(i+1,k).ne.0)) then								!
                  test=2																			!
               else																					!
                  test=6																			!
               endif   
            elseif (dissocstate(i,k).eq.8) then														!
c               write(6,*) 'possible loop forming around ',i,k										!
c               write(6,*) 'marker1121'																!
               stop																					!
			endif
c Stop nucleotide exchange fun here...			
		    dissocstate(i,k)=test
         elseif (temp.eq.1) then
            addstate(i,k)=addstate(i,k)-1
            dissocstate(i,k)=0
            if (ev(i,k,1).ne.0) then
               index = ev(i,k,1)
c               if (qdebug) write(6,*) 'Lose Addition at : ',i,k,index,event(index),ev(i,k,1)
                call RemoveAdditionEvent(i,k,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,dissocstate,event,times,totev)

  			   call build_min_heap(event,revmap,times,totev)
               		
               call hpsort(nrecyc,recyc)
            else
               write(6,*) 'trouble2'
               stop
            endif
         else
            write(6,*) 'big mistake!' 
            stop
         endif
      elseif (state(i,k).eq.-1) then
        	
         addstate(i,k)=addstate(i,k)-1
					
      elseif (state(i,k).eq.1) then
c        	write(6,*) 'GTP below'

c	     if ((i.eq.xo).AND.(k.eq.yo).AND.QCORN) then
c            if (dissocstate(i,k).lt.8) then
c         	   nrecyc = nrecyc+1
c      		   recyc(nrecyc) = ev(i,k,2)
c      		   index=revmap(ev(i,k,2))
c      		   ev(i,k,2)=0
c      		   temp=event(index)
c	  		   event(index)=event(totev)
c	  		   event(totev)=temp
c	  		   revmap(event(totev))=totev
c	  		   revmap(event(index))=index
c	  		   times(event(totev))=1d15
c              totev=totev-1
c	  		   call min_heapify(event,revmap,times,revmap(ev(i,k,2)),totev)
c      		   call hpsort(nrecyc,recyc)
c      		endif
c      	 endif
        	
         if (ev(i,k,3).ne.0) then
c            if (qdebug) write(6,*) 'Lose Hydrolysis at : ',i,k,ev(i,k,3)
c 					do kk=1,totev
c         			write(6,*) 'times b4',kk,times(event(kk)),event(kk),revmap(kk)
c      				end do
            call RemoveHydroEvent(i,k,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)        		
c 					do kk=1,totev
c         			write(6,*) 'times a',kk,times(event(kk)),event(kk),revmap(kk)
c      				end do
         endif
         addstate(i,k)=addstate(i,k)-1
            
      else
c         write(6,*) 'Trouble with state'
      endif
      endif

      k=j+1
c      write(6,*) 'before looking up',totev
	  if (state(i,k).eq.0) then
c         if (qdebug) write(6,*) 'this site is not taken: ',i,k
         if (addstate(i,k).ge.2) then
            addstate(i,k)=addstate(i,k)-1
               
            temp=0
c Have some nucleotide exchange fun here...            
            if (dissocstate(i,k).eq.2) then
c               write(6,*) 'leaving dstate 2 above'
            elseif (dissocstate(i,k).eq.3) then
               temp=3
            elseif (dissocstate(i,k).eq.4) then
               temp=4
            elseif ((dissocstate(i,k).eq.5).or.(dissocstate(i,k).eq.6)) then
               temp=2
            elseif (dissocstate(i,k).eq.10) then													!
               temp=5																				!
            elseif (dissocstate(i,k).eq.11) then
               temp=6
            elseif (dissocstate(i,k).eq.12) then													!
               if ((state(i-1,k).ne.0).and.(state(i+1,k).ne.0)) then								!
                  temp=2																			!
               else																					!
                  temp=5																			!
               endif																				!
            elseif (dissocstate(i,k).eq.13) then													!
               if ((state(i-1,k).ne.0).and.(state(i+1,k).ne.0)) then								!
                  temp=2																			!
               else																					!
                  temp=6																			!
               endif
            elseif (dissocstate(i,k).eq.8) then														!
               write(6,*) 'possible loop forming around ',i,k										!
               stop																					!
        	endif
c Stop nucleotide exchange fun here...        	
        	dissocstate(i,k) = temp
         elseif (addstate(i,k).eq.1) then
            addstate(i,k)=addstate(i,k)-1
            dissocstate(i,k)=0
            if (ev(i,k,1).ne.0) then
c               if (qdebug) write(6,*) 'Lose Addition at : ',i,k
c 					do kk=1,totev
c         			write(6,*) 'times before',kk,times(event(kk)),event(kk),revmap(kk)
c      				end do
               call RemoveAdditionEvent(i,k,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
c 					do kk=1,totev
c         			write(6,*) 'times after',kk,times(event(kk)),event(kk),revmap(kk)
c      				end do
      		endif
     
         else
c            write(6,*) 'big mistake!' 
         endif
      else 
         addstate(i,k)=addstate(i,k)-1
            
c         if (ev(i,j,3).ne.0) then
c            if (qdebug) write(6,*) 'Lose Hydrolysis at : ',i,j,ev(i,j,3)
c            call RemoveHydroEvent(i,j,nrecyc,recyc,revmap,ev,nev,
c     @                               addstate,event,times,totev)
c      	 endif
      endif
      endif
c New Addition event at i,j 
c        write(6,*) 'Add new addition at ',i,j,'totev',totev
c		write(6,*) 'Test',i,j,nev(i,j) 

       call AddNewAdditionEvent(i,j,addstate,totev,nev,ev,nrecyc,recyc,
     @                               xloc,yloc,times,k_on,conc,GDP,K_lat,
     @                               K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                               K_all,event,revmap,seammult,k_ne)
     
c***************************************************
c nuking subunit
c***************************************************

c   Coordinates (i,j) are for primary subunit being removed

c   Checking to see if primary subunit has neighbors that need to be removed as well. Using original
c   dissocstates and dependencies (odissoc, odep).
        if ((i.gt.1).and.(i.lt.13)) then
        
	    if (odissoc(i,j).lt.5) then
	 	   if (addstate(i,j).gt.1) then 
	 		  qwipe = .true.
c	 		  write(6,*) 'qwipe'
c	 		  if (qdebug) write(6,*) 'resetting addstate to 1 for ',i,j
              addstate(i,j) = 1
	 	   endif
	    endif
	    if ((odissoc(i,j).eq.5).or.(odissoc(i,j).eq.6)) then
	 	   if (addstate(i,j).gt.2) then
	 		  qwipe = .true.
c	 		  write(6,*) 'qwipe'
c	 		  if (qdebug) write(6,*) 'resetting addstate to 2 for ',i,j
              addstate(i,j) = 2
	  	   endif
	  	elseif (odissoc(i,j).ge.10) then															!
c	  	   write(6,*) 'marker1128'																	!
	  	   if (addstate(i,j).eq.4) then																!
c	  	      write(6,*) 'marker1129'																!
	  	      qwipe=.true.																			!
c	  	      write(6,*) 'qwipe for dissocstate 10-13 true'											!
	  	      addstate(i,j) = 3																		!
	       endif																					!
	    endif
	    
	    endif

	    if (qwipe) then
	    
c	    write(6,*) 'Old dependency of (i,j) = ',odep(i,j)
	    
c   Initialization of local variables.	    
	       do ii=1,13
	          do jj=1,maxlen
	             qlisted(ii,jj)=.false.
	             qlisted1(ii,jj)=.FALSE.
	             qlisted2(ii,jj)=.FALSE.
	          end do
	       end do
	       
	       xspec=0
	  	   yspec=0
	  	   xspec2=-999
	  	   yspec2=-999
	  	   xspec3=-999																				!
	  	   yspec3=-999																				!
           nlist = 0
           nremove = 0
           
           if ((odissoc(i,j).eq.10).or.(odissoc(i,j).eq.11)) then									!
              xspec = i																				!
              yspec = j+1																			!
              xspec2 = i																			!
              yspec2 = j-1																			!
              if ((state(i-1,j+1).ne.0).and.(state(i-1,j-1).ne.0)) then								!
                 xspec3 = i-1																		!
                 yspec3 = j																			!
                 if (state(i+1,j).ne.0) then														!
                    nlist = nlist+1																	!
                    nremove = nremove+1																!
                    xrem(nlist) = i+1																!
                    yrem(nlist) = j																	!
                    qlisted(i+1,j) = .true.															!
                 endif																				!
              elseif ((state(i+1,j+1).ne.0).and.(state(i+1,j-1).ne.0)) then							!
                 xspec3 = i+1																		!
                 yspec3 = j																			!
                 if (state(i-1,j).ne.0) then														!
                    nlist = nlist+1																	!
                    nremove = nremove+1																!
                    xrem(nlist) = i-1																!
                    yrem(nlist) = j																	!
                    qlisted(i-1,j) = .true.															!
                 endif																				!
             endif																					!
           elseif (odissoc(i,j).ge.12) then															!
              xspec = i-1																			!
              yspec = j																				!
              xspec2 = i+1																			!
              yspec2 = j																			!
              if ((state(i-1,j+1).ne.0).and.(state(i+1,j+1).ne.0)) then								!
                 xspec3 = i																			!
                 yspec3 = j+1																		!
                 if (state(i,j-1).ne.0) then														!
                    nlist = nlist+1																	!
                    nremove = nremove+1																!
                    xrem(nlist) = i																	!
                    yrem(nlist) = j-1																!
                    qlisted(i,j-1) = .true.															!
                 endif																				!
              elseif ((state(i-1,j-1).ne.0).and.(state(i+1,j-1).ne.0)) then							!
                 xspec3 = i																			!
                 yspec3 = j-1																		!
                 if (state(i,j+1).ne.0) then														!
                    nlist = nlist+1																	!
                    nremove = nremove+1																!
                    xrem(nlist) = i																	!
                    yrem(nlist) = j+1																!
                    qlisted(i,j+1) = .true.															!
                 endif																				!
              endif																					!
	       elseif (odissoc(i,j).lt.8) then															!
              if (odep(i,j).eq.0) then
                 write(6,*) 'STOP! Removing Founder!'
                 stop
              endif
              if (odep(i,j).eq.1) then
                 xspec = i
                 yspec = j+1
                 if ((odissoc(i,j).eq.5).or.(odissoc(i,j).eq.6)) then								!
                    if (dep(i-1,j).eq.1) then
                       xspec2 = i-1
                       yspec2 = j
                       if (state(i,j-1).ne.0) then													!Checking below
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i
                          yrem(nlist) = j-1
                          qlisted(i,j-1) = .true.
                       endif
                       if (state(i+1,j).ne.0) then													!Checking right
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i+1
                          yrem(nlist) = j
                          qlisted(i+1,j) = .true.
                       endif
                    elseif (dep(i+1,j).eq.1) then
                       xspec2 = i+1
                       yspec2 = j
                       if (state(i,j-1).ne.0) then													!Checking below
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i
                          yrem(nlist) = j-1
                          qlisted(i,j-1) = .true.
                       endif
                       if (state(i-1,j).ne.0) then													!Checking left
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i-1
                          yrem(nlist) = j
                          qlisted(i-1,j) = .true.
                       endif
                    else
                       write(6,*) 'Empty left/right subunits from primary of dissocstate GE 5?'
                       stop
                    endif
                 elseif (odissoc(i,j).lt.5) then													!
c                 write(6,*) 'Primary subunit not a part of a square, coordinates',i,j
c   Should only need to check subunits below, left and right.
                    if (state(i,j-1).ne.0) then														!Checking below
                       nlist = nlist+1
                       nremove = nremove+1
                       xrem(nlist) = i
                       yrem(nlist) = j-1
                       qlisted(i,j-1) = .true.
                    endif
                    if (state(i-1,j).ne.0) then														!Checking left
                       nlist = nlist+1
                       nremove = nremove+1
                       xrem(nlist) = i-1
                       yrem(nlist) = j
                       qlisted(i-1,j) = .true.
                    endif
                    if (state(i+1,j).ne.0) then														!Checking right
                       nlist = nlist+1
                       nremove = nremove+1
                       xrem(nlist) = i+1
                       yrem(nlist) = j
                       qlisted(i+1,j) = .true.
                    endif
                 endif
              
              elseif (odep(i,j).eq.2) then
                 xspec = i
                 yspec = j-1
                 if ((odissoc(i,j).eq.5).or.(odissoc(i,j).eq.6)) then								!
                    if (dep(i-1,j).eq.2) then
                       xspec2 = i-1
                       yspec2 = j
                       if (state(i,j+1).ne.0) then													!Checking above
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i
                          yrem(nlist) = j+1
                          qlisted(i,j+1) = .true.
                       endif
                       if (state(i+1,j).ne.0) then													!Checking right
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i+1
                          yrem(nlist) = j
                          qlisted(i+1,j) = .true.
                       endif
                    elseif (dep(i+1,j).eq.2) then
                       xspec2 = i+1
                       yspec2 = j
                       if (state(i-1,j).ne.0) then													!Checking left
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i-1
                          yrem(nlist) = j
                          qlisted(i-1,j) = .true.
                       endif
                       if (state(i,j+1).ne.0) then													!Checking above
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i
                          yrem(nlist) = j+1
                          qlisted(i,j+1) = .true.
                       endif
                    else
                       write(6,*) 'Empty left/right subunits from primary of dissocstate GE 5?'
                       stop
                    endif
                 elseif (odissoc(i,j).lt.5) then													!
c                 write(6,*) 'Primary subunit not a part of a square, coordinates',i,j
c   Should only need to check subunits above, left and right.
                    if (state(i,j+1).ne.0) then														!Checking above
                       nlist = nlist+1
                       nremove = nremove+1
                       xrem(nlist) = i
                       yrem(nlist) = j+1
                       qlisted(i,j+1) = .true.
                    endif
                    if (state(i-1,j).ne.0) then														!Checking left
                       nlist = nlist+1
                       nremove = nremove+1
                       xrem(nlist) = i-1
                       yrem(nlist) = j
                       qlisted(i-1,j) = .true.
                    endif
                    if (state(i+1,j).ne.0) then														!Checking right
                       nlist = nlist+1
                       nremove = nremove+1
                       xrem(nlist) = i+1
                       yrem(nlist) = j
                       qlisted(i+1,j) = .true.
                    endif
                 endif
              
              elseif (odep(i,j).eq.3) then
                 xspec = i-1
                 yspec = j
                 if ((odissoc(i,j).eq.5).or.(odissoc(i,j).eq.6)) then								!
                    if (dep(i,j+1).eq.3) then
                       xspec2 = i
                       yspec2 = j+1
                       if (state(i,j-1).ne.0) then													!Checking below
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i
                          yrem(nlist) = j-1
                          qlisted(i,j-1)= .true.
                       endif
                       if (state(i+1,j).ne.0) then													!Checking right
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i+1
                          yrem(nlist) = j
                          qlisted(i+1,j) = .true.
                       endif
                    elseif (dep(i,j-1).eq.3) then
                       xspec2 = i
                       yspec2 = j-1
                       if (state(i,j+1).ne.0) then													!Checking above
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i
                          yrem(nlist) = j+1
                          qlisted(i,j+1) = .true.
                       endif
                       if (state(i+1,j).ne.0) then													!Checking right
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i+1
                          yrem(nlist) = j
                          qlisted(i+1,j) = .true.
                       endif
                    else
                       write(6,*) 'Empty top/bottom subunits from primary of dissocstate GE 5?'
                       stop
                    endif
                 elseif (odissoc(i,j).lt.5) then													!
c                 write(6,*) 'Primary subunit not a part of a square, coordinates',i,j
c   Should only need to check subunits above, below and to the right.
                    if (state(i,j+1).ne.0) then														!Checking above
                       nlist = nlist+1
                       nremove = nremove+1
                       xrem(nlist) = i
                       yrem(nlist) = j+1
                       qlisted(i,j+1) = .true.
                    endif
                    if (state(i,j-1).ne.0) then														!Checking below
                       nlist = nlist+1
                       nremove = nremove+1
                       xrem(nlist) = i
                       yrem(nlist) = j-1
                       qlisted(i,j-1)= .true.
                    endif
                    if (state(i+1,j).ne.0) then														!Checking right
                       nlist = nlist+1
                       nremove = nremove+1
                       xrem(nlist) = i+1
                       yrem(nlist) = j
                       qlisted(i+1,j) = .true.
                    endif
                 endif
              
              elseif (odep(i,j).eq.4) then
                 xspec = i+1
                 yspec = j
                 if ((odissoc(i,j).eq.5).or.(odissoc(i,j).eq.6)) then								!
                    if (dep(i,j+1).eq.4) then
                       xspec2 = i
                       yspec2 = j+1
                       if (state(i,j-1).ne.0) then													!Checking below
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i
                          yrem(nlist) = j-1
                          qlisted(i,j-1) = .true.
                       endif
                       if (state(i-1,j).ne.0) then													!Checking left
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i-1
                          yrem(nlist) = j
                          qlisted(i-1,j) = .true.
                       endif
                    elseif (dep(i,j-1).eq.4) then
                       xspec2 = i
                       yspec2 = j-1
                       if (state(i,j+1).ne.0) then													!Checking above
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i
                          yrem(nlist) = j+1
                          qlisted(i,j+1) = .true.
                       endif
                       if (state(i-1,j).ne.0) then													!Checking left
                          nlist = nlist+1
                          nremove = nremove+1
                          xrem(nlist) = i-1
                          yrem(nlist) = j
                          qlisted(i-1,j) = .true.
                       endif
                    else
                       write(6,*) 'Empty top/bottom subunits from primary of dissocstate GE 5?'
                       stop
                    endif
                 elseif (odissoc(i,j).lt.5) then													!
c                 write(6,*) 'Primary subunit not a part of a square, coordinates',i,j
c   Should only need to check subunits above, below and to the left.
                    if (state(i,j+1).ne.0) then														!Checking above
                       nlist = nlist+1
                       nremove = nremove+1
                       xrem(nlist) = i
                       yrem(nlist) = j+1
                       qlisted(i,j+1) = .true.
                    endif
                    if (state(i,j-1).ne.0) then														!Checking below
                       nlist = nlist+1
                       nremove = nremove+1
                       xrem(nlist) = i
                       yrem(nlist) = j-1
                       qlisted(i,j-1) = .true.
                    endif
                    if (state(i-1,j).ne.0) then														!Checking left
                       nlist = nlist+1
                       nremove = nremove+1
                       xrem(nlist) = i-1
                       yrem(nlist) = j
                       qlisted(i-1,j) = .true.
                    endif
                 endif
              
              elseif (odep(i,j).eq.5) then
                 xspec = i
                 yspec = j+1
                 xspec2 = i-1
                 yspec2 = j
c   Should only need to check subunits below and to the right.
                 if (state(i,j-1).ne.0) then														!Checking below
                    nlist = nlist+1
                    nremove = nremove+1
                    xrem(nlist) = i
                    yrem(nlist) = j-1
                    qlisted(i,j-1) = .true.
                 endif
                 if (state(i+1,j).ne.0) then														!Checking right
                    nlist = nlist+1
                    nremove = nremove+1
                    xrem(nlist) = i+1
                    yrem(nlist) = j
                    qlisted(i+1,j) = .true.
                 endif
              
              elseif (odep(i,j).eq.6) then
                 xspec = i
                 yspec = j+1
                 xspec2 = i+1
                 yspec2 = j
c   Should only need to check subunits below and to the left.
                 if (state(i,j-1).ne.0) then														!Checking below
                    nlist = nlist+1
                    nremove = nremove+1
                    xrem(nlist) = i
                    yrem(nlist) = j-1
                    qlisted(i,j-1) = .true.
                 endif
                 if (state(i-1,j).ne.0) then														!Checking left
                    nlist = nlist+1
                    nremove = nremove+1
                    xrem(nlist) = i-1
                    yrem(nlist) = j
                    qlisted(i-1,j) = .true.
                 endif
              
              elseif (odep(i,j).eq.7) then
                 xspec = i
                 yspec = j-1
                 xspec2 = i+1
                 yspec2 = j
c   Should only need to check subunits above and to the left.         
                 if (state(i,j+1).ne.0) then														!Checking above
                    nlist = nlist+1
                    nremove = nremove+1
                    xrem(nlist) = i
                    yrem(nlist) = j+1
                    qlisted(i,j+1) = .true.
                 endif
                 if (state(i-1,j).ne.0) then														!Checking left
                    nlist = nlist+1
                    nremove = nremove+1
                    xrem(nlist) = i-1
                    yrem(nlist) = j
                    qlisted(i-1,j) = .true.
                 endif
        
              elseif (odep(i,j).eq.8) then
                 xspec = i
                 yspec = j-1
                 xspec2 = i-1
                 yspec2 = j
c   Should only need to check subunit above and to the right.
                 if (state(i,j+1).ne.0) then														!Checking above
                    nlist = nlist+1
                    nremove = nremove+1
                    xrem(nlist) = i
                    yrem(nlist) = j+1
                    qlisted(i,j+1) = .true.
                 endif
                 if (state(i+1,j).ne.0) then														!Checking right
                    nlist = nlist+1
                    nremove = nremove+1
                    xrem(nlist) = i+1
                    yrem(nlist) = j
                    qlisted(i+1,j) = .true.
                 endif
	          else
                 write(6,*) 'Wrong! Subunit has no dependency?'
                 stop
              endif
           endif	     	  
c wiping part

         icount=1
	     do while (nremove.gt.0)
c	        if (qdebug) write(6,*) 'nremove, current',nremove,xrem(icount),yrem(icount)
	  
	  	    do ii=xrem(icount)-1,xrem(icount)+1,2
c               if (qdebug) write(6,*) 'checking ii neigbs',ii,yrem(icount)
c watch parenthesis for xrem(icount)
	  		   if (.NOT.((ii.eq.xspec).AND.(yrem(icount).eq.yspec))) then
	  			  if (.NOT.((ii.eq.xspec2).AND.(yrem(icount).eq.yspec2))) then
C
C CHANGES HERE - add xspec 3, etc
C
	  				 if (state(ii,yrem(icount)).ne.0) then
	  					if (.NOT.qlisted(ii,yrem(icount))) then
	  		               qlisted(ii,yrem(icount))=.TRUE.
	  		               nremove=nremove+1
	  					   nlist=nlist+1
	  					   xrem(nlist)=ii
	  					   yrem(nlist)=yrem(icount)
c	  					   if (qdebug) write(6,*) 'adding to remove list',ii,yrem(icount)
	  					endif
	  				 else
	  				    if ( .NOT.( (ii.eq.i).AND.(yrem(icount).eq.j) ) ) then
	  					   if (ev(ii,yrem(icount),1).ne.0) then
c        				      if (qdebug) write(6,*) 'addstate at ',ii,yrem(icount),' is ',
c     @  addstate(ii,yrem(icount))
     						  if (addstate(ii,yrem(icount)).eq.1) then
								 index=ev(ii,yrem(icount),1)
								 nrecyc=nrecyc+1
								 recyc(nrecyc)=ev(ii,yrem(icount),1)
c		                         if (qdebug) write(6,*)'rec event at',ev(ii,yrem(icount),1),ii,yrem(icount)
								 index=revmap(ev(ii,yrem(icount),1))
            					 nev(ii,yrem(icount))=nev(ii,yrem(icount))-1
            					 ev(ii,yrem(icount),1)=0
            					 dissocstate(ii,yrem(icount))=0
								 addstate(ii,yrem(icount))=0
               		
      	    					 temp=event(index)
	  							 event(index)=event(totev)
	  							 event(totev)=temp
	  							 revmap(event(totev))=totev
	  							 revmap(event(index))=index
	  							 times(event(totev))=1d15
            					 totev=totev-1
  								 call build_min_heap(event,revmap,times,totev)
            					 call hpsort(nrecyc,recyc)
     						  elseif (addstate(ii,yrem(icount)).gt.1) then
     							 if (dissocstate(ii,yrem(icount)).eq.2) then
     								dissocstate(ii,yrem(icount))=2
     						     elseif (dissocstate(ii,yrem(icount)).eq.3) then
     								dissocstate(ii,yrem(icount))=3
c Start nucleotide exchange fun here...     								
     							elseif (dissocstate(ii,yrem(icount)).eq.4) then
     								dissocstate(ii,yrem(icount))=4
     							 elseif (dissocstate(ii,yrem(icount)).eq.5) then
     								dissocstate(ii,yrem(icount))=3
     							 elseif (dissocstate(ii,yrem(icount)).eq.6) then
     								dissocstate(ii,yrem(icount))=4
                                 elseif (dissocstate(ii,yrem(icount)).eq.10) then				!
                                       if ((state(ii,yrem(icount)-1).ne.0).and.						!
     @                                    (state(ii,yrem(icount)+1).ne.0)) then						!
               	                          dissocstate(ii,yrem(icount))=3							!
                                       else															!
                  	                      dissocstate(ii,yrem(icount))=5							!
                                       endif														!
                                 elseif (dissocstate(ii,yrem(icount)).eq.11) then				!
                                       if ((state(ii,yrem(icount)-1).ne.0).and.						!
     @                                    (state(ii,yrem(icount)+1).ne.0)) then						!
               	                          dissocstate(ii,yrem(icount))=4							!
                                       else															!
                  	                      dissocstate(ii,yrem(icount))=6							!
                                       endif      
                                 elseif (dissocstate(ii,yrem(icount)).eq.12) then					!
                                       dissocstate(ii,yrem(icount))=5								!
                                 elseif (dissocstate(ii,yrem(icount)).eq.13) then				!
                                       dissocstate(ii,yrem(icount))=6      
     				             elseif (dissocstate(ii,yrem(icount)).eq.8) then
                                       write(6,*) 'possible loop at',ii,yrem(icount)				!			
     							       stop															!
     					  	     else
     								   write(6,*) 'nonsensical dissocstate'
     								   stop
     							 endif
c End nucleotide exchange fun here...     							 
     						  endif
     					   endif
     				    endif
    				 endif
    				 if (addstate(ii,yrem(icount)).ne.0) then
					    if ( .NOT.( (ii.eq.i).AND.(yrem(icount).eq.j) ) ) then
         	    		   addstate(ii,yrem(icount))=addstate(ii,yrem(icount))-1
         	    	    endif
         	         endif
         		  endif
         	   endif
            enddo
         
            do jj=yrem(icount)-1,yrem(icount)+1,2
c               if (qdebug) write(6,*) 'checking jj neigbs',xrem(icount),jj
        	   if (.NOT.((jj.eq.yspec).AND.(xrem(icount).eq.xspec))) then
        		  if (.NOT.((jj.eq.yspec2).AND.(xrem(icount).eq.xspec2))) then
C
C CHANGES HERE - add xspec 3, etc
C
        		
        			 if (state(xrem(icount),jj).ne.0) then
	  					if (.NOT.qlisted(xrem(icount),jj)) then
	  		               qlisted(xrem(icount),jj)=.TRUE.
	  		               nremove=nremove+1
	  					   nlist=nlist+1
	  					   xrem(nlist)=xrem(icount)
	  					   yrem(nlist)=jj
c	  					   if (qdebug) write(6,*) 'adding to remove list',xrem(icount),jj
	  					endif
        			 else
	  				    if ( .NOT.( (xrem(icount).eq.i).AND.(jj.eq.j) ) ) then
c	  				       if (qdebug) write(6,*) 'ooga'
	  				   
        				   if (ev(xrem(icount),jj,1).ne.0) then
c        				      if (qdebug) write(6,*) 'addstate at ',xrem(icount),jj,' is ',
c     @  addstate(xrem(icount),jj)
     						  if (addstate(xrem(icount),jj).eq.1) then
								 index=ev(xrem(icount),jj,1)
								 dissocstate(xrem(icount),jj)=0
								 addstate(xrem(icount),jj)=0
            					 nrecyc=nrecyc+1
            					 recyc(nrecyc)=ev(xrem(icount),jj,1)
c            		             if (qdebug) write(6,*)'rec event at',ev(xrem(icount),jj,1),xrem(icount),jj
      	   			 			 index=revmap(ev(xrem(icount),jj,1))
            					 nev(xrem(icount),jj)=nev(xrem(icount),jj)-1
            					 ev(xrem(icount),jj,1)=0
               		
      	    					 temp=event(index)
	  							 event(index)=event(totev)
	  							 event(totev)=temp
	  							 revmap(event(totev))=totev
	  							 revmap(event(index))=index
	  							 times(event(totev))=1d15
            					 totev=totev-1
  								 call build_min_heap(event,revmap,times,totev)
            					 call hpsort(nrecyc,recyc)
         					  elseif (addstate(xrem(icount),jj).gt.1) then
     							 if (dissocstate(xrem(icount),jj).eq.2) then
     							    dissocstate(xrem(icount),jj)=2
     							 elseif (dissocstate(xrem(icount),jj).eq.3) then
     							    dissocstate(xrem(icount),jj)=3
c     							 elseif (dissocstate(xrem(icount),jj).eq.4) then
c     								dissocstate(xrem(icount),jj)=4
     							 elseif (dissocstate(xrem(icount),jj).eq.5) then
     								dissocstate(xrem(icount),jj)=2
c     							 elseif (dissocstate(xrem(icount),jj).eq.6) then
c     								dissocstate(xrem(icount),jj)=2
     							 elseif (dissocstate(xrem(icount),jj).eq.8) then
     								if (addstate(xrem(icount),jj).eq.4) then
     								   dissocstate(xrem(icount),jj)=8
     								elseif (addstate(xrem(icount),jj).eq.3) then
     								   if ((state(xrem(icount)-1,jj).ne.0)
     @										.AND.(state(xrem(icount)+1,jj).ne.0)) then
     								      dissocstate(xrem(icount),jj)=2
     								   else
     									  dissocstate(xrem(icount),jj)=5
     								   endif
     								else 
     								   write(6,*) 'addstate=1 for dissoctype 8'
     								   stop
     								endif
     							 else
     								write(6,*) 'nonsensical dissocstate'
     								stop
     							 endif
							  endif
						   endif
					    endif
					 endif
					 if (addstate(xrem(icount),jj).ne.0) then
					    if ( .NOT.( (xrem(icount).eq.i).AND.(jj.eq.j) ) ) then
c			               if (qdebug) write(6,*) 'subtracting from addstate, vert',xrem(icount),jj
         	    		   addstate(xrem(icount),jj)=addstate(xrem(icount),jj)-1
         	    	    endif
         	         end if
         		  endif
         	   endif
            enddo
         
c now remove subunits
      if ((xrem(icount).eq.xo).and.(yrem(icount).eq.yo)) then
                write(6,*) 'removing founder: Printing configuration'
      			write(6,'(13A)') '  1 ',' 2 ',' 3 ',' 4 ',' 5 ',' 6 ',' 7 ',
     @                     ' 8 ',' 9 ',' 10',' 11',' 12',' 13'
         	do ll=110,90,-1
            	write(6,'(13I3)') state(1,ll),state(2,ll),state(3,ll),
     @ 	state(4,ll),state(5,ll),state(6,ll),state(7,ll),state(8,ll),
     @ 	state(9,ll),state(10,ll),state(11,ll),state(12,ll),state(13,ll)
       	 end do
       	 write(6,*) ''
       	  do ll=110,90,-1
     		write(6,'(13I3)') dissocstate(1,ll),dissocstate(2,ll),
     @		dissocstate(3,ll),
     @ 		dissocstate(4,ll),dissocstate(5,ll),dissocstate(6,ll),
     @		dissocstate(7,ll),
     @ 		dissocstate(8,ll),dissocstate(9,ll),dissocstate(10,ll),
     @		dissocstate(11,ll),
     @ 		dissocstate(12,ll),dissocstate(13,ll)
          end do
        	write(6,*) ''
         	do ll=110,90,-1
     		write(6,'(13I3)') addstate(1,ll),addstate(2,ll),
     @		addstate(3,ll),
     @ 	addstate(4,ll),addstate(5,ll),addstate(6,ll),
     @		addstate(7,ll),
     @ 	addstate(8,ll),addstate(9,ll),addstate(10,ll),
     @	addstate(11,ll),
     @ 	addstate(12,ll),addstate(13,ll)
         end do
         write(6,*) ''
         	do ll=110,90,-1
     		write(6,'(13I3)') dep(1,ll),dep(2,ll),
     @		dep(3,ll),
     @ 	dep(4,ll),dep(5,ll),dep(6,ll),
     @		dep(7,ll),
     @ 	dep(8,ll),dep(9,ll),dep(10,ll),
     @	dep(11,ll),
     @ 	dep(12,ll),dep(13,ll)
         end do        
        stop
      endif

	  	state(xrem(icount),yrem(icount))=0
	  	ntub=ntub-1
	  	nremove=nremove-1
	  	dissocstate(xrem(icount),yrem(icount))=0
	  	dep(xrem(icount),yrem(icount))=9
	  	if (ev(xrem(icount),yrem(icount),2).ne.0) then
	  		index=revmap(ev(xrem(icount),yrem(icount),2))
	  		nrecyc=nrecyc+1
	  		
      		recyc(nrecyc)=ev(xrem(icount),yrem(icount),2)
c      		if (qdebug) write(6,*)'rec event at',ev(xrem(icount),yrem(icount),2),xrem(icount),yrem(icount)

      		index=revmap(ev(xrem(icount),yrem(icount),2))
      		nev(xrem(icount),yrem(icount))=nev(xrem(icount),yrem(icount))-1
      		ev(xrem(icount),yrem(icount),2)=0
               		
      		temp=event(index)
	  		event(index)=event(totev)
	  		event(totev)=temp
	  		revmap(event(totev))=totev
	  		revmap(event(index))=index
	  		times(event(totev))=1d15
      		totev=totev-1
  	  		call build_min_heap(event,revmap,times,totev)
      		call hpsort(nrecyc,recyc)
      	endif
   	  	if (ev(xrem(icount),yrem(icount),3).ne.0) then
      		index = revmap(ev(xrem(icount),yrem(icount),3))
c      	write(6,*) 'Lose Addition at : ',xrem(icount),yrem(icount),index,event(index),ev(xrem(icount),jj,1)

c dissocstate? addstate?
           
      		nrecyc=nrecyc+1
      		recyc(nrecyc)=ev(xrem(icount),yrem(icount),3)
c	  		if (qdebug) write(6,*)'rec event at',ev(xrem(icount),yrem(icount),3),xrem(icount),yrem(icount)

      		index=revmap(ev(xrem(icount),yrem(icount),3))
      		nev(xrem(icount),yrem(icount))=nev(xrem(icount),yrem(icount))-1
      		ev(xrem(icount),yrem(icount),3)=0
               		
      		temp=event(index)
	  		event(index)=event(totev)
	  		event(totev)=temp
	  		revmap(event(totev))=totev
	  		revmap(event(index))=index
	  		times(event(totev))=1d15
      		totev=totev-1
  	  		call build_min_heap(event,revmap,times,totev)
      		call hpsort(nrecyc,recyc)
   	  	endif
c Check to see if NucEx event needs to be removed...												!new for nuc ex
        if (ev(xrem(icount),yrem(icount),4).ne.0) then
c           write(6,*) 'NucEx to be removed at ',xrem(icount),yrem(icount),
c     @                ev(xrem(icount),yrem(icount),4)
           call RemoveNucExEvent(xrem(icount),yrem(icount),nrecyc,recyc,revmap,
     @                           ev,nev,event,times,totev)
        endif
        
   	  	icount=icount+1
c   	  	if (qdebug) write(6,*) 'increased icount', icount
	  end do
	  
c	  do k=1,nrecyc
c	  	write(6,*)'k,recyc',k,recyc(k)
c	  enddo
	  	  
c	  write(6,*) 'nrecyc',nrecyc
c      do kk=1,nrecyc
c         write(6,*) 'nrecyc-end',kk,recyc(kk)
c      end do
	  
        endif
        
	    return
	    end
	   
      subroutine HydroTub(ntub,evno,xloc,yloc,state,nrecyc,recyc,
     @					  totev,addstate,nev,ev,maxlen,
     @ 					dissocstate,dep,k_on,conc,event,revmap,times,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @          K_thr_lat,K_all,dist,xo,yo,qdebug,seammult,k_ne)
      
      implicit none
c
c i/o variables
	  integer evno,xloc(*),yloc(*),state(13,*),ntub
      integer nrecyc,recyc(*),totev,addstate(13,*),maxlen
      integer nev(13,*),ev(13,maxlen,4)
      integer dissocstate(13,maxlen),dep(13,*)
      integer event(*)
      integer revmap(*),dist(13,*)
      double precision times(*)
      double precision get_evtime
      double precision k_on,conc,GDP,K_lat,K_long,K_both,k_hyd
      double precision K_thr_long,K_thr_lat,K_all,k_ne
      double precision seammult(13,*)
      integer index,xo,yo
      logical qdebug,qdouble
c
c local variables
      integer i,j,k,temp,kk,temp2,ll
      
c      write(6,*) 'nrecyc,recyc: ',nrecyc,recyc(1),recyc(2),recyc(3)


      qdouble=.false.
c begin computation
	  i=xloc(evno)
	  j=yloc(evno)
	  nev(i,j)=nev(i,j)-1
c	  if (qdebug) write(6,*) 'nrecyc',nrecyc
      do kk=1,nrecyc
c         if (qdebug) write(6,*) 'nrecyc-beginning',kk,recyc(kk)
      end do
c      write(6,*) 'Hydro tub at: ',i,j
	  
c	  write(6,*) 'First thing to do: hydrolyze site'
	  state(i,j)=-1
	  
	  
c	  write(6,*) 'Recycle old event number'
	  nrecyc=nrecyc+1
	  recyc(nrecyc)=evno
	  
	  index=revmap(ev(i,j,3))
	  ev(i,j,3)=0
	  temp=event(index)
	  event(index)=event(totev)
	  event(totev)=temp
	  revmap(event(totev))=totev
	  revmap(event(index))=index
	  times(event(totev))=1d15
	  totev=totev-1
	  call min_heapify(event,revmap,times,1,totev)
	  call hpsort(nrecyc,recyc)

      temp=dissocstate(i,j)
      temp2=dissocstate(i,j+1)
      
      if (j.gt.102) then
         if (dissocstate(i,j).eq.10) then
c            write(6,*) 'we are dstate 10, turning into 11'
            temp=11
         endif
      
         if (dissocstate(i,j+1).eq.3) then
            temp2=4
         elseif (dissocstate(i,j+1).eq.5) then
            temp2=6
         elseif (dissocstate(i,j+1).eq.10) then
            temp2=11
         elseif (dissocstate(i,j+1).eq.11) then
c            write(6,*) 'double gdp for dstate 11 above'
            temp2=11
            qdouble=.true.
         elseif (dissocstate(i,j+1).eq.12) then
            temp2=13
         elseif (dissocstate(i,j+1).eq.8) then
c            write(6,*) 'dstate above = 8, nothing to do'
         else
            write(6,*) 'dstate above not 3,5,10,11,12, or 8'
            stop
         endif
      elseif (j.lt.98) then
         write(6,*) 'whoops, minus end!'
         stop
      endif
      
      if (dissocstate(i,j).ne.temp) then
         dissocstate(i,j)=temp
         times(ev(i,j,2))=get_evtime(dissocstate(i,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(i,j))
         call update(event,revmap,ev(i,j,2),
     @                          times(ev(i,j,2)),times,totev)
      endif

      if (dissocstate(i,j+1).ne.temp2) then
         dissocstate(i,j+1)=temp2
	  	 times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(i,j+1))
         if (qdouble) times(ev(i,j+1,2))=GDP*times(ev(i,j+1,2))
         call update(event,revmap,ev(i,j+1,2),
     @                          times(ev(i,j+1,2)),times,totev)
      endif
	  
	  return
	  end
	  	
c BELOW ARE SUBROUTINES (MIN_HEAPIFY ETC.) FOR THE ABOVE SUBROUTINES		  	
	  	
      subroutine hpsort(n,ra)
      
      integer n
      integer ra(n)
      
      integer i,ir,j,l,kk
      real rra
      
      
c      write(6,*) 'inside hpsort', n
c      do kk=1,n
c         write(6,*) kk,ra(kk)
c      end do
c      write(6,*) 
      if (n.lt.2) return
      
      l=n/2+1
      ir=n
   10 continue
      	if(l.gt.1) then
      		l=l-1
      		rra=ra(l)
      	else
      		rra=ra(ir)
      		ra(ir)=ra(1)
      		ir=ir-1
      		if(ir.eq.1) then
      			ra(1)=rra
      			return
      		endif
      	endif
      	i=l
      	j=l+1
   20	if(j.le.ir) then
      		if(j.lt.ir) then
      			if(ra(j).lt.ra(j+1))j=j+1
      		endif
      		if(rra.lt.ra(j)) then
      			ra(i)=ra(j)
      			i=j
      			j=j+j
      		else
      			j=ir+1
      		endif
      	goto 20
      	endif
      	ra(i)=rra
      goto 10
      
      return
      END
C
C +++++
C
       subroutine build_min_heap(indices,revmap,times,dim)
C       
C      i/o
       integer indices(*),revmap(*),dim
       double precision times(*)
C      local
       integer start,i,fastest,j
       
       start = int(dim/2)
c       write(6,*) 'start = ',start
       
       do i=start,1,-1
C          if (i.le.40) then
C             write(6,*) 'i,intermediate state',i
C             do j=1,80
C                write(6,*) j,indices(j),times(indices(j))
C             end do
C          endif
c          write(6,*) 'build_min_heap: i,start,dim= ',
c     @ i,start,dim
          call min_heapify(indices,revmap,times,i,dim)
       end do
      
       return
       end
       
       recursive subroutine min_heapify(indices,revmap,times,index,dim)
C
C      i/o
       integer indices(*),revmap(*),index,dim
       double precision times(*)
C      local
       integer lchild,rchild,fastest,nextcall
       integer temp,temp2,fastev,slowev
       double precision time1,time2
       
c       write(6,*) 'inside min_heapify, index,dim= ',index,dim
       lchild = 2*index
       rchild = 2*index+1
c       write(6,*) 'children, indices: ', lchild,rchild,
c     @      indices(lchild),indices(rchild)
C       write(6,*) 'times:'
       fastest = index
       
       if (lchild.le.dim) then
          time1 = times(indices(lchild))
          time2 = times(indices(index))
          if (time1.le.time2) then
c             write(6,*) 'lchild is less',time1,time2
             fastest = lchild
             nextcall = lchild
          else
             fastest = index
          endif
       endif
       
       if (rchild.le.dim) then
          time1 = times(indices(rchild))
          time2 = times(indices(fastest))
          if (time1.le.time2) then
c             write(6,*) 'rchild is less',time1,time2
             fastest = rchild
             nextcall = rchild
          endif
       endif

       if (fastest.ne.index) then
c          write(6,*) 'fastest,index',fastest,index
          temp = indices(index)
          fastev = indices(fastest)
          slowev = indices(index)
c          write(6,*) 'temp,temp2',temp,temp2
c          write(6,*) 'BLAH: ',indices(index),indices(fastest)
          indices(index) = indices(fastest)
          revmap(fastev)=index
          indices(fastest) = temp
          revmap(slowev)=fastest

c          do i=1,15
c             write(6,*) i,indices(i),revmap(i),times(indices(i))
c           end do

          call min_heapify(indices,revmap,times,nextcall,dim)
       endif

       return
       end
C
C +++++
C
       subroutine heap_decrease_key(indices,revmap,eventindex,
     @     value,times,dim)
C
C      i/o
       integer indices(*),revmap(*),dim
       integer eventindex
       double precision times(*),value
C      local
       integer lchild,rchild,fastest,nextcall,index
       integer temp,temp2,parent,fastev,slowev
       logical cond
       double precision time1,time2
C
C
       index = revmap(eventindex)
       parent = int(index/2)

c       write(6,*) 'index,parent,eventindex,indices(eventindex)',
c     @    index,parent,eventindex,indices(eventindex),revmap(eventindex)
       times(eventindex) = value
c       write(6,*) 'cond:',times(indices(parent)),
c     @ times(indices(index))
       do while ( (index.gt.1).and.
     @  (times(indices(parent)).ge.times(indices(index))) )
c          write(6,*) 'index,parent,indices,times',
c     @ index,parent,indices(index),indices(parent),
c     @ times(indices(index)),times(indices(parent))
          temp = indices(index)
          slowev = indices(parent)
          fastev = indices(index)
          indices(index) = indices(parent)
          indices(parent) = fastev
          revmap(fastev)=parent
          revmap(slowev)=index
          index = parent
          parent = int(index/2)
       end do
       
       return
       end
       
      double precision function get_evtime(evtype,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,smult)      
      implicit none

c i/o variables
	  integer evtype
	  double precision k_on,conc,GDP,K_lat,K_long,K_both,k_hyd,time
      double precision K_thr_long,K_thr_lat,K_all,k_ne
      double precision smult
c local variables

      double precision rate, tmp
            
      if (evtype.eq.1) then
      	rate=k_on*conc
      elseif (evtype.eq.2) then
      	rate=k_on*K_lat/smult
c      	write(6,*) 'dstate 2 in get_evtime'
      elseif (evtype.eq.3) then
      	rate=k_on*K_long/smult
      elseif (evtype.eq.4) then
      	rate=k_on*K_long*GDP/smult
      elseif (evtype.eq.5) then
      	rate=k_on*K_both/smult
      elseif (evtype.eq.6) then
      	rate=k_on*K_both*GDP/smult
      elseif (evtype.eq.7) then
      	rate=k_hyd
      elseif (evtype.eq.8) then
      	rate=k_on*K_all/smult
      elseif (evtype.eq.9) then			!new for nuc ex
        rate=k_ne
      elseif (evtype.eq.10) then
        rate=k_on*K_thr_long/smult
      elseif (evtype.eq.11) then
        rate=k_on*K_thr_long*GDP/smult
      elseif (evtype.eq.12) then
        rate=k_on*K_thr_lat/smult
      elseif (evtype.eq.13) then
c         rate=k_on*K_thr_lat*2*GDP/smult
        rate=k_on*K_thr_lat*GDP/smult
      else
        write(6,*) 'evtype out of allowed range', evtype
        stop
      endif
      
      call random_number(tmp)
      get_evtime=-log(tmp)/rate
c      write(6,*) 'get_evtime: ',-log(tmp)/rate
c      write(6,*) 'get_evtime: tmp, -log(tmp), rate, -log(tmp)/rate',
c     @                         tmp, -log(tmp), rate, -log(tmp)/rate
      
c      if (evtype.eq.2) then
c         write(6,*) 'dstate 2, get_evtime complete'
c      endif
            
      return
      end

       subroutine update(indices,revmap,eventindex,value,times,dim)

!      i/o
       integer indices(*),revmap(*),dim
       integer eventindex
       double precision times(*),value
!      local
       integer lchild,rchild,fastest,nextcall,index
       integer temp,temp2,parent,fastev,slowev
       logical qmin
       double precision time1,time2
!
!
       index = revmap(eventindex)
       times(eventindex)=value
c       write(6,*) 'update: ',eventindex,index,value
       if (index.eq.1) then
          qmin = .false.
          lchild = 2*index
          rchild = 2*index+1
          if (times(indices(index)).gt.times(indices(lchild))) then 
             qmin=.true.
          endif
          if (times(indices(index)).gt.times(indices(rchild))) then
             qmin=.true.
          endif
          if (qmin) then
             call min_heapify(indices,revmap,times,index,dim)
          endif
       else
          parent = int(index/2)
          if ( times(indices(index)).lt.times(indices(parent)) ) then
             do while ( ((index.gt.1).and.
     @ (times(indices(index)).lt.times(indices(parent))) ))
                temp = indices(parent)
                indices(parent)=indices(index)
                revmap(indices(parent)) = parent
                indices(index) = temp
                revmap(indices(index)) = index
                index=parent
                parent=int(index/2)
             end do
          else
             qmin = .false.
             lchild = 2*index
             rchild = 2*index+1
             if (times(indices(index)).gt.times(indices(lchild))) then
                qmin =.true.
             endif
             if (times(indices(index)).gt.times(indices(rchild))) then
                qmin =.true.
             endif
             if (qmin) then
c                write(6,*) 'calling min_heapify'
                call min_heapify(indices,revmap,times,index,dim)
             endif
          endif
       endif
  
       return
       end


      Subroutine SubLowLefF(dep,dissocstate,state,ih,jh,iv,jv,temph,tempv,tempd)
      
      implicit none
      
      integer dep(13,*),dissocstate(13,*),state(13,*)
      integer ih,jh,iv,jv
      integer temph,tempv,tempd
            
            if (dep(iv,jv).eq.0) then																!Vertical is founder
               !Re-assign dependencies...
               if (dep(ih,jh).eq.5) then
                  dep(ih,jh)=1
               else
                  write(6,*) 'Wrong dependency for ',ih,jh
                  stop
               endif
               if (dissocstate(iv,jv).eq.8) then
                  if ((state(iv-1,jv).ne.0).and.(state(iv-1,jv+1).ne.0).and.(state(iv,jv+1).ne.0).and.(state(iv+1,jv+1).ne.0)) then
                     write(6,*) 'founder stays 8'
                  else
                     if (state(iv,jv).eq.1) then
                        tempv=5
                     elseif (state(iv,jv).eq.-1) then
                        tempv=6
                     else
                        write(6,*) 'Vertical subunit empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                  if ((state(iv-1,jv).ne.0).and.(state(iv-1,jv+1).ne.0).and.(state(iv,jv+1).ne.0)) then
                     if (state(iv,jv).eq.1) then
                        if (dissocstate(iv,jv).ne.5) then
                           write(6,*) 'switch dstate 5<=>6, vert founder'
                           tempv=5
                        endif
                     elseif (state(iv,jv).eq.-1) then
                        if (dissocstate(iv,jv).ne.6) then
                           write(6,*) 'switch dstate 5<=>6, diag founder'
                           tempv=6
                        endif
                     else
                        write(6,*) 'Vertical subunit empty?!'
                        stop
                     endif
                  else
                     tempv=2
                     !need to remove event for founder!
                  endif
               endif
               if (dissocstate(ih,jh).eq.8) then
                  if ((state(ih,jh-1).ne.0).and.(state(ih+1,jh-1).ne.0).and.(state(ih+1,jh).ne.0).and.(state(ih+1,jh+1).ne.0)) then
                     write(6,*) 'horizontal stays an 8'
                  else
                     if (state(ih,jh).eq.1) then
                        temph=5
                     elseif (state(ih,jh).eq.-1) then
                        temph=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  endif
               elseif (dissocstate(ih,jh).eq.5) then
                  temph=3
               elseif (dissocstate(ih,jh).eq.6) then
                  temph=4
               endif
               if (dissocstate(ih,jv).eq.8) then
                  if ((state(iv,jv+1).ne.0).and.(state(ih+1,jv).ne.0).and.(state(ih+1,jv+1).ne.0).and.(state(ih,jv+1).ne.0)) then
                     write(6,*) 'diagonal stays an 8'
                  elseif ((state(ih-1,jv+1).eq.0).or.(state(ih,jv+1).eq.0)) then
                     tempd=2
                  else
                     if (state(ih,jh).eq.1) then
                        tempd=5
                     elseif (state(ih,jh).eq.-1) then
                        tempd=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
                  tempd=2
               endif
            elseif (dep(ih,jh).eq.0) then															!Horizontal is founder
               !Re-assign dependencies...
               if (dep(iv,jv).eq.7) then
                  dep(iv,jv)=4
               else
                  write(6,*) 'Wrong dependency for ',iv,jv
                  stop
               endif
               if (dissocstate(iv,jv).eq.8) then
                  if ((state(iv-1,jv).ne.0).and.(state(iv-1,jv+1).ne.0).and.(state(iv,jv+1).ne.0).and.(state(iv+1,jv+1).ne.0)) then
                     write(6,*) 'vertical stays 8'
                  else
                     if (state(iv,jv).eq.1) then
                        tempv=5
                     elseif (state(iv,jv).eq.-1) then
                        tempv=6
                     else
                        write(6,*) 'Vertical subunit empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                  tempv=2
               endif
               if (dissocstate(ih,jh).eq.8) then
                  if ((state(ih,jh-1).ne.0).and.(state(ih+1,jh-1).ne.0).and.(state(ih+1,jh).ne.0).and.(state(ih+1,jh+1).ne.0)) then
                     write(6,*) 'founder stays 8'
                  else
                     if (state(ih,jh).eq.1) then
                        temph=5
                     elseif (state(ih,jh).eq.-1) then
                        temph=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(ih,jh).eq.5).or.(dissocstate(ih,jh).eq.6)) then
                  if ((state(ih,jh-1).ne.0).and.(state(ih+1,jh-1).ne.0).and.(state(ih+1,jh).ne.0)) then
                     if (state(ih,jh-1).eq.1) then
                        if (dissocstate(ih,jh).ne.5) then
                           write(6,*) 'switch dstate 5<=>6, horiz founder'
                           temph=5
                        endif
                     elseif (state(ih,jh-1).eq.-1) then
                        if (dissocstate(ih,jh).ne.6) then
                           write(6,*) 'switch dstate 5<=>6, horiz founder'
                           temph=6
                        endif
                     !Already tested for presence of subunit below horizontal
                     endif
                  else
                     temph=2
                     !need to remove event for founder!
                  endif
               endif
               if (dissocstate(ih,jv).eq.8) then
                  if ((state(ih+1,jh).ne.0).and.(state(ih,jv+1).ne.0).and.(state(ih+1,jv+1).ne.0).and.(state(ih+1,jv).ne.0)) then
                     write(6,*) 'diagonal stays an 8'
                  elseif ((state(ih+1,jh).eq.0).or.(state(ih+1,jv).eq.0)) then
                     if (state(ih,jh).eq.1) then
                        tempd=3
                     elseif (state(ih,jh).eq.-1) then
                        tempd=4
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  else
                     if (state(ih,jh).eq.1) then
                        tempd=5
                     elseif (state(ih,jh).eq.-1) then
                        tempd=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  endif
               elseif (dissocstate(ih,jv).eq.5) then
                  tempd=3
               elseif (dissocstate(ih,jv).eq.6) then
                  tempd=4
               endif
            elseif (dep(ih,jv).eq.0) then															!Diagonal is founder
               if (dissocstate(iv,jv).eq.8) then
                  if ((state(iv-1,jv).ne.0).and.(state(iv-1,jv+1).ne.0).and.(state(iv,jv+1).ne.0).and.(state(iv+1,jv+1).ne.0)) then
                     write(6,*) 'vertical stays 8'
                  else
                     if (state(iv,jv).eq.1) then
                        tempv=5
                     elseif (state(iv,jv).eq.-1) then
                        tempv=6
                     else
                        write(6,*) 'Vertical subunit empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                  tempv=2
               endif
               if (dissocstate(ih,jh).eq.8) then
                  if ((state(ih,jh-1).ne.0).and.(state(ih+1,jh-1).ne.0).and.(state(ih+1,jh).ne.0).and.(state(ih+1,jh+1).ne.0)) then
                     write(6,*) 'horizontal stays 8'
                  else
                     if (state(ih,jh).eq.1) then
                        temph=5
                     elseif (state(ih,jh).eq.-1) then
                        temph=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  endif
               elseif (dissocstate(ih,jh).eq.5) then
                  temph=3
               elseif (dissocstate(ih,jh).eq.6) then
                  temph=4
               endif
               if (dissocstate(ih,jv).eq.8) then
                  if ( ((state(iv,jv+1).ne.0).and.(state(ih+1,jv).ne.0).and.(state(ih+1,jv+1).ne.0).and.(state(ih,jv+1).ne.0)).or.
     @              ((state(ih+1,jh).ne.0).and.(state(ih,jv+1).ne.0).and.(state(ih+1,jv+1).ne.0).and.(state(ih+1,jv).ne.0)) ) then
                     write(6,*) 'founder stays 8'
                  elseif ( ((state(ih-1,jv+1).eq.0).or.(state(ih,jv+1).eq.0)).AND.
     @                     ((state(ih+1,jh).eq.0).or.(state(ih+1,jv).eq.0)) ) then					! no SQ on TOP or RIGHT
                     tempd=2
                     !need to kill dissoc event for founder
                  elseif ( ((state(ih-1,jv+1).ne.0).and.(state(ih,jv+1).ne.0)).AND.
     @                     ((state(ih+1,jh).eq.0).or.(state(ih+1,jv).eq.0)) ) then 					! SQ on TOP only
                     if (state(ih,jh).eq.1) then
                        tempd=5
                     elseif (state(ih,jh).eq.-1) then
                        tempd=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  elseif ( ((state(ih-1,jv+1).eq.0).or.(state(ih,jv+1).eq.0)).AND.
     @                     ((state(ih+1,jh).ne.0).and.(state(ih+1,jv).ne.0)) ) then 				! SQ on RIGHT only
                     if (state(ih,jh).eq.1) then
                        tempd=5
                     elseif (state(ih,jh).eq.-1) then
                        tempd=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
                  if ( (state(ih,jv+1).ne.0).AND.(state(ih+1,jv+1).ne.0).AND.(state(ih+1,jv).ne.0) ) then
                     if (state(ih,jh).eq.1) then
                        if (dissocstate(ih,jv).ne.5) then
                           write(6,*) 'switch dstate 5<=>6, diag founder'
                           tempd=5
                        endif
                     elseif (state(ih,jh).eq.-1) then
                        if (dissocstate(ih,jv).ne.6) then
                           write(6,*) 'switch dstate 5<=>6, diag founder'
                           tempd=6
                        endif
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  else
                     tempd=2
                     !need to remove dissoc event
                  endif
               endif
            else
               write(6,*) 'Founder not in square'
               stop
            endif
            
      return
      end


      Subroutine SubUppLefF(dep,dissocstate,state,ih,jh,iv,jv,temph,tempv,tempd)
      
      implicit none
      
      integer dep(13,*),dissocstate(13,*),state(13,*)
      integer ih,jh,iv,jv
      integer temph,tempv,tempd
            
            if (dep(iv,jv).eq.0) then																!Vertical is founder
               !Re-assign dependencies...
               if (dep(ih,jh).eq.8) then
                  dep(ih,jh)=2
               else
                  write(6,*) 'Wrong dependency for ',ih,jh
                  stop
               endif
               if (dissocstate(iv,jv).eq.8) then
                  if ((state(iv-1,jv).ne.0).and.(state(iv-1,jv-1).ne.0).and.(state(iv,jv-1).ne.0).and.(state(iv+1,jv-1).ne.0)) then
                     write(6,*) 'founder stays 8'
                  else
                     if (state(iv,jv-1).eq.1) then
                        tempv=5
                     elseif (state(iv,jv-1).eq.-1) then
                        tempv=6
                     else
                        !In order for vertical to be 8, subunit below must be there
                        write(6,*) 'Subunit below vertical empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                  if ((state(iv-1,jv).ne.0).and.(state(iv-1,jv-1).ne.0).and.(state(iv,jv-1).ne.0)) then
                     if (state(iv,jv-1).eq.1) then
                        if (dissocstate(iv,jv).ne.5) then
                           write(6,*) 'switch dstate 5<=>6, vert founder'
                           tempv=5
                        endif
                     elseif (state(iv,jv-1).eq.-1) then
                        if (dissocstate(iv,jv).ne.6) then
                           write(6,*) 'switch dstate 5<=>6, vert founder'
                           tempv=6
                        endif
                     !Already tested for presence of subunit below vertical
                     endif
                  else
                     tempv=2
                     !need to remove event for founder!
                  endif
               endif
               if (dissocstate(ih,jh).eq.8) then
                  if ((state(ih,jh+1).ne.0).and.(state(ih+1,jh+1).ne.0).and.(state(ih+1,jh).ne.0).and.(state(ih+1,jh-1).ne.0)) then
                     write(6,*) 'horizontal stays an 8'
                  else
                     if (state(ih,jv).eq.1) then
                        temph=5
                     elseif (state(ih,jv).eq.-1) then
                        temph=6
                     else
                        write(6,*) 'Diagonal subunit empty?!'
                        stop
                     endif
                  endif
               elseif (dissocstate(ih,jh).eq.5) then
                  temph=3
               elseif (dissocstate(ih,jh).eq.6) then
                  temph=4
               endif
               if (dissocstate(ih,jv).eq.8) then
                  if ((state(iv,jv-1).ne.0).and.(state(ih+1,jv).ne.0).and.(state(ih+1,jv-1).ne.0).and.(state(ih,jv-1).ne.0)) then
                     write(6,*) 'diagonal stays an 8'
                  elseif ((state(ih-1,jv-1).eq.0).or.(state(ih,jv-1).eq.0)) then
                     tempd=2
                  else
                     if (state(ih,jv-1).eq.1) then
                        tempd=5
                     elseif (state(ih,jv-1).eq.-1) then
                        tempd=6
                     else
                        !In order for diagonal to be 8 -> 5/6, subunit below must be there
                        write(6,*) 'Subunit below diagonal empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
                  tempd=2
               endif
            elseif (dep(ih,jh).eq.0) then															!Horizontal is founder
               !Re-assign dependencies...
               if (dep(iv,jv).eq.6) then
                  dep(iv,jv)=4
               else
                  write(6,*) 'Wrong dependency for ',iv,jv
                  stop
               endif
               if (dissocstate(iv,jv).eq.8) then 
                  if ((state(iv-1,jv).ne.0).and.(state(iv-1,jv-1).ne.0).and.(state(iv,jv-1).ne.0).and.(state(iv+1,jv-1).ne.0)) then
                     write(6,*) 'vertical stays 8'
                  else
                     if (state(iv,jv-1).eq.1) then
                        tempv=5
                     elseif (state(iv,jv-1).eq.-1) then
                        tempv=6
                     else
                        !In order for vertical to be 8, subunit below must be there
                        write(6,*) 'Subunit below vertical empty?!'
                        stop
                     endif
                  endif                              
               elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                  tempv=2
               endif
               if (dissocstate(ih,jh).eq.8) then
                  if ((state(ih,jh+1).ne.0).and.(state(ih+1,jh+1).ne.0).and.(state(ih+1,jh).ne.0).and.(state(ih+1,jh-1).ne.0)) then
                     write(6,*) 'founder stays 8'
                  else
                     if (state(ih,jv).eq.1) then
                        temph=5
                     elseif (state(ih,jv).eq.-1) then
                        temph=6
                     else
                        write(6,*) 'Diagonal subunit empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(ih,jh).eq.5).or.(dissocstate(ih,jh).eq.6)) then
                  if ((state(ih,jh+1).ne.0).and.(state(ih+1,jh+1).ne.0).and.(state(ih+1,jh).ne.0)) then
                     if (state(ih,jv).eq.1) then
                        if (dissocstate(ih,jh).ne.5) then
                           write(6,*) 'switch dstate 5<=>6, horiz founder'
                           temph=5
                        endif
                     elseif (state(ih,jv).eq.-1) then
                        if (dissocstate(ih,jh).ne.6) then
                           write(6,*) 'switch dstate 5<=>6, horiz founder'
                           temph=6
                        endif
                     else
                        write(6,*) 'Diagonal subunit empty?!'
                        stop
                     endif
                  else
                     temph=2
                     !need to remove event for founder!
                  endif
               endif
               if (dissocstate(ih,jv).eq.8) then
                  if ((state(ih+1,jh).ne.0).and.(state(ih,jv-1).ne.0).and.(state(ih+1,jv-1).ne.0).and.(state(ih+1,jv).ne.0)) then
                     write(6,*) 'diagonal stays an 8'
                  elseif ((state(ih+1,jh).eq.0).or.(state(ih+1,jv).eq.0)) then
                     if (state(ih,jv).eq.1) then
                        tempd=3
                     elseif (state(ih,jv).eq.-1) then
                        tempd=4
                     else
                        write(6,*) 'Diagonal subunit empty?!'
                        stop
                     endif
                  else
                     if (state(ih,jv).eq.1) then
                        tempd=5
                     elseif (state(ih,jv).eq.-1) then
                        tempd=6
                     else
                        write(6,*) 'Diagonal subunit empty?!'
                        stop
                     endif
                  endif
               elseif (dissocstate(ih,jv).eq.5) then
                  tempd=3
               elseif (dissocstate(ih,jv).eq.6) then
                  tempd=4
               endif
            elseif (dep(ih,jv).eq.0) then															!Diagonal is founder
               if (dissocstate(iv,jv).eq.8) then
                  if ((state(iv-1,jv).ne.0).and.(state(iv-1,jv-1).ne.0).and.(state(iv,jv-1).ne.0).and.(state(iv+1,jv-1).ne.0)) then
                     write(6,*) 'vertical stays 8'
                  else
                     if (state(iv,jv-1).eq.1) then
                        tempv=5
                     elseif (state(iv,jv-1).eq.-1) then
                        tempv=6
                     else
                     !In order for vertical to be 8, subunit below must be there
                        write(6,*) 'Subunit below vertical empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                  tempv=2
               endif
               if (dissocstate(ih,jh).eq.8) then
                  if ((state(ih,jh+1).ne.0).and.(state(ih+1,jh+1).ne.0).and.(state(ih+1,jh).ne.0).and.(state(ih+1,jh-1).ne.0)) then
                     write(6,*) 'horizontal stays 8'
                  else
                     if (state(ih,jv).eq.1) then
                        temph=5
                     elseif (state(ih,jv).eq.-1) then
                        temph=6
                     else
                        write(6,*) 'Diagonal subunit empty?!'
                        stop
                     endif
                  endif
               elseif (dissocstate(ih,jh).eq.5) then
                  temph=3
               elseif (dissocstate(ih,jh).eq.6) then
                  temph=4
               endif
               if (dissocstate(ih,jv).eq.8) then
                  if ( ((state(iv,jv-1).ne.0).and.(state(ih,jv-1).ne.0).and.(state(ih+1,jv-1).ne.0).and.(state(ih+1,jv).ne.0)).or.
     @              ((state(ih+1,jh).ne.0).and.(state(ih+1,jv).ne.0).and.(state(ih+1,jv-1).ne.0).and.(state(ih,jv-1).ne.0)) ) then
                     write(6,*) 'founder stays 8'
                  elseif ( ((state(ih-1,jv-1).eq.0).or.(state(ih,jv-1).eq.0)).AND.
     @                     ((state(ih+1,jh).eq.0).or.(state(ih+1,jv).eq.0)) ) then					! no SQ on BOT or RIGHT
                     tempd=2
                     !need to kill dissoc event for founder
                  elseif ( ((state(ih-1,jv-1).ne.0).and.(state(ih,jv-1).ne.0)).AND.
     @                     ((state(ih+1,jh).eq.0).or.(state(ih+1,jv).eq.0)) ) then 					! SQ on BOT only
                     if (state(ih,jv-1).eq.1) then
                        tempd=5
                     elseif (state(ih,jv-1).eq.-1) then
                        tempd=6
                        !Have already tested for presence of subunit below diagonal
                     endif
                  elseif ( ((state(ih-1,jv-1).eq.0).or.(state(ih,jv-1).eq.0)).AND.
     @                     ((state(ih+1,jh).ne.0).and.(state(ih+1,jv).ne.0)) ) then 				! SQ on RIGHT only
                     if (state(ih,jv).eq.1) then
                        tempd=5
                     elseif (state(ih,jv).eq.-1) then
                        tempd=6
                     else
                        write(6,*) 'Diagonal subunit empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
                  if ( (state(ih,jv-1).ne.0).AND.(state(ih+1,jv-1).ne.0).AND.(state(ih+1,jv).ne.0) ) then
                     if (state(ih,jv-1).eq.1) then
                        if (dissocstate(ih,jv).ne.5) then
                           write(6,*) 'switch dstate 5<=>6, diag founder'
                           tempd=5
                        endif
                     elseif (state(ih,jv-1).eq.-1) then
                        if (dissocstate(ih,jv).ne.6) then
                           write(6,*) 'switch dstate 5<=>6, diag founder'
                           tempd=6
                        endif
                     !Have already tested for presence of subunit below diagonal
                     endif
                  else
                     tempd=2
                     !need to remove dissoc event
                  endif
               endif
            else
               write(6,*) 'Founder not in square'
               stop
            endif
            
      return
      end
      
      
      Subroutine SubLowRigF(dep,dissocstate,state,ih,jh,iv,jv,temph,tempv,tempd)
      
      implicit none
      
      integer dep(13,*),dissocstate(13,*),state(13,*)
      integer ih,jh,iv,jv
      integer temph,tempv,tempd
            
            if (dep(iv,jv).eq.0) then																!Vertical is founder
               !Re-assign dependencies...
               if (dep(ih,jh).eq.6) then
                  dep(ih,jh)=1
               else
                  write(6,*) 'Wrong dependency for ',ih,jh
                  stop
               endif
               if (dissocstate(iv,jv).eq.8) then
                  if ((state(iv+1,jv).ne.0).and.(state(iv+1,jv+1).ne.0).and.(state(iv,jv+1).ne.0).and.(state(iv-1,jv+1).ne.0)) then
                     write(6,*) 'founder stays 8'
                  else
                     if (state(iv,jv).eq.1) then
                        tempv=5
                     elseif (state(iv,jv).eq.-1) then
                        tempv=6
                     else
                        write(6,*) 'Vertical subunit empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                  if ((state(iv+1,jv).ne.0).and.(state(iv+1,jv+1).ne.0).and.(state(iv,jv+1).ne.0)) then
                     if (state(iv,jv).eq.1) then
                        if (dissocstate(iv,jv).ne.5) then
                           write(6,*) 'switch dstate 5<=>6, vert founder'
                           tempv=5
                        endif
                     elseif (state(iv,jv).eq.-1) then
                        if (dissocstate(iv,jv).ne.6) then
                           write(6,*) 'switch dstate 5<=>6, vert founder'
                           tempv=6
                        endif
                     else
                        write(6,*) 'Vertical subunit empty?!'
                        stop
                     endif
                  else
                     tempv=2
                     !need to remove event for founder!
                  endif
               endif
               if (dissocstate(ih,jh).eq.8) then
                  if ((state(ih-1,jh).ne.0).and.(state(ih-1,jh-1).ne.0).and.(state(ih,jh-1).ne.0).and.(state(ih-1,jh+1).ne.0)) then
                     write(6,*) 'horizontal stays an 8'
                  else
                     if (state(ih,jh).eq.1) then
                        temph=5
                     elseif (state(ih,jh).eq.-1) then
                        temph=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  endif
               elseif (dissocstate(ih,jh).eq.5) then
                  temph=3
               elseif (dissocstate(ih,jh).eq.6) then
                  temph=4
               endif
               if (dissocstate(ih,jv).eq.8) then
                  if ((state(iv,jv+1).ne.0).and.(state(ih-1,jv).ne.0).and.(state(ih-1,jv+1).ne.0).and.(state(ih,jv+1).ne.0)) then
                     write(6,*) 'diagonal stays an 8'
                  elseif ((state(iv,jv+1).eq.0).or.(state(ih,jv+1).eq.0)) then
                     tempd=2
                  else
                     if (state(ih,jh).eq.1) then
                        tempd=5
                     elseif (state(ih,jh).eq.-1) then
                        tempd=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
                  tempd=2
               endif
            elseif (dep(ih,jh).eq.0) then															!Horizontal is founder
               !Re-assign dependencies...
               if (dep(iv,jv).eq.8) then
                  dep(iv,jv)=3
               else
                  write(6,*) 'Wrong dependency for ',iv,jv
                  stop
               endif
               if (dissocstate(iv,jv).eq.8) then
                  if ((state(iv,jv+1).ne.0).and.(state(iv+1,jv+1).ne.0).and.(state(iv+1,jv).ne.0).and.(state(iv-1,jv+1).ne.0)) then
                     write(6,*) 'vertical stays 8'
                  else
                     if (state(iv,jv).eq.1) then
                        tempv=5
                     elseif (state(iv,jv).eq.-1) then
                        tempv=6
                     else
                        write(6,*) 'Vertical subunit empty?!'
                        stop
                     endif
                  endif                          
               elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                  tempv=2
               endif
               if (dissocstate(ih,jh).eq.8) then               
                  if ((state(ih,jh-1).ne.0).and.(state(ih-1,jh-1).ne.0).and.(state(ih-1,jh).ne.0).and.(state(ih-1,jh+1).ne.0)) then
                     write(6,*) 'founder stays 8'
                  else
                     if (state(ih,jh).eq.1) then
                        temph=5
                     elseif (state(ih,jh).eq.-1) then
                        temph=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  endif                              
               elseif ((dissocstate(ih,jh).eq.5).or.(dissocstate(ih,jh).eq.6)) then
                  if ((state(ih,jh-1).ne.0).and.(state(ih-1,jh-1).ne.0).and.(state(ih-1,jh).ne.0)) then
                     if (state(ih,jh-1).eq.1) then
                        if (dissocstate(ih,jh).ne.5) then
                           write(6,*) 'switch dstate 5<=>6, horiz founder'
                           temph=5
                        endif
                     elseif (state(ih,jh-1).eq.-1) then
                        if (dissocstate(ih,jh).ne.6) then
                           write(6,*) 'switch dstate 5<=>6, horiz founder'
                           temph=6
                        endif
                     !Already tested for presence of subunit below horizontal
                     endif
                  else
                     temph=2
                     !need to remove event for founder!
                  endif
               endif
               if (dissocstate(ih,jv).eq.8) then
                  if ((state(ih-1,jh).ne.0).and.(state(ih,jv+1).ne.0).and.(state(ih-1,jv).ne.0).and.(state(ih-1,jv+1).ne.0)) then
                     write(6,*) 'diagonal stays an 8'
                  elseif ((state(ih-1,jh).eq.0).or.(state(ih-1,jv).eq.0)) then
                     if (state(ih,jh).eq.1) then
                        tempd=3
                     elseif (state(ih,jh).eq.-1) then
                        tempd=4
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  else
                     if (state(ih,jh).eq.1) then
                        tempd=5
                     elseif (state(ih,jh).eq.-1) then
                        tempd=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  endif
               elseif (dissocstate(ih,jv).eq.5) then
                  tempd=3
               elseif (dissocstate(ih,jv).eq.6) then
                  tempd=4
               endif
            elseif (dep(ih,jv).eq.0) then															!Diagonal is founder
               if (dissocstate(iv,jv).eq.8) then
                  if ((state(iv+1,jv).ne.0).and.(state(iv+1,jv+1).ne.0).and.(state(iv,jv+1).ne.0).and.(state(iv-1,jv+1).ne.0)) then
                     write(6,*) 'vertical stays 8'
                  else
                     if (state(iv,jv).eq.1) then
                        tempv=5
                     elseif (state(iv,jv).eq.-1) then
                        tempv=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                  tempv=2
               endif
               if (dissocstate(ih,jh).eq.8) then
                  if ((state(ih,jh-1).ne.0).and.(state(ih-1,jh-1).ne.0).and.(state(ih-1,jh).ne.0).and.(state(ih-1,jh+1).ne.0)) then
                     write(6,*) 'horizontal stays 8'
                  else
                     if (state(ih,jh).eq.1) then
                        temph=5
                     elseif (state(ih,jh).eq.-1) then
                        temph=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  endif
               elseif (dissocstate(ih,jh).eq.5) then
                  temph=3
               elseif (dissocstate(ih,jh).eq.6) then
                  temph=4
               endif
               if (dissocstate(ih,jv).eq.8) then
                  if ( ((state(ih-1,jv+1).ne.0).and.(state(ih,jv+1).ne.0).and.(state(ih-1,jv-1).ne.0).and.(state(ih-1,jv).ne.0)).or.
     @              ((state(ih-1,jv).ne.0).and.(state(ih-1,jv+1).ne.0).and.(state(ih,jv+1).ne.0).and.(state(ih,jv+1).ne.0)) ) then
                     write(6,*) 'founder stays 8'
                  elseif ( ((state(ih,jv+1).eq.0).or.(state(ih+1,jv+1).eq.0)).AND.
     @                     ((state(ih-1,jh).eq.0).or.(state(ih-1,jv).eq.0)) ) then					! no SQ on TOP or LEFT
                     tempd=2
                     !need to kill dissoc event for founder
                  elseif ( ((state(ih,jv+1).ne.0).and.(state(ih+1,jv+1).ne.0)).AND.
     @                     ((state(ih-1,jh).eq.0).or.(state(ih-1,jv).eq.0)) ) then 					! SQ on TOP only
                     if (state(ih,jh).eq.1) then
                        tempd=5
                     elseif (state(ih,jh).eq.-1) then
                        tempd=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  elseif ( ((state(ih,jv+1).eq.0).or.(state(ih+1,jv+1).eq.0)).AND.
     @                     ((state(ih-1,jh).ne.0).and.(state(ih-1,jv).ne.0)) ) then 				! SQ on LEFT only
                     if (state(ih,jh).eq.1) then
                        tempd=5
                     elseif (state(ih,jh).eq.-1) then
                        tempd=6
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
                  if ( (state(ih,jv+1).ne.0).AND.(state(ih-1,jv+1).ne.0).AND.(state(ih-1,jv).ne.0) ) then
                     if (state(ih,jh).eq.1) then
                        if (dissocstate(ih,jv).ne.5) then
                           write(6,*) 'switch dstate 5<=>6, diag founder'
                           tempd=5
                        endif
                     elseif (state(ih,jh).eq.-1) then
                        if (dissocstate(ih,jv).ne.6) then
                           write(6,*) 'switch dstate 5<=>6, diag founder'
                           tempd=6
                        endif
                     else
                        write(6,*) 'Horizontal subunit empty?!'
                        stop
                     endif
                  else
                     tempd=2
                     !need to remove dissoc event
                  endif
               endif
            else
               write(6,*) 'Founder not in square'
               stop
            endif

      return
      end
      
      
      Subroutine SubUppRigF(dep,dissocstate,state,ih,jh,iv,jv,temph,tempv,tempd)
      
      implicit none
      
      integer dep(13,*),dissocstate(13,*),state(13,*)
      integer ih,jh,iv,jv
      integer temph,tempv,tempd
            
            if (dep(iv,jv).eq.0) then																!Vertical is founder
               !Re-assign dependencies...
               if (dep(ih,jh).eq.7) then
                  dep(ih,jh)=2
               else
                  write(6,*) 'Wrong dependency for ',ih,jh
                  stop
               endif
               if (dissocstate(iv,jv).eq.8) then
                  if ((state(iv+1,jv).ne.0).and.(state(iv+1,jv-1).ne.0).and.(state(iv,jv-1).ne.0).and.(state(iv-1,jv-1).ne.0)) then
                     write(6,*) 'founder stays 8'
                  else
                     if (state(iv,jv-1).eq.1) then
                        tempv=5
                     elseif (state(iv,jv-1).eq.-1) then
                        tempv=6
                     else
                     !In order for vertical to be 8, subunit below must be there
                        write(6,*) 'Subunit below vertical empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                  if ((state(iv+1,jv).ne.0).and.(state(iv+1,jv-1).ne.0).and.(state(iv,jv-1).ne.0)) then
                     if (state(iv,jv-1).eq.1) then
                        if (dissocstate(iv,jv).ne.5) then
                           write(6,*) 'switch dstate 5<=>6, vert founder'
                           tempv=5
                        endif
                     elseif (state(iv,jv-1).eq.-1) then
                        if (dissocstate(iv,jv).ne.6) then
                           write(6,*) 'switch dstate 5<=>6, vert founder'
                           tempv=6
                        endif
                     !Already tested for presence of subunit below vertical
                     endif
                  else
                     tempv=2
                     !need to remove event for founder!
                  endif
               endif
               if (dissocstate(ih,jh).eq.8) then
                  if ((state(ih-1,jh).ne.0).and.(state(ih-1,jh+1).ne.0).and.(state(ih,jh+1).ne.0).and.(state(ih-1,jh-1).ne.0)) then
                     write(6,*) 'horizontal stays an 8'
                  else
                     if (state(ih,jv).eq.1) then
                        temph=5
                     elseif (state(ih,jv).eq.-1) then
                        temph=6
                     else
                        write(6,*) 'Diagonal subunit empty?!'
                        stop
                     endif
                  endif
               elseif (dissocstate(ih,jh).eq.5) then
                  temph=3
               elseif (dissocstate(ih,jh).eq.6) then
                  temph=4
               endif
               if (dissocstate(ih,jv).eq.8) then
                  if ((state(iv,jv-1).ne.0).and.(state(ih-1,jv).ne.0).and.(state(ih-1,jv-1).ne.0).and.(state(ih,jv-1).ne.0)) then
                     write(6,*) 'diagonal stays an 8'
                  elseif ((state(iv,jv-1).eq.0).or.(state(ih,jv-1).eq.0)) then
                     tempd=2
                  else
                     if (state(ih,jv-1).eq.1) then
                        tempd=5
                     elseif (state(ih,jv-1).eq.-1) then
                        tempd=6
                     else
                     !In order for diagonal to be 8 -> 5/6, subunit below must be there
                        write(6,*) 'Subunit below diagonal empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
                  tempd=2
               endif
            elseif (dep(ih,jh).eq.0) then															!Horizontal is founder
               !Re-assign dependencies...
               if (dep(iv,jv).eq.5) then
                  dep(iv,jv)=3
               else
                  write(6,*) 'Wrong dependency for ',iv,jv
                  stop
               endif
               if (dissocstate(iv,jv).eq.8) then
                  if ((state(iv,jv-1).ne.0).and.(state(iv+1,jv-1).ne.0).and.(state(iv+1,jv).ne.0).and.(state(iv-1,jv-1).ne.0)) then
                     write(6,*) 'vertical stays 8'
                  else
                     if (state(iv,jv-1).eq.1) then
                        tempv=5
                     elseif (state(iv,jv-1).eq.-1) then
                        tempv=6
                     else
                     !In order for vertical to be 8, subunit below must be there
                        write(6,*) 'Subunit below vertical empty?!'
                        stop
                     endif
                  endif       
               elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                  tempv=2
               endif
               if (dissocstate(ih,jh).eq.8) then
                  if ((state(ih,jh+1).ne.0).and.(state(ih-1,jh+1).ne.0).and.(state(ih-1,jh).ne.0).and.(state(ih-1,jh-1).ne.0)) then
                     write(6,*) 'founder stays 8'
                  else
                     if (state(ih,jv).eq.1) then
                        temph=5
                     elseif (state(ih,jv).eq.-1) then
                        temph=6
                     else
                        write(6,*) 'Diagonal subunit empty?!'
                        stop
                     endif
                  endif                              
               elseif ((dissocstate(ih,jh).eq.5).or.(dissocstate(ih,jh).eq.6)) then
                  if ((state(ih,jh+1).ne.0).and.(state(ih-1,jh+1).ne.0).and.(state(ih-1,jh).ne.0)) then
                     if (state(ih,jv).eq.1) then
                        if (dissocstate(ih,jh).ne.5) then
                           write(6,*) 'switch dstate 5<=>6, horiz founder'
                           temph=5
                        endif
                     elseif (state(ih,jv).eq.-1) then
                        if (dissocstate(ih,jh).ne.6) then
                           write(6,*) 'switch dstate 5<=>6, horiz founder'
                           temph=6
                        endif
                     else
                        write(6,*) 'Diagonal subunit empty?!'
                        stop
                     endif
                  else
                     temph=2
                     !need to remove event for founder!
                  endif
               endif
               if (dissocstate(ih,jv).eq.8) then
                  if ((state(ih-1,jh).ne.0).and.(state(ih,jv-1).ne.0).and.(state(ih-1,jv).ne.0).and.(state(ih-1,jv-1).ne.0)) then
                     write(6,*) 'diagonal stays an 8'
                  elseif ((state(ih-1,jh).eq.0).or.(state(ih-1,jv).eq.0)) then
                     if (state(ih,jv).eq.1) then
                        tempd=3
                     elseif (state(ih,jv).eq.-1) then
                        tempd=4
                     else
                        write(6,*) 'Diagonal subunit empty?!'
                        stop
                     endif
                  else
                     if (state(ih,jv).eq.1) then
                        tempd=5
                     elseif (state(ih,jv).eq.-1) then
                        tempd=6
                     else
                        write(6,*) 'Diagonal subunit empty?!'
                        stop
                     endif
                  endif
               elseif (dissocstate(ih,jv).eq.5) then
                  tempd=3
               elseif (dissocstate(ih,jv).eq.6) then
                  tempd=4
               endif
            elseif (dep(ih,jv).eq.0) then															!Diagonal is founder
               if (dissocstate(iv,jv).eq.8) then
                  if ((state(iv,jv-1).ne.0).and.(state(iv+1,jv).ne.0).and.(state(iv+1,jv-1).ne.0).and.(state(iv-1,jv-1).ne.0)) then
                     write(6,*) 'vertical stays 8'
                  else
                     if (state(iv,jv-1).eq.1) then
                        tempv=5
                     elseif (state(iv,jv-1).eq.-1) then
                        tempv=6
                     else
                     !In order for vertical to be 8, subunit below must be there
                        write(6,*) 'Subunit below vertical empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                  tempv=2
               endif
               if (dissocstate(ih,jh).eq.8) then
                  if ((state(ih-1,jh).ne.0).and.(state(ih-1,jh+1).ne.0).and.(state(ih,jh+1).ne.0).and.(state(ih-1,jh-1).ne.0)) then
                     write(6,*) 'horizontal stays 8'
                  else
                     if (state(ih,jv).eq.1) then
                        temph=5
                     elseif (state(ih,jv).eq.-1) then
                        temph=6
                     else
                        write(6,*) 'Diagonal subunit empty?!'
                        stop
                     endif
                  endif
               elseif (dissocstate(ih,jh).eq.5) then
                  temph=3
               elseif (dissocstate(ih,jh).eq.6) then
                  temph=4
               endif
               if (dissocstate(ih,jv).eq.8) then
                  if ( ((state(ih-1,jv+1).ne.0).and.(state(ih,jv-1).ne.0).and.(state(ih-1,jv-1).ne.0).and.(state(ih-1,jv).ne.0)).or.
     @              ((state(ih-1,jv).ne.0).and.(state(ih-1,jv-1).ne.0).and.(state(ih,jv-1).ne.0).and.(state(iv,jv-1).ne.0)) ) then
                     write(6,*) 'founder stays 8'
                  elseif ( ((state(ih,jv-1).eq.0).or.(state(ih+1,jv-1).eq.0)).AND.
     @                     ((state(ih-1,jh).eq.0).or.(state(ih-1,jv).eq.0)) ) then					! no SQ on BOT or LEFT
                     tempd=2
                     !need to kill dissoc event for founder
                  elseif ( ((state(ih,jv-1).ne.0).and.(state(ih+1,jv-1).ne.0)).AND.
     @                     ((state(ih-1,jh).eq.0).or.(state(ih-1,jv).eq.0)) ) then 					! SQ on BOT only
                     if (state(ih,jv-1).eq.1) then
                        tempd=5
                     elseif (state(ih,jv-1).eq.-1) then
                        tempd=6
                     !Already tested for presence of subunit below diagonal
                     endif
                  elseif ( ((state(ih,jv-1).eq.0).or.(state(ih+1,jv-1).eq.0)).AND.
     @                     ((state(ih-1,jh).ne.0).and.(state(ih-1,jv).ne.0)) ) then 				! SQ on LEFT only
                     if (state(ih,jv).eq.1) then
                        tempd=5
                     elseif (state(ih,jv).eq.-1) then
                        tempd=6
                     else
                        write(6,*) 'Diagonal subunit empty?!'
                        stop
                     endif
                  endif
               elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
                  if ( (state(ih,jv-1).ne.0).AND.(state(ih-1,jv-1).ne.0).AND.(state(ih-1,jv).ne.0) ) then
                     if (state(ih,jv-1).eq.1) then
                        if (dissocstate(ih,jv).ne.5) then
                           write(6,*) 'switch dstate 5<=>6, diag founder'
                           tempd=5
                        endif
                     elseif (state(ih,jv-1).eq.-1) then
                        if (dissocstate(ih,jv).ne.6) then
                           write(6,*) 'switch dstate 5<=>6, diag founder'
                           tempd=6
                        endif
                     !Already tested for presence of subunit below diagonal
                     endif
                  else
                     tempd=2
                     !need to remove dissoc event
                  endif
               endif
            else
               write(6,*) 'Founder not in square'
               stop
            endif

      return
      end
      
      
      Subroutine SubLowLef(dep,dissocstate,state,ih,jh,iv,jv,temph,tempv,tempd)
      
      implicit none
      
      integer dep(13,*),dissocstate(13,*),state(13,*)
      integer ih,jh,iv,jv
      integer temph,tempv,tempd
      
      integer dh,dv,dd
            
            dh=dep(ih,jh)
            dv=dep(iv,jv)
            dd=dep(ih,jv)
            
c            write(6,*) 'special subunit should always be to the right: ',ih,jh
            
c            write(6,*) 'dep of vertical has to change'
c            write(6,*) 'dep before: ',dep(iv,jv)
            if ((state(iv,jv+1).ne.0).and.(state(iv+1,jv+1).ne.0)) then							!added conditions for dependencies
               dv=6
            elseif ((state(iv-1,jv).ne.0).and.(state(iv-1,jv+1).ne.0).and.
     @             (state(iv,jv+1).ne.0)) then
               dv=5
            else
               dv=4
            endif
c            write(6,*) 'dep after: ',dep(iv,jv)
            
            if (dissocstate(ih,jv).eq.8) then
               if ((state(ih-1,jv+1).ne.0).and.(state(ih,jv+1).ne.0).and.(state(ih+1,jv+1).ne.0)
     @            .and.(state(ih+1,jv).ne.0).and.(state(ih+1,jv-1).ne.0)) then
c                  write(6,*) 'diagonal stays an 8'
               elseif (state(ih-1,jv+1).eq.0) then
                  if ((state(ih,jv).eq.1).and.(state(ih,jh).eq.1)) then
c                     write(6,*) 'dstate 8 -> 10 for ',ih,jv
                     tempd=10
                  elseif ((state(ih,jv).eq.-1).or.(state(ih,jh).eq.-1)) then
c                     write(6,*) 'dstate 8 -> 10 for ',ih,jv
                     tempd=11
c                     write(6,*) 'need to check for double GDP'
                  else
                     write(6,*) 'bad state for ',ih,jv,'or ',ih,jh
                     stop
                  endif
               elseif (state(ih+1,jv+1).eq.0) then
                  if (state(ih,jh).eq.1) then
c                     write(6,*) 'dstate 8 -> 5 for ',ih,jv
                     tempd=5
                  elseif (state(ih,jh).eq.-1) then
c                     write(6,*) 'dstate 8 -> 6 for ',ih,jv
                     tempd=6
                  else
                     write(6,*) 'bad state for ',ih,jh
                     stop
                  endif
               elseif (state(ih+1,jv-1).eq.0) then
                  if (state(ih,jh).eq.1) then
c                     write(6,*) 'dstate 8 -> 3 for ',ih,jv
                     tempd=3
                  elseif (state(ih,jh).eq.-1) then
c                     write(6,*) 'dstate 8 -> 4 for ',ih,jv
                     tempd=4
                  else
                     write(6,*) 'bad state for ',ih,jh
                     stop
                  endif
               endif
            elseif (dissocstate(ih,jv).eq.13) then
c               write(6,*) 'dstate 13 -> 6 for ',ih,jv
               tempd=6
            elseif (dissocstate(ih,jv).eq.12) then
c               write(6,*) 'dstate 12 -> 5 for ',ih,jv
               tempd=5
            elseif (dissocstate(ih,jv).eq.5) then
c               write(6,*) 'dstate 5 -> 3 for ',ih,jv
               tempd=3
            elseif (dissocstate(ih,jv).eq.6) then
c               write(6,*) 'dstate 6 -> 4 for ',ih,jv
               tempd=4
            else
               write(6,*) 'bad dstate for ',ih,jv,': ',dissocstate(ih,jv)
               stop
            endif   
            
            if (dissocstate(ih,jh).eq.8) then
               if ((state(ih,jh).eq.1).and.(state(ih,jh-1).eq.1)) then
c                  write(6,*) 'dstate 8 -> 10 for ',ih,jh
                  temph=10
               elseif ((state(ih,jh).eq.-1).or.(state(ih,jh-1).eq.-1)) then
c                  write(6,*) 'dstate 8 -> 11 for ',ih,jh
                  temph=11
c                  write(6,*) 'need to check for double GDP'
               else
                  write(6,*) 'bad state for ',ih,jh,'or ',ih,jh-1
                  stop
               endif
            elseif (dissocstate(ih,jh).eq.13) then
c               write(6,*) 'dstate 13 -> 6 for ',ih,jh
               temph=6
            elseif (dissocstate(ih,jh).eq.12) then
c               write(6,*) 'dstate 12 -> 5 for ',ih,jh
               temph=5
            elseif ((dissocstate(ih,jh).eq.5).or.(dissocstate(ih,jh).eq.6)) then
               if (((state(ih+1,jh+1).eq.0).and.(state(ih-1,jh-1).eq.0)).and.((state(ih+1,jh).ne.0)
     @            .and.(state(ih+1,jh-1).ne.0).and.(state(ih,jh-1).ne.0))) then
                  if (dep(ih,jh).eq.7) then
c                     write(6,*) 'dstate stays 5/6 for ',ih,jh
                  else
                     write(6,*) 'bad dep for ',ih,jh,': ',dep(ih,jh)
                     stop
                  endif
               else
                  if (dissocstate(ih,jh).eq.5) then
c                     write(6,*) 'dstate 5 -> 3 for ',ih,jh
                     temph=3
                  elseif (dissocstate(ih,jh).eq.6) then
c                     write(6,*) 'dstate 6 -> 4 for ',ih,jh
                     temph=4
                  endif
               endif
            else
               write(6,*) 'bad dstate for ',ih,jh,': ',dissocstate(ih,jh)
               stop
            endif
            
            if (dissocstate(iv,jv).eq.8) then
               if (state(iv,jv).eq.1) then
c                  write(6,*) 'dstate 8 -> 12 for ',iv,jv
                  tempv=12
               elseif (state(iv,jv).eq.-1) then
c                  write(6,*) 'dstate 8 -> 13 for ',iv,jv
                  tempv=13
               else
                  write(6,*) 'bad state for ',iv,jv
                  stop
               endif
            elseif (dissocstate(iv,jv).eq.11) then
               if (state(iv,jv).eq.1) then
c                  write(6,*) 'dstate 11 -> 5 for ',iv,jv
                  tempv=5
               elseif (state(iv,jv).eq.-1) then
c                  write(6,*) 'dstate 11 -> 6 for ',iv,jv
                  tempv=6
               else
                  write(6,*) 'bad state for ',iv,jv
                  stop
               endif
            elseif (dissocstate(iv,jv).eq.10) then
c               write(6,*) 'dstate 10 -> 5 for ',iv,jv
               tempv=5
            elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
c               write(6,*) 'dstate 5/6 -> 2 for ',iv,jv
               tempv=2
            endif

c            write(6,*) 'end SubLowLef: h,v,d -> ',temph,tempv,tempd            
c            write(6,*) 'At end of SubLowLef'
c            write(6,*) 'DEPs before: ',dep(ih,jh),dep(iv,jv),dep(ih,jv)
c            write(6,*) 'DEPs after : ',dh,dv,dd
            dep(ih,jh)=dh
            dep(iv,jv)=dv
            dep(ih,jv)=dd
            
      return
      end


      Subroutine SubUppLef(dep,dissocstate,state,ih,jh,iv,jv,temph,tempv,tempd)
      
      implicit none
      
      integer dep(13,*),dissocstate(13,*),state(13,*)
      integer ih,jh,iv,jv
      integer temph,tempv,tempd
      
      integer dh,dv,dd
      double precision get_evtime
      
            dh=dep(ih,jh)
            dv=dep(iv,jv)
            dd=dep(ih,jv)

c            write(6,*) 'subuppleftt, assume diag is special',ih,jh,iv,jv
               if (dissocstate(ih,jh).eq.5) then
                  temph=3
               elseif (dissocstate(ih,jh).eq.6) then
                  temph=4
               elseif (dissocstate(ih,jh).eq.8) then
                  if ((state(ih,jh).eq.1).and.(state(ih,jh-1).eq.1)) then
                     temph=10
                  elseif ((state(ih,jh).eq.1).and.(state(ih,jh-1).eq.-1)) then
                     temph=11
                  elseif ((state(ih,jh).eq.-1).and.(state(ih,jh-1).eq.1)) then
                     temph=11
                  elseif ((state(ih,jh).eq.-1).and.(state(ih,jh-1).eq.-1)) then
c                     write(6,*) 'need to figure out the double gtp/gdp stuff'
                     temph=11
                  else
                     write(6,*) 'empty subunit where one should not be?'
                     stop
                  endif
               elseif (dissocstate(ih,jh).eq.12) then												!
c                  write(6,*) 'marker1624'															!
                  temph=5																			!
               elseif (dissocstate(ih,jh).eq.13) then												!
c                  write(6,*) 'marker1625'															!
                  temph=6																			!
               endif
               if (dep(ih,jh).eq.8) then
                  if (temph.ge.5) then																!replaced dissocstate(ih,jh) with temph
c                     write(6,*) 'resetting dep of h-neighb from 8 to 7'
                     dh=7
                  else
c                     write(6,*) 'resetting dep of h-neighb from 8 to 2'
                     dh=2
                  endif
               endif
c               write(6,*) 'only check below if j.gt.103'
               if (jh.gt.103) then
               if ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                  if (((state(iv-1,jv+1).eq.0).and.(state(iv+1,jv-1).eq.0)).and.
     @               ((state(iv-1,jv).ne.0).and.(state(iv-1,jv-1).ne.0).and.
     @               (state(iv,jv-1).ne.0))) then
c                     write(6,*) 'dstate stays 5/6 for ',iv,jv
                  else
                     tempv=2
                  endif
               elseif (dissocstate(iv,jv).eq.8) then
                  if (state(iv,jv-1).eq.1) then														!
c                     write(6,*) 'marker1627'														!
                     tempv=12																		!
                  elseif (state(iv,jv-1).eq.-1) then												!
c                     write(6,*) 'marker1628'														!
                     tempv=13																		!
                  else																				!
c                     write(6,*) 'marker1629'														!
                     write(6,*) 'empty subunit below vertical??'									!
                     stop																			!
                  endif																				!
               elseif (dissocstate(iv,jv).eq.11) then												!
c                  write(6,*) 'marker1631'															!
                  if (state(iv,jv-1).eq.1) then														!
                     tempv=5																		!
                  elseif (state(iv,jv-1).eq.-1) then												!
                     tempv=6																		!
                  else																				!
                     write(6,*) 'empty subunit below vertical??'									!
                     stop																			!
                  endif																				!
               elseif (dissocstate(iv,jv).eq.10) then
c                  write(6,*) 'marker1930'
                  tempv=5
               else
c                  write(6,*) 'marker1633'															!
                  write(6,*) 'bad dissocstate ',dissocstate(iv,jv),' for ',iv,jv					!
                  stop																				!
               endif
               if (dissocstate(ih,jv).eq.8) then													!diagonal subunit
                  if ((temph.ge.5).and.(tempv.ge.5)) then													!
c                     write(6,*) 'marker1634'														!
c                     write(6,*) 'diagonal stays 8'		
                     tempd=8!
                  elseif ((temph.lt.5).and.(tempv.ge.5)) then
c                     write(6,*) 'h neighb lt 5: diag goes to 12/13'
                     if (state(ih,jv-1).eq.1) then
c                        write(6,*) 'gtp below diag'
                        tempd=12
                     elseif (state(ih,jv-1).eq.-1) then
c                        write(6,*) 'gdp below diag'
                        tempd=13
                     else
                        write(6,*) 'neither gtp or gdp below??'
                        stop
                     endif
                  elseif ((temph.ge.5).and.(tempv.lt.5)) then
c                     write(6,*) 'v neighb lt 5: diag goes to 10/11'
                     if ((state(ih,jv).eq.1).and.(state(ih,jv-1).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',ih,jv
                        tempd=10
                     elseif ((state(ih,jv).eq.-1).or.(state(ih,jv-1).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',ih,jv
                        tempd=11
                     else
                        write(6,*) 'bad state for ',ih,jv
                        stop
                     endif
                  else
                     write(6,*) 'h and v neighbs lt 5, how could diag be 8??'
                     stop
                  endif
               elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
                  if (((state(ih+1,jv+1).eq.0).and.(state(ih-1,jv-1).eq.0)).and.
     @               ((state(ih+1,jv).ne.0).and.(state(ih+1,jv-1).ne.0).and.
     @               (state(ih,jv-1).ne.0))) then
c                     write(6,*) 'dstate stays 5/6 for ',ih,jv
                  else
                     tempd=2
                  endif
               elseif (dissocstate(ih,jv).eq.11) then
c                  write(6,*) 'marker1931'
                  if (state(ih,jv-1).eq.1) then
                     tempd=5
                  elseif (state(ih,jv-1).eq.-1) then
                     tempd=6
                  else
                     write(6,*) 'empty subunit below diagonal??'
                     stop
                  endif
               elseif ((dissocstate(ih,jv).eq.10).or.(dissocstate(ih,jv).eq.12)) then				!
c                  write(6,*) 'marker1653'															!
                  tempd=5																			!
               elseif (dissocstate(ih,jv).eq.13) then												!
c                  write(6,*) 'marker1654'															!
                  tempd=6																			!
               endif
               endif

c            write(6,*) 'At end of SubUppLef'
c            write(6,*) 'DEPs before: ',dep(ih,jh),dep(iv,jv),dep(ih,jv)
c            write(6,*) 'DEPs after : ',dh,dv,dd
            dep(ih,jh)=dh
            dep(iv,jv)=dv
            dep(ih,jv)=dd

      return
      end


      Subroutine SubLowRig(dep,dissocstate,state,ih,jh,iv,jv,temph,tempv,tempd)
      
      implicit none
      
      integer dep(13,*),dissocstate(13,*),state(13,*)
      integer ih,jh,iv,jv
      integer temph,tempv,tempd
            
      integer dh,dv,dd
      
            dh=dep(ih,jh)
            dv=dep(iv,jv)
            dd=dep(ih,jv)
            
c            write(6,*) 'special subunit should always be to the left: ',ih,jh
            
c            write(6,*) 'dep of vertical has to change'
c            write(6,*) 'dep before: ',dep(iv,jv)
            if ((state(iv-1,jv+1).ne.0).and.(state(iv,jv+1).ne.0)) then								!added conditions for dependencies
               dv=5
            elseif ((state(iv,jv+1).ne.0).and.(state(iv+1,jv+1).ne.0).and.
     @             (state(iv+1,jv).ne.0)) then
               dv=6
            else
               dv=3
            endif
c            write(6,*) 'dep after: ',dep(iv,jv)
            
            if (dissocstate(ih,jv).eq.8) then
               if ((state(ih-1,jv-1).ne.0).and.(state(ih-1,jv).ne.0).and.(state(ih-1,jv+1).ne.0)
     @            .and.(state(ih,jv+1).ne.0).and.(state(ih+1,jv+1).ne.0)) then
c                  write(6,*) 'diagonal stays an 8'
               elseif (state(ih+1,jv+1).eq.0) then
                  if ((state(ih,jv).eq.1).and.(state(ih,jh).eq.1)) then
c                     write(6,*) 'dstate 8 -> 10 for ',ih,jv
                     tempd=10
                  elseif ((state(ih,jv).eq.-1).or.(state(ih,jh).eq.-1)) then
c                     write(6,*) 'dstate 8 -> 10 for ',ih,jv
                     tempd=11
c                     write(6,*) 'need to check for double GDP'
                  else
                     write(6,*) 'bad state for ',ih,jv,'or ',ih,jh
                     stop
                  endif
               elseif (state(ih-1,jv+1).eq.0) then
                  if (state(ih,jh).eq.1) then
c                     write(6,*) 'dstate 8 -> 5 for ',ih,jv
                     tempd=5
                  elseif (state(ih,jh).eq.-1) then
c                     write(6,*) 'dstate 8 -> 6 for ',ih,jv
                     tempd=6
                  else
                     write(6,*) 'bad state for ',ih,jh
                     stop
                  endif
               elseif (state(ih-1,jv-1).eq.0) then
                  if (state(ih,jh).eq.1) then
c                     write(6,*) 'dstate 8 -> 3 for ',ih,jv
                     tempd=3
                  elseif (state(ih,jh).eq.-1) then
c                     write(6,*) 'dstate 8 -> 4 for ',ih,jv
                     tempd=4
                  else
                     write(6,*) 'bad state for ',ih,jh
                     stop
                  endif
               endif
            elseif (dissocstate(ih,jv).eq.13) then
c               write(6,*) 'dstate 13 -> 6 for ',ih,jv
               tempd=6
            elseif (dissocstate(ih,jv).eq.12) then
c               write(6,*) 'dstate 12 -> 5 for ',ih,jv
               tempd=5
            elseif (dissocstate(ih,jv).eq.5) then
c               write(6,*) 'dstate 5 -> 3 for ',ih,jv
               tempd=3
            elseif (dissocstate(ih,jv).eq.6) then
c               write(6,*) 'dstate 6 -> 4 for ',ih,jv
               tempd=4
            else
               write(6,*) 'bad dstate for ',ih,jv,': ',dissocstate(ih,jv)
               stop
            endif   
            
            if (dissocstate(ih,jh).eq.8) then
               if ((state(ih,jh).eq.1).and.(state(ih,jh-1).eq.1)) then
c                  write(6,*) 'dstate 8 -> 10 for ',ih,jh
                  temph=10
               elseif ((state(ih,jh).eq.-1).or.(state(ih,jh-1).eq.-1)) then
c                  write(6,*) 'dstate 8 -> 11 for ',ih,jh
                  temph=11
c                  write(6,*) 'need to check for double GDP'
               else
                  write(6,*) 'bad state for ',ih,jh,'or ',ih,jh-1
                  stop
               endif
            elseif (dissocstate(ih,jh).eq.13) then
c               write(6,*) 'dstate 13 -> 6 for ',ih,jh
               temph=6
            elseif (dissocstate(ih,jh).eq.12) then
c               write(6,*) 'dstate 12 -> 5 for ',ih,jh
               temph=5
            elseif ((dissocstate(ih,jh).eq.5).or.(dissocstate(ih,jh).eq.6)) then
               if (((state(ih-1,jh+1).eq.0).and.(state(ih+1,jh-1).eq.0)).and.((state(ih-1,jh).ne.0)
     @            .and.(state(ih-1,jh-1).ne.0).and.(state(ih,jh-1).ne.0))) then
                  if (dep(ih,jh).eq.8) then
c                     write(6,*) 'dstate stays 5/6 for ',ih,jh
                  else
                     write(6,*) 'bad dep for ',ih,jh,': ',dep(ih,jh)
                     stop
                  endif
               else
                  if (dissocstate(ih,jh).eq.5) then
c                     write(6,*) 'dstate 5 -> 3 for ',ih,jh
                     temph=3
                  elseif (dissocstate(ih,jh).eq.6) then
c                     write(6,*) 'dstate 6 -> 4 for ',ih,jh
                     temph=4
                  endif
               endif
            else
               write(6,*) 'bad dstate for ',ih,jh,': ',dissocstate(ih,jh)
               stop
            endif
            
            if (dissocstate(iv,jv).eq.8) then
               if (state(iv,jv).eq.1) then
c                  write(6,*) 'dstate 8 -> 12 for ',iv,jv
                  tempv=12
               elseif (state(iv,jv).eq.-1) then
c                  write(6,*) 'dstate 8 -> 13 for ',iv,jv
                  tempv=13
               else
                  write(6,*) 'bad state for ',iv,jv
                  stop
               endif
            elseif (dissocstate(iv,jv).eq.11) then
               if (state(iv,jv).eq.1) then
c                  write(6,*) 'dstate 11 -> 5 for ',iv,jv
                  tempv=5
               elseif (state(iv,jv).eq.-1) then
c                  write(6,*) 'dstate 11 -> 6 for ',iv,jv
                  tempv=6
               else
                  write(6,*) 'bad state for ',iv,jv
                  stop
               endif
            elseif (dissocstate(iv,jv).eq.10) then
c               write(6,*) 'dstate 10 -> 5 for ',iv,jv
               tempv=5
            elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
c               write(6,*) 'dstate 5/6 -> 2 for ',iv,jv
               tempv=2
            endif
            
c            write(6,*) 'end SubLowRig: h,v,d -> ',temph,tempv,tempd
c            write(6,*) 'At end of SubLowLef'
c            write(6,*) 'DEPs before: ',dep(ih,jh),dep(iv,jv),dep(ih,jv)
c            write(6,*) 'DEPs after : ',dh,dv,dd
            dep(ih,jh)=dh
            dep(iv,jv)=dv
            dep(ih,jv)=dd
            
      return
      end


      Subroutine SubUppRig(dep,dissocstate,state,ih,jh,iv,jv,temph,tempv,tempd)
      
      implicit none
      
      integer dep(13,*),dissocstate(13,*),state(13,*)
      integer ih,jh,iv,jv
      integer temph,tempv,tempd
            
      integer dh,dv,dd
      
            dh=dep(ih,jh)
            dv=dep(iv,jv)
            dd=dep(ih,jv)


c            write(6,*) 'subuppright, assume diag is special'
               if (dissocstate(ih,jh).eq.5) then													!horizontal subunit
                  temph=3
               elseif (dissocstate(ih,jh).eq.6) then
                  temph=4
               elseif (dissocstate(ih,jh).eq.8) then
                  if ((state(ih,jh).eq.1).and.(state(ih,jh-1).eq.1)) then
                     temph=10
                  elseif ((state(ih,jh).eq.1).and.(state(ih,jh-1).eq.-1)) then
                     temph=11
                  elseif ((state(ih,jh).eq.-1).and.(state(ih,jh-1).eq.1)) then
                     temph=11
                  elseif ((state(ih,jh).eq.-1).and.(state(ih,jh-1).eq.-1)) then
c                     write(6,*) 'need to figure out the double gtp/gdp stuff'
                     temph=11
                  else
                     write(6,*) 'empty subunit where one should not be?'
                     stop
                  endif
               elseif (dissocstate(ih,jh).eq.12) then												!
c                  write(6,*) 'marker1794'															!
                  temph=5																			!
               elseif (dissocstate(ih,jh).eq.13) then												!
c                  write(6,*) 'marker1795'															!
                  temph=6																			!
               else
c                  write(6,*) 'marker1796'															!
                  write(6,*) 'bad dissocstate ',dissocstate(ih,jh),' for ',ih,jh					!
                  stop																				!
               endif
               if ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then						!vertical subunit
                  if (((state(iv-1,jv-1).eq.0).and.(state(iv+1,jv+1).eq.0)).and.
     @               ((state(iv,jv-1).ne.0).and.(state(iv+1,jv-1).ne.0).and.
     @               (state(iv+1,jv).ne.0))) then
c                     write(6,*) 'dstate stays 5/6 for ',iv,jv
                  else
                     tempv=2
                  endif
               elseif (dissocstate(iv,jv).eq.10) then
c                  write(6,*) 'marker1938'
                  tempv=5
               elseif (dissocstate(iv,jv).eq.11) then												!
c                  write(6,*) 'marker1803'															!
                  if (state(iv,jv-1).eq.1) then														!
                     tempv=5																		!
                  elseif (state(iv,jv-1).eq.-1) then												!
                     tempv=6																		!
                  else																				!
                     write(6,*) 'empty subunit below vertical??'									!
                     stop																			!
                  endif																				!
               elseif (dissocstate(iv,jv).eq.8) then
                  if (state(iv,jv-1).eq.1) then														!
c                     write(6,*) 'marker1797'														!
                     tempv=12																		!
                  elseif (state(iv,jv-1).eq.-1) then												!
c                     write(6,*) 'marker1798'														!
                     tempv=13																		!
                  else																				!
c                     write(6,*) 'marker1799'														!
                     write(6,*) 'empty subunit below vertical??'									!
                     stop																			!
                  endif																				!
               else
c                  write(6,*) 'marker1805'															!
                  write(6,*) 'bad dissocstate ',dissocstate(iv,jv),' for ',iv,jv					!
                  stop																				!
               endif
               if (dissocstate(ih,jv).eq.8) then
                  if ((temph.ge.5).and.(tempv.ge.5)) then													!
c                     write(6,*) 'marker1634'														!
c                     write(6,*) 'diagonal stays 8'		
                     tempd=8!
                  elseif ((temph.lt.5).and.(tempv.ge.5)) then
c                     write(6,*) 'h neighb lt 5: diag goes to 12/13'
                     if (state(ih,jv-1).eq.1) then
c                        write(6,*) 'gtp below diag'
                        tempd=12
                     elseif (state(ih,jv-1).eq.-1) then
c                        write(6,*) 'gdp below diag'
                        tempd=13
                     else
                        write(6,*) 'neither gtp or gdp below??'
                        stop
                     endif
                  elseif ((temph.ge.5).and.(tempv.lt.5)) then
c                     write(6,*) 'v neighb lt 5: diag goes to 10/11'
                     if ((state(ih,jv).eq.1).and.(state(ih,jv-1).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',ih,jv
                        tempd=10
                     elseif ((state(ih,jv).eq.-1).or.(state(ih,jv-1).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',ih,jv
                        tempd=11
                     else
                        write(6,*) 'bad state for ',ih,jv
                        stop
                     endif
                  else
                     write(6,*) 'h and v neighbs lt 5, how could diag be 8??'
                     stop
                  endif
               elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
                  if (((state(ih-1,jv+1).eq.0).and.(state(ih+1,jv-1).eq.0)).and.
     @               ((state(ih-1,jv).ne.0).and.(state(ih-1,jv-1).ne.0).and.
     @               (state(ih,jv-1).ne.0))) then
c                     write(6,*) 'dstate stays 5/6 for ',ih,jv
                  else
                     tempd=2
                  endif
               elseif (dissocstate(ih,jv).eq.10) then				!
c                  write(6,*) 'marker1825'															!
                  tempd=5																			!
               elseif (dissocstate(ih,jv).eq.11) then
c                  write(6,*) 'marker1939'
                  if (state(ih,jv-1).eq.1) then
                     tempd=5
                  elseif (state(ih,jv-1).eq.-1) then
                     tempd=6
                  else
                     write(6,*) 'empty subunit below diagonal??'
                     stop
                  endif
               endif!
               if (dep(ih,jh).eq.7) then
                  if (temph.ge.5) then
                     dh=8
                  else
                     dh=2
                  endif
               endif
            
c            write(6,*) 'At end of SubUppRig'
c            write(6,*) 'DEPs before: ',dep(ih,jh),dep(iv,jv),dep(ih,jv)
c            write(6,*) 'DEPs after : ',dh,dv,dd
c            write(6,*) 'End SubUppRig: h,v,d',temph,tempv,tempd
            dep(ih,jh)=dh
            dep(iv,jv)=dv
            dep(ih,jv)=dd

      return
      end
c
c
       subroutine EIemptyabove(i,j,dep,dissocstate,addstate,state,times,event,revmap,ev,totev,nev,
     @                         nrecyc,recyc,xloc,yloc,k_on,conc,GDP,K_lat,K_long,K_both,K_hyd,
     @                         K_thr_long,K_thr_lat,K_all,seammult,k_ne)

       implicit none
c
c i/o variables
       integer i,j,dep(13,*),dissocstate(13,*),addstate(13,*),state(13,*)
       integer event(*),revmap(*),ev(13,2000,*)
       integer totev,nev(13,*),nrecyc,recyc(*),xloc(*),yloc(*)
       double precision times(*)
       double precision k_on,conc,GDP,K_lat,K_long,K_both,K_hyd
       double precision K_thr_long,K_thr_lat,K_all,k_ne
       double precision seammult(13,*)
       double precision get_evtime
c local variables
       integer il,jl,ir,jr,ib,jb,temp,ll,kk
       logical qspec
       
            il=i-1
            jl=j
            ir=i+1
            jr=j
            ib=i
            jb=j-1

c            write(6,*) 'assume vert is special, dont worry about dep of bottom row'

               dep(i,j)=7                                                                      		! Assign new dependencies
               if (dep(il,jl).eq.2) dep(il,jl)=7
               if (dep(il,jl).eq.8) dep(i,j)=8
                  
               if ((dep(il,jl).ne.7).and.(dep(il,jl).ne.8)) then
                  write (6,*) 'dep not right, possible loop? dep(il,jl)= ',dep(il,jl)
                  stop
               endif
               if (dep(ir,jr).eq.2) then
                  dep(ir,jr)=8
               elseif (dep(ir,jr).eq.7) then
c                  write(6,*) 'leave right dep at 7'
               else
                  write (6,*) 'dep not right, possible loop? dep(ir,jr)= ',dep(ir,jr)
                  stop
               endif

c not possible to have dstate 3/4->8 here                              
c               write(6,*) 'elemptyabove, dstate left',il,jl,dissocstate(il,jl)
               temp=dissocstate(il,jl)							                               		! do dstate for left
               if (dissocstate(il,jl).eq.3) then
                  temp=5
               elseif (dissocstate(il,jl).eq.4) then
                  temp=6
               elseif (dissocstate(il,jl).eq.5) then												!
c                  write(6,*) 'marker324'															!
                  temp=12																			!
               elseif (dissocstate(il,jl).eq.6) then												!
c                  write(6,*) 'marker325'															!
                  temp=13																			!
               elseif ((dissocstate(il,jl).eq.10).or.(dissocstate(il,jl).eq.11)) then				!
c                  write(6,*) 'marker326'															!
                  temp=8																			!
               else
c                  write(6,*) 'marker327'															!
                  write(6,*) 'bad dissocstate ',dissocstate(il,jl),' for ',il,jl					!
                  stop																				!
               endif
c               write(6,*) 'times of il,jl: ',times(ev(il,jl,2))
c               write(6,*) 'event of il,jl: ',ev(il,jl,2)
               if (temp.ne.dissocstate(il,jl)) then
c                  write(6,*) 'updating dissocstate'
                  dissocstate(il,jl)=temp
c                  write(6,*) 'dissocstate updated: ',dissocstate(il,jl)
c                  write(6,*) 'updating times'
c                  do kk=1,totev
c         			write(6,*) 'times b4',kk,times(event(kk)),event(kk),revmap(kk)
c      			  end do
c      			  write(6,*) 'seammult ',seammult(il,jl)
                  times(ev(il,jl,2))=get_evtime(dissocstate(il,jl),k_on,conc,GDP,K_lat,
     @                      K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,k_ne,seammult(il,jl))
c                  write(6,*) 'times updated: ',times(ev(il,jl,2))
c                  write(6,*) 'calling update'
                  call update(event,revmap,ev(il,jl,2),times(ev(il,jl,2)),times,totev)
c                  write(6,*) 'update called'
               endif
c not possible to have dstate 3/4->8 here                                             
c               write(6,*) 'elemptyabove, dstate right',ir,jr,dissocstate(ir,jr)
               temp=dissocstate(ir,jr)							                               		! do dstate for right
               if (dissocstate(ir,jr).eq.3) then
                  temp=5
               elseif (dissocstate(ir,jr).eq.4) then
                  temp=6
               elseif (dissocstate(ir,jr).eq.5) then												!
c                  write(6,*) 'marker338'															!
                  temp=12																			!
               elseif (dissocstate(ir,jr).eq.6) then												!
c                  write(6,*) 'marker339'															!
                  temp=13																			!
               elseif ((dissocstate(ir,jr).eq.10).or.(dissocstate(ir,jr).eq.11)) then				!
c                  write(6,*) 'marker340'															!
                  temp=8																			!
               else
c                  write(6,*) 'marker341'															!
                  write(6,*) 'bad dissocstate ',dissocstate(ir,jr),' for ',ir,jr					!
                  stop																				!
               endif
               if (temp.ne.dissocstate(ir,jr)) then
                  dissocstate(ir,jr)=temp
                  times(ev(ir,jr,2))=get_evtime(dissocstate(ir,jr),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(ir,jr))
                  call update(event,revmap,ev(ir,jr,2),times(ev(ir,jr,2)),times,totev)
               endif
																									! do dstate below
			   if (j.gt.103) then

c                  write(6,*) 'checking bottom middle'
			      
			      temp=dissocstate(ib,jb)
			      if ((dissocstate(ib,jb).eq.12).or.(dissocstate(ib,jb).eq.13)) then
			         temp=8
			      else
			         write(6,*) 'eiemptyabove, fix dstate checks bottom, only did 12,13'
			         stop
			      endif
                  if (temp.ne.dissocstate(ib,jb)) then
                     dissocstate(ib,jb)=temp
                     times(ev(ib,jb,2))=get_evtime(dissocstate(ib,jb),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(ib,jb))
                     call update(event,revmap,ev(ib,jb,2),times(ev(ib,jb,2)),times,totev)
                  endif


c                  write(6,*) 'checking bottom diagonals'

               temp=dissocstate(il,jb)							                               		! do dstate for lower left
               if (dissocstate(il,jb).eq.2) then
c                  write(6,*) 'marker328'															!
                  if ((state(il-1,jb+1).ne.0).and.(state(il-1,jb).ne.0).and.						!
     @               (state(il-1,jb-1).ne.0).and.(state(il,jb-1).ne.0)) then						!
                     temp=8																			!
                  elseif ((state(i-2,j).ne.0).and.(state(i-2,j-1).ne.0)) then						!
                     if (state(il,jb).eq.1) then													!
                        temp=12																		!
                     elseif (state(il,jb).eq.-1) then												!
                        temp=13																		!
                     else																			!
                        write(6,*) 'empty lower left subunit??'										!
                        stop																		!
                     endif																			!
                  else
                     if (state(il,jb).eq.1) then
                        temp=5
                     elseif (state(il,jb).eq.-1) then
                        temp=6
                     else
                        write(6,*) 'empty LOWERLEFT subunit??'
                        stop                  
                     endif
                  endif
               elseif ((dissocstate(il,jb).eq.5).or.(dissocstate(il,jb).eq.6)) then					!
                     if ((state(il,jb).eq.1).and.(state(il,jb-1).eq.1)) then						!
c                        write(6,*) 'marker329'														!
                        temp=10																		!
                     elseif ((state(il,jb).eq.-1).or.(state(il,jb-1).eq.-1)) then					!
c                        write(6,*) 'marker330'														!
                        temp=11																		!
                     else																			!
                        write(6,*) 'empty lower left subunit or subunit below??'					!
                        stop																		!
                     endif																			!
               elseif (dissocstate(il,jb).ge.12) then												!
c                  write(6,*) 'marker331'															!
                  temp=8																			!
               elseif ((dissocstate(il,jb).eq.3).or.(dissocstate(il,jb).eq.4).or.
     @                (dissocstate(il,jb).eq.10).or.(dissocstate(il,jb).eq.11)) then
c                  write(6,*) 'marker332'															!
                  write(6,*) 'bad dissocstate ',dissocstate(il,jb),' for ',il,jb					!
                  stop																				!
               endif
               if (temp.ne.dissocstate(il,jb)) then
                  dissocstate(il,jb)=temp
                  times(ev(il,jb,2))=get_evtime(dissocstate(il,jb),k_on,conc,
     @                               GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                               K_thr_lat,K_all,k_ne,seammult(il,jb))
c Adding code to check for double GDP for dstate 11.
                  if (temp.eq.11) then
                     if ((state(il,jb).eq.-1).and.(state(il,jb-1).eq.-1)) then
c                        write(6,*) 'double GDP, recalculate times'
                        times(ev(il,jb,2))=times(ev(il,jb,2))*GDP
                     else
c                        write(6,*) 'single GDP, do nothing'
                     endif
                  endif
cccccccccccccccccccccccccccccccccccccccccccccccccccc
                  call update(event,revmap,ev(il,jb,2),times(ev(il,jb,2)),times,totev)
               endif

               temp=dissocstate(ir,jb)							                               		! do dstate for lower right
               if (dissocstate(ir,jb).eq.2) then
c                  write(6,*) 'marker333'															!
                  if ((state(ir,jb-1).ne.0).and.(state(ir+1,jb-1).ne.0).and.						!
     @               (state(ir+1,jb).ne.0).and.(state(ir+1,jb+1).ne.0)) then						!
                     temp=8																			!
                  elseif ((state(i+2,j).ne.0).and.(state(i+2,j-1).ne.0)) then						!
                     if (state(ir,jb).eq.1) then													!
                        temp=12																		!
                     elseif (state(ir,jb).eq.-1) then												!
                        temp=13																		!
                     else																			!
                        write(6,*) 'empty lower right subunit??'									!
                        stop																		!
                     endif																			!
                  else
                     if (state(ir,jb).eq.1) then
                        temp=5
                     elseif (state(ir,jb).eq.-1) then
                        temp=6
                     else
                        write(6,*) 'empty LOWER RIGHT subunit??'
                        stop                  
                     endif
                  endif
               elseif ((dissocstate(ir,jb).eq.5).or.(dissocstate(ir,jb).eq.6)) then					!
                  if ((state(ir-1,jb-1).ne.0).and.(state(ir,jb-1).ne.0).and.						!
     @               (state(ir+1,jb).ne.0).and.(state(ir+1,jb+1).ne.0)) then						!
c                     write(6,*) 'marker1878'														!
                     temp=8																			!
                  else																				!
                     if ((state(ir,jb).eq.1).and.(state(ir,jb-1).eq.1)) then						!
c                        write(6,*) 'marker334'														!
                        temp=10																		!
                     elseif ((state(ir,jb).eq.-1).or.(state(ir,jb-1).eq.-1)) then					!
c                        write(6,*) 'marker335'														!
                        temp=11																		!
                     else																			!
                        write(6,*) 'empty lower right subunit or subunit below??'					!
                        stop																		!
                     endif																			!
                  endif																				!
               elseif (dissocstate(ir,jb).ge.12) then												!
c                  write(6,*) 'marker336'															!
                  temp=8																			!
               elseif ((dissocstate(ir,jb).eq.3).or.(dissocstate(ir,jb).eq.4).or.
     @                (dissocstate(ir,jb).eq.10).or.(dissocstate(ir,jb).eq.11)) then
c                  write(6,*) 'marker337'															!
                  write(6,*) 'bad dissocstate ',dissocstate(ir,jb),' for ',ir,jb					!
                  stop																				!
               endif
               if (temp.ne.dissocstate(ir,jb)) then
                  dissocstate(ir,jb)=temp
                  times(ev(ir,jb,2))=get_evtime(dissocstate(ir,jb),k_on,conc,
     @                               GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                               K_thr_lat,K_all,k_ne,seammult(ir,jb))
c Adding code to check for double GDP for dstate 11.
                  if (temp.eq.11) then
                     if ((state(ir,jb).eq.-1).and.(state(ir,jb-1).eq.-1)) then
c                        write(6,*) 'double GDP, recalculate times'
                        times(ev(ir,jb,2))=times(ev(ir,jb,2))*GDP
                     else
c                        write(6,*) 'single GDP, do nothing'
                     endif
                  endif
cccccccccccccccccccccccccccccccccccccccccccccccccccc
                  call update(event,revmap,ev(ir,jb,2),times(ev(ir,jb,2)),times,totev)
               endif
               endif

       return
       end
c
c
       subroutine EIemptybelow(i,j,dep,dissocstate,addstate,state,times,event,revmap,ev,totev,nev,
     @                         nrecyc,recyc,xloc,yloc,k_on,conc,GDP,K_lat,K_long,K_both,K_hyd)
c
c i/o variables
       integer i,j,dep(13,*),dissocstate(13,*),addstate(13,*),state(13,*)
       integer event(*),revmap(*),ev(13,2000,*)
       integer totev,nev(13,*),nrecyc,recyc(*),xloc(*),yloc(*)
       double precision times(*)
       double precision k_on,conc,GDP,K_lat,K_long,K_both,K_hyd
       
c local variables
       integer il,jl,ir,jr,it,jt,temp,ll
       logical qspec
       
            il=i-1
            jl=j
            ir=i+1
            jr=j
            it=i
            jt=j+1
c
c   find special subunit
            qspec=.false.
            write(6,*) 'Starting Elemptybelow'
            stop
            if ((dep(il,jl).eq.0).or.(dep(il,jl).eq.2).or.(dep(il,jl).eq.3).or.(dep(il,jl).eq.8)) then			! Left is special/founder
c               write(6,*) 'Left is special'
               qspec=.true.
               dep(i,j)=3
               if (dep(it,jt).eq.3) then                                                    		! Assign dependencies
                  dep(it,jt)=8
               else
                  write(6,*) 'dep not right, possible loop? dep(it,jt)= ',dep(it,jt)
                  stop
               endif
               if (dep(ir,jr).eq.1) then
                  dep(ir,jr)=3
               else
                  write(6,*) 'dep not right, possible loop? dep(ir,jr)= ',dep(ir,jr)
                  stop
               endif
               if (dep(ir,jt).eq.3) then
                  dep(ir,jt)=8
               else
                  write(6,*) 'dep not right, possible loop? dep(ir,jt)= ',dep(ir,jt)
                  stop
               endif
               if (dep(il,jl).ne.0) then									    			   		! Left is not founder
                  temp=dissocstate(il,jl)   
                  if (dissocstate(il,jl).ge.5) then                                            		! Assign new dissocstates
                     if ( (state(i-2,j+1).ne.0).and.(state(i-2,j).ne.0) ) then
                        temp = 8
                     else
c                        write(6,*) 'dissocstate will stay the same for (il,jl)'
                     endif
                  else
c                     write(6,*) 'dissocstate will stay the same for (il,jl)'
                  endif
                  if (temp.ne.dissocstate(il,jl)) then                  
                     dissocstate(il,jl)=temp
                     times(ev(il,jl,2))=get_evtime(dissocstate(il,jl),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                     call update(event,revmap,ev(il,jl,2),times(ev(il,jl,2)),times,totev)
                  endif      
               else                     										               		! Left is founder
                  temp=dissocstate(il,jl)
                  if (dissocstate(il,jl).lt.5) then                                            		! Assign new dissocstates
                     if (state(il,jl).eq.1) then
                        temp=5
                     elseif (state(il,jl).eq.-1) then
                        temp=6
                     else
                        write(6,*) 'empty LEFT founder'
                        stop
                     endif
                  elseif (dissocstate(il,jl).ge.5) then
                     if ( (state(i-2,j+1).ne.0).and.(state(i-2,j).ne.0) ) then
                        temp = 8
                     else
c                        write (6,*) 'dissocstate will stay the same for (il,jl)'
                     endif
                  endif
c
c this is not correct below - changing dissocstate but then testing for it right after
c now has been fixed
                  if (temp.ne.dissocstate(il,jl)) then
                     if (dissocstate(il,jl).ge.5) then
                        dissocstate(il,jl)=temp
                        times(ev(il,jl,2))=get_evtime(dissocstate(il,jl),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                        call update(event,revmap,ev(il,jl,2),times(ev(il,jl,2)),times,totev)
                     else
                        dissocstate(il,jl)=temp
                        if (state(il,jl).ne.0) then
                           totev=totev+1
                           nev(il,jl)=nev(il,jl)+1
                           if (nrecyc.eq.0) then
                              xloc(totev)=il
                              yloc(totev)=jl
                              ev(il,jl,2)=totev
                           else
                              ev(il,jl,2)=recyc(1)
                              xloc(recyc(1))=il
                              yloc(recyc(1))=jl
                              if (nrecyc.gt.1) then
                                 recyc(1)=recyc(nrecyc)
                                 call hpsort(nrecyc-1,recyc)
                              endif
                           endif
                           nrecyc=nrecyc-1
                        endif
                        times(ev(il,jl,2))=get_evtime(dissocstate(il,jl),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd)
                        event(totev)=ev(il,jl,2)
                        revmap(ev(il,jl,2))=totev
                        call build_min_heap(event,revmap,times,totev)
                     end if 
                  endif
               endif
c
c new logic below captures case where dstate 3/4->8, need to dbl chk and insert elsewhere                        
               temp=dissocstate(il,jt)							                               		! do dstate for upper left
               if ( (dissocstate(il,jt).eq.3).or.(dissocstate(il,jt).eq.4) ) then
                  if ( (state(i,j+2).ne.0).AND.(state(i-1,j+2).ne.0) ) then
                     temp = 8
                  else
                     if (dissocstate(il,jt).eq.3) then
                        temp=5
                     elseif (dissocstate(il,jt).eq.4) then
                        temp=6
                     endif
                  endif
               elseif (dissocstate(il,jt).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=2 for adding into 8, upper left'
                  stop
               endif
               if (temp.ne.dissocstate(il,jt)) then
                  dissocstate(il,jt)=temp
                  times(ev(il,jt,2))=get_evtime(dissocstate(il,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(il,jt,2),times(ev(il,jt,2)),times,totev)
               endif
               temp=dissocstate(it,jt)							                               		! do dstate for upper middle
               if ( (dissocstate(it,jt).eq.2).or.(dissocstate(it,jt).ge.5) ) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=3,4 for adding into 8, upper middle'
                  stop
               endif
               if (temp.ne.dissocstate(it,jt)) then
                  dissocstate(it,jt)=temp
                  times(ev(it,jt,2))=get_evtime(dissocstate(it,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(it,jt,2),times(ev(it,jt,2)),times,totev)
               endif
c
c new logic below captures case where dstate 2->8, need to dbl chk and insert elsewhere                                          
               temp=dissocstate(ir,jt)							                               		! do dstate for upper right
               if (dissocstate(ir,jt).eq.2) then
                  if ( (state(i+2,j).ne.0).and.(state(i+2,j+1).ne.0) ) then
                     temp=8
                  else
                     if (state(ir,jr).eq.1) then
                        temp=5
                     elseif (state(ir,jr).eq.-1) then
                        temp=6
                     else
                        write(6,*) 'empty RIGHT neighbor??'
                        stop                  
                     endif
                  endif
               elseif (dissocstate(ir,jt).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=3,4 for adding into 8, upper right'
                  stop
               endif
               if (temp.ne.dissocstate(ir,jt)) then
                  dissocstate(ir,jt)=temp
                  times(ev(ir,jt,2))=get_evtime(dissocstate(ir,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(ir,jt,2),times(ev(ir,jt,2)),times,totev)
               endif
c
c not possible to have dstate 3/4->8 here               
               temp=dissocstate(ir,jr)							                               		! do dstate for right
               if (dissocstate(ir,jr).eq.3) then
                  temp=5
               elseif (dissocstate(ir,jr).eq.4) then
                  temp = 6
               elseif (dissocstate(ir,jr).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=2 for adding into 8, right'
                  stop
               endif
               if (temp.ne.dissocstate(ir,jr)) then
                  dissocstate(ir,jr)=temp
                  times(ev(ir,jr,2))=get_evtime(dissocstate(ir,jr),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(ir,jr,2),times(ev(ir,jr,2)),times,totev)
               endif
c going to test to see if other subunits outside of region have proper dependencies
               if ((state(i+2,j+1).ne.0).and.(state(i+2,j).ne.0)) then
                  if ((dep(i+2,j+1).ne.8).and.(dep(i+2,j).ne.3)) then
                     write(6,*) 'STOP! Dependencies need to be changed for ',i+2,j+1,' and ',i+2,j                  
                     stop
                  endif
               endif
            elseif ( (dep(il,jt).eq.1).or.(dep(il,jt).eq.3).or.(dep(il,jt).eq.5).or.(dep(il,jt).eq.0) ) then		   ! UPLEFT is Special/Founder
c               write(6,*) 'Upperleft is special'
               if (qspec) then
                  write(6,*) 'two special subunits?, LOWLEFT'
                  stop
               endif
               qspec=.true.
               dep(i,j)=5
               if (dep(ir,jr).eq.1) then                                                    		! Assign new dependencies
                  dep(ir,jr)=5
               else
                  write (6,*) 'dep not right, possible loop? dep(ir,jr)= ',dep(ir,jr)
                  stop
               endif
               if (dep(il,jt).ne.0) then                                                       		! Upperleft is not founder
                  temp=dissocstate(il,jt)
                  if (dissocstate(il,jt).ge.5) then                                            		! Assign new dissocstate
                     if ( ((state(i-2,j+1).ne.0).and.(state(i-2,j).ne.0)).or.
     @                    ((state(i,j+2).ne.0).and.(state(i-1,j+2).ne.0)) ) then
                        temp=8
                     else
c                        write (6,*) 'dissocstate will stay the same for (il,jt)'
                     endif
                  else
c                     write (6,*) 'dissocstate will stay the same for (il,jt)'
                  endif
                  if (temp.ne.dissocstate(il,jt)) then
                     dissocstate(il,jt)=temp
                     times(ev(il,jt,2))=get_evtime(dissocstate(il,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                     call update(event,revmap,ev(il,jt,2),times(ev(il,jt,2)),times,totev)
                  endif
               else                                                     					   		! UPLEFT is Founder
                  temp=dissocstate(il,jt)                                                      
                  if (dissocstate(il,jt).lt.5) then                                            		! Assign new dissocstates
                     if (state(il,jl).eq.1) then
                        temp=5
                     elseif (state(il,jl).eq.-1) then
                        temp=6
                     else
                        write(6,*) 'empty founder neighbor, LEFT'
                        stop
                     endif
                  elseif (dissocstate(il,jt).ge.5) then
                     if ( ((state(i-2,j+1).ne.0).and.(state(i-2,j).ne.0)).or.
     @                    ((state(i,j+2).ne.0).and.(state(i-1,j+2).ne.0)) ) then
                        temp = 8
                     else
                        write (6,*) 'dissocstate will stay the same for (il,jt)'
                     endif
                  endif
                  if (temp.ne.dissocstate(il,jt)) then
                     if (dissocstate(il,jt).ge.5) then
                        dissocstate(il,jt)=temp
                        times(ev(il,jt,2))=get_evtime(dissocstate(il,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                        call update(event,revmap,ev(il,jt,2),times(ev(il,jt,2)),times,totev)
                     else
                        dissocstate(il,jt)=temp
                        if (state(il,jl).ne.0) then
                           totev=totev+1
                           nev(il,jt)=nev(il,jt)+1
                           if (nrecyc.eq.0) then
                              xloc(totev)=il
                              yloc(totev)=jt
                              ev(il,jt,2)=totev
                           else
                              ev(il,jt,2)=recyc(1)
                              xloc(recyc(1))=il
                              yloc(recyc(1))=jt
                              if (nrecyc.gt.1) then
                                 recyc(1)=recyc(nrecyc)
                                 call hpsort(nrecyc-1,recyc)
                              endif
                              nrecyc=nrecyc-1
                           endif
                           times(ev(il,jt,2))=get_evtime(dissocstate(il,jt),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd)
                           event(totev)=ev(il,jt,2)
                           revmap(ev(il,jt,2))=totev
                           call build_min_heap(event,revmap,times,totev)
                        endif
                     endif
                  endif
               endif
c not possible to have dstate 3/4->8 here               
               temp=dissocstate(il,jl)							                               		! do dstate for left
               if (dissocstate(il,jl).eq.3) then
                  temp = 5
               elseif (dissocstate(il,jl).eq.4) then
                  temp = 6
               elseif (dissocstate(il,jl).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=2 for adding into 8, left'
                  stop
               endif
               if (temp.ne.dissocstate(il,jl)) then
                  dissocstate(il,jl)=temp
                  times(ev(il,jl,2))=get_evtime(dissocstate(il,jl),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(il,jl,2),times(ev(il,jl,2)),times,totev)
               endif
c not possible to have dstate 2->8 here                              
               temp=dissocstate(it,jt)							                               		! do dstate for upper middle
               if ( (dissocstate(it,jt).eq.2).or.(dissocstate(it,jt).ge.5) ) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=3,4 for adding into 8, upper middle'
                  stop
               endif
               if (temp.ne.dissocstate(it,jt)) then
                  dissocstate(it,jt)=temp
                  times(ev(it,jt,2))=get_evtime(dissocstate(it,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(it,jt,2),times(ev(it,jt,2)),times,totev)
               endif
c
c new logic below captures case where dstate2->8, need to dbl chk and insert elsewhere                                                         
               temp=dissocstate(ir,jt)							                               		! do dstate for upper right
               if (dissocstate(ir,jt).eq.2) then
                  if ( (state(i+2,j).ne.0).and.(state(i+2,j+1).ne.0) ) then
                     temp=8
                  else
                     if (state(ir,jr).eq.1) then
                        temp=5
                     elseif (state(ir,jr).eq.-1) then
                        temp=6
                     else
                        write(6,*) 'empty UPPER RIGHT neighbor??'
                        stop                  
                     endif
                  endif
               elseif (dissocstate(ir,jt).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=3,4 for adding into 8, upper right'
                  stop
               endif
               if (temp.ne.dissocstate(ir,jt)) then
                  dissocstate(ir,jt)=temp
                  times(ev(ir,jt,2))=get_evtime(dissocstate(ir,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(ir,jt,2),times(ev(ir,jt,2)),times,totev)
               endif
c not possible to have dstate 3/4->8 here                              
               temp=dissocstate(ir,jr)							                               		! do dstate for right
               if (dissocstate(ir,jr).eq.3) then
                  temp=5
               elseif (dissocstate(ir,jr).eq.4) then
                  temp = 6
               elseif (dissocstate(ir,jr).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=2 for adding into 8, right'
                  stop
               endif
               if (temp.ne.dissocstate(ir,jr)) then
                  dissocstate(ir,jr)=temp
                  times(ev(ir,jr,2))=get_evtime(dissocstate(ir,jr),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(ir,jr,2),times(ev(ir,jr,2)),times,totev)
               endif
            elseif ( (dep(it,jt).eq.1).or.(dep(it,jt).eq.0) ) then		   							! UpMID is Special/Founder
c               write(6,*) 'Uppermiddle is special'
               if (qspec) then
                  write(6,*) 'two special subunits?, LOWMID'
                  stop
               endif
               qspec=.true.
               dep(i,j)=1                                                                      		! Assign new dependencies
               if (dep(il,jl).eq.1) then
                  dep(il,jl)=6
               else
                  write (6,*) 'dep not right, possible loop? dep(il,jl)= ',dep(il,jl)
                  stop
               endif
               if (dep(ir,jr).eq.1) then
                  dep(ir,jr)=5
               else
                  write (6,*) 'dep not right, possible loop? dep(ir,jr)= ',dep(ir,jr)
                  stop
               endif
               if (dep(it,jt).ne.0) then                                                       		! UpMID is not founder
                  temp=dissocstate(it,jt)
                  if (dissocstate(it,jt).ge.5) then
                     temp = 8
                  elseif ( (dissocstate(it,jt).eq.3).or.(dissocstate(it,jt).eq.4) ) then
c                     write (6,*) 'dissocstate will stay the same for (it,jt)'
                  else
                     write (6,*) 'bad dstate=2 for adding into 8, special UpMID'
                     stop
                  endif
                  if (temp.ne.dissocstate(it,jt)) then
                     dissocstate(it,jt)=temp
                     times(ev(it,jt,2))=get_evtime(dissocstate(it,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                     call update(event,revmap,ev(it,jt,2),times(ev(it,jt,2)),times,totev)
                  endif
               else						                                                       		! UpMID is Founder
                  temp=dissocstate(it,jt)
                  if (dissocstate(it,jt).lt.8) then
                     temp=8
                  else
c                     write (6,*) 'dissocstate will stay the same for (it,jt)'
                  endif
                  if (temp.ne.dissocstate(it,jt)) then 
                     if (dissocstate(it,jt).ge.5) then
                        dissocstate(it,jt)=temp
                        times(ev(it,jt,2))=get_evtime(dissocstate(it,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                        call update(event,revmap,ev(it,jt,2),times(ev(it,jt,2)),times,totev)
                     else
                        dissocstate(it,jt)=temp
                        if (state(it,jt).ne.0) then
                           totev=totev+1
                           nev(it,jt)=nev(it,jt)+1
                           if (nrecyc.eq.0) then
                              xloc(totev)=it
                              yloc(totev)=jt
                              ev(it,jt,2)=totev
                           else
                              ev(it,jt,3)=recyc(1)
                              xloc(recyc(1))=it
                              yloc(recyc(1))=jt
                              if (nrecyc.gt.1) then
                                 recyc(1)=recyc(nrecyc)
                                 call hpsort(nrecyc-1,recyc)
                              endif
                              nrecyc=nrecyc-1
                           endif
                           times(ev(it,jt,2))=get_evtime(dissocstate(it,jt),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd)
                           event(totev)=ev(it,jt,2)
                           revmap(ev(it,jt,2))=totev
                           call build_min_heap(event,revmap,times,totev)
                        endif
                     endif
                  endif
               endif
c not possible to have dstate 3/4->8 here                                             
               temp=dissocstate(il,jl)							                               		! do dstate for left
               if (dissocstate(il,jl).eq.3) then
                  temp = 5
               elseif (dissocstate(il,jl).eq.4) then
                  temp = 6
               elseif (dissocstate(il,jl).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=2 for adding into 8, left'
                  stop
               endif
               if (temp.ne.dissocstate(il,jl)) then
                  dissocstate(il,jl)=temp
                  times(ev(il,jl,2))=get_evtime(dissocstate(il,jl),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(il,jl,2),times(ev(il,jl,2)),times,totev)
               endif
c new logic below captures case where dstate 2->8, need to dbl chk and insert elsewhere                                                                        
               temp=dissocstate(il,jt)							                               		! do dstate for upper left
               if (dissocstate(il,jt).eq.2) then
                  if ( (state(i-2,j).ne.0).and.(state(i-2,j+1).ne.0) ) then
                     temp=8
                  else
                     if (state(il,jl).eq.1) then
                        temp=5
                     elseif (state(il,jl).eq.-1) then
                        temp=6
                     else
                        write(6,*) 'empty LEFT neighbor??'
                        stop                  
                     endif
                  endif
               elseif (dissocstate(il,jt).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=3,4 for adding into 8, upper left'
                  stop
               endif
               if (temp.ne.dissocstate(il,jt)) then
                  dissocstate(il,jt)=temp
                  times(ev(il,jt,2))=get_evtime(dissocstate(il,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(il,jt,2),times(ev(il,jt,2)),times,totev)
               endif
c new logic below captures case where dstate 2->8, need to dbl chk and insert elsewhere                                                                                       
               temp=dissocstate(ir,jt)							                               		! do dstate for upper right
               if (dissocstate(ir,jt).eq.2) then
                  if ( (state(i+2,j).ne.0).and.(state(i+2,j+1).ne.0) ) then
                     temp=8
                  else
                     if (state(ir,jr).eq.1) then
                        temp=5
                     elseif (state(ir,jr).eq.-1) then
                        temp=6
                     else
                        write(6,*) 'empty RIGHT neighbor??'
                        stop                  
                     endif
                  endif
               elseif (dissocstate(ir,jt).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=3,4 for adding into 8, upper right'
                  stop
               endif
               if (temp.ne.dissocstate(ir,jt)) then
                  dissocstate(ir,jt)=temp
                  times(ev(ir,jt,2))=get_evtime(dissocstate(ir,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(ir,jt,2),times(ev(ir,jt,2)),times,totev)
               endif
c not possible to have dstate 3/4->8 here                                                            
               temp=dissocstate(ir,jr)							                               		! do dstate for right
               if (dissocstate(ir,jr).eq.3) then
                  temp=5
               elseif (dissocstate(ir,jr).eq.4) then
                  temp = 6
               elseif (dissocstate(ir,jr).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=2 for adding into 8, right'
                  stop
               endif
               if (temp.ne.dissocstate(ir,jr)) then
                  dissocstate(ir,jr)=temp
                  times(ev(ir,jr,2))=get_evtime(dissocstate(ir,jr),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(ir,jr,2),times(ev(ir,jr,2)),times,totev)
               endif
            elseif ((dep(ir,jt).eq.1).or.(dep(ir,jt).eq.4).or.(dep(ir,jt).eq.6).or.(dep(ir,jt).eq.0)) then			! UpRIGHT is Special/Founder
c               write(6,*) 'Upperright is special'
               if (qspec) then
                  write(6,*) 'two special subunits?, LOWRIGHT'
                  stop
               endif
               qspec=.true.
               dep(i,j)=6                                                                      		! Assign new dependencies
               if (dep(il,jl).eq.1) then
                  dep(il,jl)=6
               else
                  write (6,*) 'dep not right, possible loop? dep(il,jl)= ',dep(il,jl)
                  stop
               endif
               if (dep(ir,jt).ne.0) then                                                       		! UpRIGHT is not founder
                  temp=dissocstate(ir,jt)   
                  if (dissocstate(ir,jt).ge.5) then                                            		! Assign new dissocstate
                     if ( ((state(i+2,j+1).ne.0).and.(state(i+2,j).ne.0)).or.
     @                    ((state(i,j+2).ne.0).and.(state(i+1,j+2).ne.0)) ) then
                        temp = 8
                     else
c                        write (6,*) 'dissocstate will stay the same for (ir,jt)'
                     endif
                  else
c                     write (6,*) 'dissocstate will stay the same for (ir,jt)'
                  endif
                  if (temp.ne.dissocstate(ir,jt)) then
                     dissocstate(ir,jt)=temp
                     times(ev(ir,jt,2))=get_evtime(dissocstate(ir,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                     call update(event,revmap,ev(ir,jt,2),times(ev(ir,jt,2)),times,totev)
                  endif
               else						                                                       		! UpRIGHT is Founder
                  temp=dissocstate(ir,jt)
                  if (dissocstate(ir,jt).lt.5) then                                            		! Assign new dissocstate
                     if (state(ir,jr).eq.1) then
                        temp=5
                     elseif (state(ir,jr).eq.-1) then
                        temp=6
                     else
                        write(6,*) 'empty founder neighbor?? RIGHT'
                        stop
                     endif
                  elseif (dissocstate(ir,jt).ge.5) then
                     if ( ((state(i+2,j+1).ne.0).and.(state(i+2,j).ne.0)).or.
     @                    ((state(i,j+2).ne.0).and.(state(i+1,j+2).ne.0)) ) then
                        temp=8
                     else
c                        write (6,*) 'dissocstate will stay the same for (ir,jt)'
                     endif
                  endif
                  if (temp.ne.dissocstate(ir,jt)) then 
                     if (dissocstate(ir,jt).ge.5) then
                        dissocstate(ir,jt)=temp
                        times(ev(ir,jt,2))=get_evtime(dissocstate(ir,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                        call update(event,revmap,ev(ir,jt,2),times(ev(ir,jt,2)),times,totev)
                     else
                        dissocstate(ir,jt)=temp
                        if (state(ir,jt).ne.0) then
                           totev=totev+1
                           nev(ir,jt)=nev(ir,jt)+1
                           if (nrecyc.eq.0) then
                              xloc(totev)=ir
                              yloc(totev)=jt
                              ev(ir,jt,2)=totev
                           else
                              ev(ir,jt,2)=recyc(1)
                              xloc(recyc(1))=ir
                              yloc(recyc(1))=jt
                              if (nrecyc.gt.1) then
                                 recyc(1)=recyc(nrecyc)
                                 call hpsort(nrecyc-1,recyc)
                              endif
                              nrecyc=nrecyc-1
                           endif
                           times(ev(ir,jt,2))=get_evtime(dissocstate(ir,jt),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd)
                           event(totev)=ev(ir,jt,2)
                           revmap(ev(ir,jt,2))=totev
                           call build_min_heap(event,revmap,times,totev)
                        endif
                     endif
                  endif
               endif
c not possible to have dstate 3/4->8 here                                             
               temp=dissocstate(il,jl)							                               		! do dstate for left
               if (dissocstate(il,jl).eq.3) then
                  temp = 5
               elseif (dissocstate(il,jl).eq.4) then
                  temp = 6
               elseif (dissocstate(il,jl).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=2 for adding into 8, left'
                  stop
               endif
               if (temp.ne.dissocstate(il,jl)) then
                  dissocstate(il,jl)=temp
                  times(ev(il,jl,2))=get_evtime(dissocstate(il,jl),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(il,jl,2),times(ev(il,jl,2)),times,totev)
               endif
c new logic below captures case where dstate 2->8, need to dbl chk and insert elsewhere                                                                                       
               temp=dissocstate(il,jt)							                               		! do dstate for upper left
               if (dissocstate(il,jt).eq.2) then
                  if ( (state(i-2,j).ne.0).and.(state(i-2,j+1).ne.0) ) then
                     temp=8
                  else
                     if (state(il,jl).eq.1) then
                        temp=5
                     elseif (state(il,jl).eq.-1) then
                        temp=6
                     else
                        write(6,*) 'empty LEFT neighbor??'
                        stop                  
                     endif
                  endif
               elseif (dissocstate(il,jt).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=3,4 for adding into 8, upper left'
                  stop
               endif
               if (temp.ne.dissocstate(il,jt)) then
                  dissocstate(il,jt)=temp
                  times(ev(il,jt,2))=get_evtime(dissocstate(il,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(il,jt,2),times(ev(il,jt,2)),times,totev)
               endif
               temp=dissocstate(it,jt)							                               		! do dstate for upper middle
               if ( (dissocstate(it,jt).eq.2).or.(dissocstate(it,jt).ge.5) ) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=3,4 for adding into 8, upper middle'
                  stop
               endif
               if (temp.ne.dissocstate(it,jt)) then
                  dissocstate(it,jt)=temp
                  times(ev(it,jt,2))=get_evtime(dissocstate(it,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(it,jt,2),times(ev(it,jt,2)),times,totev)
               endif
c not possible to have dstate 3/4->8 here                                                            
               temp=dissocstate(ir,jr)							                               		! do dstate for right
               if (dissocstate(ir,jr).eq.3) then
                  temp=5
               elseif (dissocstate(ir,jr).eq.4) then
                  temp = 6
               elseif (dissocstate(ir,jr).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=2 for adding into 8, right'
                  stop
               endif
               if (temp.ne.dissocstate(ir,jr)) then
                  dissocstate(ir,jr)=temp
                  times(ev(ir,jr,2))=get_evtime(dissocstate(ir,jr),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(ir,jr,2),times(ev(ir,jr,2)),times,totev)
               endif
            elseif ( (dep(ir,jr).eq.0).or.(dep(ir,jr).eq.2).or.(dep(ir,jr).eq.4).or.(dep(ir,jr).eq.7) ) then		!Right is special/founder
c               write(6,*) 'Right is special'
               if (qspec) then
                  write(6,*) 'two special subunits?, Right'
                  stop
               endif
               qspec=.true.
               dep(i,j)=4                                                                      		! Assign new dependencies
               if (dep(il,jl).eq.1) then
                  dep(il,jl)=4
               else
                  write (6,*) 'dep not right, possible loop? dep(il,jl)= ',dep(il,jl)
                  stop
               endif
               if (dep(il,jt).eq.4) then
                  dep(il,jt)=7
               else
                  write (6,*) 'dep not right, possible loop? dep(il,jt)= ',dep(il,jt)
                  stop
               endif
               if (dep(it,jt).eq.4) then
                  dep(it,jt)=7
               else
                  write (6,*) 'dep not right, possible loop? dep(it,jt)= ',dep(it,jt)
                  stop
               endif
               if (dep(ir,jr).ne.0) then                                                       		! RIGHT is not founder
                  temp=dissocstate(ir,jr)   
                  if (dissocstate(ir,jr).ge.5) then                                            		! Assign new dissocstate
c change below to test explicitly for both corners
                     if ( (state(i+2,j+1).ne.0).and.(state(i+2,j).ne.0) ) then
                        temp = 8
                     else
c                        write (6,*) 'dissocstate will stay the same for (ir,jr)'
                     endif
                  else
c                     write (6,*) 'dissocstate will stay the same for (ir,jr)'
                  endif
                  if (temp.ne.dissocstate(ir,jr)) then
                     dissocstate(ir,jr)=temp
                     times(ev(ir,jr,2))=get_evtime(dissocstate(ir,jr),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                     call update(event,revmap,ev(ir,jr,2),times(ev(ir,jr,2)),times,totev)
                  endif
               else						                                                       		! RIGHT is Founder
                  temp=dissocstate(ir,jr)
                  if (dissocstate(ir,jr).lt.5) then                                            		! Assign new dissocstate
                     if (state(ir,jr).eq.1) then
                        temp=5
                     elseif (state(ir,jr).eq.-1) then
                        temp=6
                     else
                        write(6,*) 'empty founder?? RIGHT'
                        stop
                     endif
                  elseif (dissocstate(ir,jr).ge.5) then
                     if ( (state(i+2,j+1).ne.0).and.(state(i+2,j).ne.0) ) then
                        temp=8
                     else
c                        write (6,*) 'dissocstate will stay the same for (ir,jr)'
                     endif
                  endif
                  if (temp.ne.dissocstate(ir,jr)) then 
                     if (dissocstate(ir,jr).ge.5) then
                        dissocstate(ir,jr)=temp
                        times(ev(ir,jr,2))=get_evtime(dissocstate(ir,jr),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                        call update(event,revmap,ev(ir,jr,2),times(ev(ir,jr,2)),times,totev)
                     else
                        dissocstate(ir,jr)=temp
                        if (state(ir,jr).ne.0) then
                           totev=totev+1
                           nev(ir,jr)=nev(ir,jr)+1
                           if (nrecyc.eq.0) then
                              xloc(totev)=ir
                              yloc(totev)=jr
                              ev(ir,jr,2)=totev
                           else
                              ev(ir,jr,2)=recyc(1)
                              xloc(recyc(1))=ir
                              yloc(recyc(1))=jr
                              if (nrecyc.gt.1) then
                                 recyc(1)=recyc(nrecyc)
                                 call hpsort(nrecyc-1,recyc)
                              endif
                              nrecyc=nrecyc-1
                           endif
                           times(ev(ir,jr,2))=get_evtime(dissocstate(ir,jr),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd)
                           event(totev)=ev(ir,jr,2)
                           revmap(ev(ir,jr,2))=totev
                           call build_min_heap(event,revmap,times,totev)
                        endif
                     endif
                  endif
               endif
c not possible to have dstate 3/4->8                              
               temp=dissocstate(il,jl)							                               		! do dstate for left
               if (dissocstate(il,jl).eq.3) then
                  temp = 5
               elseif (dissocstate(il,jl).eq.4) then
                  temp = 6
               elseif (dissocstate(il,jl).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=2 for adding into 8, left'
                  stop
               endif
               if (temp.ne.dissocstate(il,jl)) then
                  dissocstate(il,jl)=temp
                  times(ev(il,jl,2))=get_evtime(dissocstate(il,jl),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(il,jl,2),times(ev(il,jl,2)),times,totev)
               endif
c new logic below captures case where dstate 2->8, need to dbl chk and insert elsewhere                                                                                       
               temp=dissocstate(il,jt)							                               		! do dstate for upper left
               if (dissocstate(il,jt).eq.2) then
                  if ( (state(i-2,j).ne.0).and.(state(i-2,j+1).ne.0) ) then
                     temp=8
                  else
                     if (state(il,jl).eq.1) then
                        temp=5
                     elseif (state(il,jl).eq.-1) then
                        temp=6
                     else
                        write(6,*) 'empty LEFT neighbor??'
                        stop                  
                     endif
                  endif
               elseif (dissocstate(il,jt).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=3,4 for adding into 8, upper left'
                  stop
               endif
               if (temp.ne.dissocstate(il,jt)) then
                  dissocstate(il,jt)=temp
                  times(ev(il,jt,2))=get_evtime(dissocstate(il,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(il,jt,2),times(ev(il,jt,2)),times,totev)
               endif
               temp=dissocstate(it,jt)							                               		! do dstate for upper middle
               if ( (dissocstate(it,jt).eq.2).or.(dissocstate(it,jt).ge.5) ) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=3,4 for adding into 8, upper middle'
                  stop
               endif
               if (temp.ne.dissocstate(it,jt)) then
                  dissocstate(it,jt)=temp
                  times(ev(it,jt,2))=get_evtime(dissocstate(it,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(it,jt,2),times(ev(it,jt,2)),times,totev)
               endif
c
c new logic below captures case where dstate 3/4->8, need to dbl chk and insert elsewhere
               temp=dissocstate(ir,jt)							                               		! do dstate for upper right
               if ( (dissocstate(ir,jt).eq.3).or.(dissocstate(ir,jt).eq.4) ) then
                  if ( (state(i,j+2).ne.0).AND.(state(i+1,j+2).ne.0) ) then
                     temp=8
                  else
                     if (dissocstate(ir,jt).eq.3) then
                        temp=5
                     elseif (dissocstate(ir,jt).eq.4) then
                        temp=6
                     endif
                  endif
               elseif (dissocstate(ir,jt).ge.5) then
                  temp = 8
               else
                  write(6,*) 'bad dstate=2 for adding into 8, upper right'
                  stop
               endif
               if (temp.ne.dissocstate(ir,jt)) then
                  dissocstate(ir,jt)=temp
                  times(ev(ir,jt,2))=get_evtime(dissocstate(ir,jt),k_on,conc,GDP,K_lat,K_long,K_both,k_hyd)
                  call update(event,revmap,ev(ir,jt,2),times(ev(ir,jt,2)),times,totev)
               endif
c going to test to see if other subunits outside of region have proper dependencies
               if ((state(i-2,j).ne.0).and.(state(i-2,j-1).ne.0)) then
                  if ((dep(i-2,j+1).ne.7).and.(dep(i-2,j).ne.4)) then
                     write(6,*) 'STOP! Dependencies need to be changed for ',i-2,j+1,' and ',i-2,j
                     stop
                  endif
               endif
            endif

       return
       end
c need to check that ALL necessary dependencies get changed

       subroutine EIemptyleft(i,j,dep,dissocstate,addstate,state,times,event,revmap,ev,totev,nev,
     @                        nrecyc,recyc,xloc,yloc,k_on,conc,GDP,K_lat,K_long,K_both,K_hyd,
     @                        K_thr_long,K_thr_lat,K_all,seammult,k_ne)

c i/o variables
       integer i,j,dep(13,*),dissocstate(13,*),addstate(13,*),state(13,*)
       integer event(*),revmap(*),ev(13,2000,*)
       integer totev,nev(13,*),nrecyc,recyc(*),xloc(*),yloc(*)
       double precision times(*)
       double precision k_on,conc,GDP,K_lat,K_long,K_both,K_hyd
       double precision K_thr_long,K_thr_lat,K_all,k_ne
       double precision seammult(13,*)
       
c local variables
       integer ir,jr,it,jt,ib,jb,tempv1,temph1,temph2,temph3,tempv2,ll
       
            ir=i+1
            jr=j
            it=i
            jt=j+1
            ib=i
            jb=j-1
            
            tempv1=dissocstate(it,jt)
            temph1=dissocstate(ir,jt)
            temph2=dissocstate(ir,jr)
            temph3=dissocstate(ir,jb)
            tempv2=dissocstate(ib,jb)

c            write(6,*) 'Starting Elemptyleft'
            
c            write(6,*) 'Bottom/bottom right should always be special unless special case'
            if (((dep(ir,jb).eq.7).or.(dep(ir,jb).eq.8)).or.((dep(ib,jb).eq.7).or.
     @         (dep(ib,jb).eq.8))) then
               
c               write(6,*) 'deps are only checked/changed for ',it,jt,', ',ir,jt,'and ',ir,jr
               dep(i,j)=7                                                                      		!Assign new dependencies
               dep(it,jt)=7
               if (dep(ir,jt).eq.7) then
c                  write(6,*) 'dep stays 7 for ',ir,jt
               else
                  dep(ir,jt)=8
               endif
               if (dep(ir,jr).eq.7) then
c                  write(6,*) 'dep stays 7 for ',ir,jr
               else
                  dep(ir,jr)=8
               endif
               
               if (dissocstate(it,jt).eq.2) then													!Top subunit
c                  write(6,*) 'dstate 2 -> 5 for ',it,jt
                  tempv1=5
               elseif (dissocstate(it,jt).eq.5) then
c                  write(6,*) 'dstate 5 -> 10 for ',it,jt
                  tempv1=10
               elseif (dissocstate(it,jt).eq.6) then
c                  write(6,*) 'dstate 6 -> 11, single GDP for ',it,jt
                  tempv1=11
               elseif ((dissocstate(it,jt).eq.12).or.(dissocstate(it,jt).eq.13)) then
c                  write(6,*) 'dstate 12/13 -> 8 for ',it,jt
                  tempv1=8
               else
                  write(6,*) 'bad dstate for ',it,jt,': ',dissocstate(it,jt)
                  stop
               endif
               
               if ((dissocstate(ir,jt).eq.3).or.(dissocstate(ir,jt).eq.4)) then						!Top right subunit
c                  write(6,*) 'check to see if top right subunit is at seam'
                  if (jt.eq.13) then
c                     write(6,*) 'top right subunit is at seam'
                     if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0).and.
     @                  (state(1,jt).ne.0).and.(state(1,jt-1).ne.0).and.(state(1,jt-2).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',ir,jt
                        temph1=8
                     elseif ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0)) then
                        if (dissocstate(ir,jt).eq.3) then
                           if (state(ir,jt).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',ir,jt
                              temph1=10
                           elseif (state(ir,jt).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',ir,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',ir,jt
                              stop
                           endif
                        elseif (dissocstate(ir,jt).eq.4) then
                           if (state(ir,jt).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',ir,jt
                              temph1=11
                           elseif (state(ir,jt).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',ir,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',ir,jt
                              stop
                           endif
                        endif
                     else
                        if (dissocstate(ir,jt).eq.3) then
                           temph1=5
                        elseif (dissocstate(ir,jt).eq.4) then
                           temph1=6
                        endif
                     endif
                  else
c                     write(6,*) 'top right subunit is not at seam'
                     if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0).and.
     @                  (state(ir+1,jt+1).ne.0).and.(state(ir+1,jt).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',ir,jt
                        temph1=8
                     elseif ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0)) then
                        if (dissocstate(ir,jt).eq.3) then
                           if (state(ir,jt).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',ir,jt
                              temph1=10
                           elseif (state(ir,jt).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',ir,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',ir,jt
                              stop
                           endif
                        elseif (dissocstate(ir,jt).eq.4) then
                           if (state(ir,jt).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',ir,jt
                              temph1=11
                           elseif (state(ir,jt).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',ir,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',ir,jt
                              stop
                           endif
                        endif
                     else
                        if (dissocstate(ir,jt).eq.3) then
                           temph1=5
                        elseif (dissocstate(ir,jt).eq.4) then
                           temph1=6
                        endif
                     endif
                  endif
               elseif ((dissocstate(ir,jt).eq.5).or.(dissocstate(ir,jt).eq.6)) then
                  if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0)) then
c                     write(6,*) 'dstate 5/6 -> 8 for ',ir,jt
                     temph1=8
                  else
                     if (dissocstate(ir,jt).eq.5) then
c                        write(6,*) 'dstate 5 -> 12 for ',ir,jt
                        temph1=12
                     elseif (dissocstate(ir,jt).eq.6) then
c                        write(6,*) 'dstate 6 -> 13 for ',ir,jt
                        temph1=13
                     endif
                  endif
               elseif ((dissocstate(ir,jt).eq.10).or.(dissocstate(ir,jt).eq.11)) then
c                  write(6,*) 'dstate 10/11 -> 8 for ',ir,jt
                  temph1=8
               elseif (dissocstate(ir,jt).eq.8) then
c                  write(6,*) 'dstate=8, do nothing'
               else
                  write(6,*) 'bad dstate for ',ir,jt,': ',dissocstate(ir,jt)
                  stop
               endif
               
               if ((dissocstate(ir,jr).eq.3).or.(dissocstate(ir,jr).eq.4)) then						!Right subunit
c                  write(6,*) 'check to see if right subunit is at seam'
                  if (jr.eq.13) then
c                     write(6,*) 'right subunit is at seam'
                     if ((state(1,jr).ne.0).and.(state(1,jr-1).ne.0).and.(state(1,jr-2).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',ir,jr
                        temph2=8
                     else
                        if (dissocstate(ir,jr).eq.3) then
                           if (state(ir,jr).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',ir,jr
                              temph2=10
                           elseif (state(ir,jr).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',ir,jr
                              temph2=11
                           else
                              write(6,*) 'bad state for ',ir,jr
                              stop
                           endif
                        elseif (dissocstate(ir,jr).eq.4) then
                           if (state(ir,jr).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',ir,jr
                              temph2=11
                           elseif (state(ir,jr).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',ir,jr
                              temph2=11
                           else
                              write(6,*) 'bad state for ',ir,jr
                              stop
                           endif
                        endif
                     endif
                  else
c                     write(6,*) 'right subunit is not at seam'
                     if ((state(ir+1,jr+1).ne.0).and.(state(ir+1,jr).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',ir,jr
                        temph2=8
                     else
                        if (dissocstate(ir,jr).eq.3) then
                           if (state(ir,jr).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',ir,jr
                              temph2=10
                           elseif (state(ir,jr).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',ir,jr
                              temph2=11
                           else
                              write(6,*) 'bad state for ',ir,jr
                              stop
                           endif
                        elseif (dissocstate(ir,jr).eq.4) then
                           if (state(ir,jr).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',ir,jr
                              temph2=11
                           elseif (state(ir,jr).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',ir,jr
                              temph2=11
                           else
                              write(6,*) 'bad state for ',ir,jr
                              stop
                           endif
                        endif
                     endif
                  endif
               elseif ((dissocstate(ir,jr).eq.5).or.(dissocstate(ir,jr).eq.6).or.
     @                (dissocstate(ir,jr).eq.10).or.(dissocstate(ir,jr).eq.11)) then
c                  write(6,*) 'dstate 5/6/10/11 -> 8 for ',ir,jr
                  temph2=8
               else
                  write(6,*) 'bad dstate for ',ir,jr,': ',dissocstate(ir,jr)
                  stop
               endif
               
               if (dissocstate(ir,jb).eq.2) then													!Bottom right subunit
                  
c                  write(6,*) 'for dstate=2 may need to change dep for ',ir,jb
                  if (dep(ir,jb).eq.3) then
                     dep(ir,jb)=5
                  else
                     write(6,*) 'bad dep/special case for ',ir,jb
                     stop
                  endif
                  
c                  write(6,*) 'check if bottom right subunit is on seam'
                  if (jb.eq.13) then
c                     write(6,*) 'bottom right subunit is on seam'
                     if ((state(1,jb).ne.0).and.(state(1,jb-1).ne.0).and.(state(1,jb-2).ne.0)) then
                        if (state(ir,jb).eq.1) then
c                           write(6,*) 'dstate 2 -> 12 for ',ir,jb
                           temph3=12
                        elseif (state(ir,jb).eq.-1) then
c                           write(6,*) 'dstate 2 -> 13 for ',ir,jb
                           temph3=13
                        else
                           write(6,*) 'bad state for ',ir,jb
                           stop
                        endif
                     else
                        if (state(ir,jb).eq.1) then
c                           write(6,*) 'dstate 2 -> 5 for ',ir,jb
                           temph3=5
                        elseif (state(ir,jb).eq.-1) then
c                           write(6,*) 'dstate 2 -> 6 for ',ir,jb
                           temph3=6
                        else
                           write(6,*) 'bad state for ',ir,jb
                           stop
                        endif
                     endif
                  else
c                     write(6,*) 'bottom right subunit is not on seam'
                     if ((state(ir+1,jb+1).ne.0).and.(state(ir+1,jb).ne.0)) then
                        if (state(ir,jb).eq.1) then
c                           write(6,*) 'dstate 2 -> 12 for ',ir,jb
                           temph3=12
                        elseif (state(ir,jb).eq.-1) then
c                           write(6,*) 'dstate 2 -> 13 for ',ir,jb
                           temph3=13
                        else
                           write(6,*) 'bad state for ',ir,jb
                           stop
                        endif
                     else
                        if (state(ir,jb).eq.1) then
c                           write(6,*) 'dstate 2 -> 5 for ',ir,jb
                           temph3=5
                        elseif (state(ir,jb).eq.-1) then
c                           write(6,*) 'dstate 2 -> 6 for ',ir,jb
                           temph3=6
                        else
                           write(6,*) 'bad state for ',ir,jb
                           stop
                        endif
                     endif
                  endif
               elseif ((dissocstate(ir,jb).eq.5).or.(dissocstate(ir,jb).eq.6)) then
c                  write(6,*) 'check to see if bottom right subunit is at seam'
                  if (jb.eq.13) then
c                     write(6,*) 'bottom right subunit is at seam'
                     if (((state(ir-1,jb-1).eq.0).and.(state(1,jb).eq.0)).and.
     @                  ((state(ir,jb-1).ne.0).and.(state(1,jb-1).ne.0).and.
     @                  (state(1,jb-2).ne.0))) then
c                        write(6,*) 'dstate stays 5/6 for ',ir,jb
                     elseif ((state(1,jb).ne.0).and.(state(1,jb-1).ne.0).and.
     @                      (state(1,jb-2).ne.0)) then
c                        write(6,*) 'dstate 5/6 -> 8 for ',ir,jb
                        temph3=8
                     else
                        if (dissocstate(ir,jb).eq.5) then
                           if (state(ir,jb).eq.1) then
c                              write(6,*) 'dstate 5 -> 10 for ',ir,jb
                              temph3=10
                           elseif (state(ir,jb).eq.-1) then
c                              write(6,*) 'dstate 5 -> 11, single GDP for ',ir,jb
                              temph3=11
                           else
                              write(6,*) 'bad state for ',ir,jb
                              stop
                           endif
                        elseif (dissocstate(ir,jb).eq.6) then
                           if (state(ir,jb).eq.1) then
c                              write(6,*) 'dstate 6 -> 11, single GDP for ',ir,jb
                              temph3=11
                           elseif (state(ir,jb).eq.-1) then
c                              write(6,*) 'dstate 6 -> 11, double GDP for ',ir,jb
                              temph3=11
                           else
                              write(6,*) 'bad state for ',ir,jb
                              stop
                           endif
                        endif
                     endif
                  else
c                     write(6,*) 'bottom right subunit is not at seam'
                     if (((state(ir-1,jb-1).eq.0).and.(state(ir+1,jb+1).eq.0)).and.
     @                  ((state(ir,jb-1).ne.0).and.(state(ir+1,jb-1).ne.0).and.
     @                  (state(ir+1,jb).ne.0))) then
c                        write(6,*) 'dstate stays 5/6 for ',ir,jb
                     elseif ((state(ir+1,jb+1).ne.0).and.(state(ir+1,jb).ne.0)) then
c                        write(6,*) 'dstate 5/6 -> 8 for ',ir,jb
                        temph3=8
                     else
                        if (dissocstate(ir,jb).eq.5) then
                           if (state(ir,jb).eq.1) then
c                              write(6,*) 'dstate 5 -> 10 for ',ir,jb
                              temph3=10
                           elseif (state(ir,jb).eq.-1) then
c                              write(6,*) 'dstate 5 -> 11, single GDP for ',ir,jb
                              temph3=11
                           else
                              write(6,*) 'bad state for ',ir,jb
                              stop
                           endif
                        elseif (dissocstate(ir,jb).eq.6) then
                           if (state(ir,jb).eq.1) then
c                              write(6,*) 'dstate 6 -> 11, single GDP for ',ir,jb
                              temph3=11
                           elseif (state(ir,jb).eq.-1) then
c                              write(6,*) 'dstate 6 -> 11, double GDP for ',ir,jb
                              temph3=11
                           else
                              write(6,*) 'bad state for ',ir,jb
                              stop
                           endif
                        endif
                     endif
                  endif
               elseif ((dissocstate(ir,jb).eq.10).or.(dissocstate(ir,jb).eq.11).or.
     @                (dissocstate(ir,jb).eq.12).or.(dissocstate(ir,jb).eq.13)) then
c                  write(6,*) 'dstate 10/11/12/13 -> 8 for ',ir,jb
                  temph3=8
               elseif (dissocstate(ir,jb).eq.8) then
c                  write(6,*) 'dstate stays 8 for ',ir,jb
               else
                  write(6,*) 'bad dstate for ',ir,jb
                  stop
               endif
               
               if (dissocstate(ib,jb).eq.2) then													!Bottom subunit
                  
c                  write(6,*) 'for dstate=2 may need to change dep for ',ib,jb
                  if (dep(ib,jb).eq.4) then
                     dep(ib,jb)=6
                  else
                     write(6,*) 'bad dep/special case for ',ib,jb
                     stop
                  endif
                  
c                  write(6,*) 'dstate 2 -> 5 for ',ib,jb
                  tempv2=5
               elseif ((dissocstate(ib,jb).eq.5).or.(dissocstate(ib,jb).eq.6)) then
                  if ((state(ib+1,jb-1).eq.0).and.((state(ib-1,jb).ne.0).and.
     @               (state(ib-1,jb-1).ne.0).and.(state(ib,jb-1).ne.0))) then
c                     write(6,*) 'dstate stays 5/6 for ',ib,jb
                  else
                     if (dissocstate(ib,jb).eq.5) then
c                        write(6,*) 'dstate 5 -> 10 for ',ib,jb
                        tempv2=10
                     elseif (dissocstate(ib,jb).eq.6) then
c                        write(6,*) 'dstate 6 -> 11, single GDP for ',ib,jb
                        tempv2=11
                     endif
                  endif
               elseif ((dissocstate(ib,jb).eq.12).or.(dissocstate(ib,jb).eq.13)) then
c                  write(6,*) 'dstate 12/13 -> 8 for ',ib,jb
                  tempv2=8
               else
                  write(6,*) 'bad dstate for ',ib,jb
                  stop
               endif
            elseif ((dep(ir,jb).eq.0).or.(dep(ib,jb).eq.0)) then
c               write(6,*) 'bottom 2 subunits in template, dont change'
               if (dissocstate(it,jt).eq.2) then													!Top subunit
c                  write(6,*) 'dstate 2 -> 5 for ',it,jt
                  tempv1=5
               elseif (dissocstate(it,jt).eq.5) then
c                  write(6,*) 'dstate 5 -> 10 for ',it,jt
                  tempv1=10
               elseif (dissocstate(it,jt).eq.6) then
c                  write(6,*) 'dstate 6 -> 11, single GDP for ',it,jt
                  tempv1=11
               elseif ((dissocstate(it,jt).eq.12).or.(dissocstate(it,jt).eq.13)) then
c                  write(6,*) 'dstate 12/13 -> 8 for ',it,jt
                  tempv1=8
               else
                  write(6,*) 'bad dstate for ',it,jt,': ',dissocstate(it,jt)
                  stop
               endif
               
               if ((dissocstate(ir,jt).eq.3).or.(dissocstate(ir,jt).eq.4)) then						!Top right subunit
c                  write(6,*) 'check to see if top right subunit is at seam'
                  if (jt.eq.13) then
c                     write(6,*) 'top right subunit is at seam'
                     if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0).and.
     @                  (state(1,jt).ne.0).and.(state(1,jt-1).ne.0).and.(state(1,jt-2).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',ir,jt
                        temph1=8
                     elseif ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0)) then
                        if (dissocstate(ir,jt).eq.3) then
                           if (state(ir,jt).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',ir,jt
                              temph1=10
                           elseif (state(ir,jt).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',ir,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',ir,jt
                              stop
                           endif
                        elseif (dissocstate(ir,jt).eq.4) then
                           if (state(ir,jt).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',ir,jt
                              temph1=11
                           elseif (state(ir,jt).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',ir,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',ir,jt
                              stop
                           endif
                        endif
                     else
                        if (dissocstate(ir,jt).eq.3) then
                           temph1=5
                        elseif (dissocstate(ir,jt).eq.4) then
                           temph1=6
                        endif
                     endif
                  else
c                     write(6,*) 'top right subunit is not at seam'
                     if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0).and.
     @                  (state(ir+1,jt+1).ne.0).and.(state(ir+1,jt).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',ir,jt
                        temph1=8
                     elseif ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0)) then
                        if (dissocstate(ir,jt).eq.3) then
                           if (state(ir,jt).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',ir,jt
                              temph1=10
                           elseif (state(ir,jt).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',ir,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',ir,jt
                              stop
                           endif
                        elseif (dissocstate(ir,jt).eq.4) then
                           if (state(ir,jt).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',ir,jt
                              temph1=11
                           elseif (state(ir,jt).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',ir,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',ir,jt
                              stop
                           endif
                        endif
                     else
                        if (dissocstate(ir,jt).eq.3) then
                           temph1=5
                        elseif (dissocstate(ir,jt).eq.4) then
                           temph1=6
                        endif
                     endif
                  endif
               elseif ((dissocstate(ir,jt).eq.5).or.(dissocstate(ir,jt).eq.6)) then
                  if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0)) then
c                     write(6,*) 'dstate 5/6 -> 8 for ',ir,jt
                     temph1=8
                  else
                     if (dissocstate(ir,jt).eq.5) then
c                        write(6,*) 'dstate 5 -> 12 for ',ir,jt
                        temph1=12
                     elseif (dissocstate(ir,jt).eq.6) then
c                        write(6,*) 'dstate 6 -> 13 for ',ir,jt
                        temph1=13
                     endif
                  endif
               elseif ((dissocstate(ir,jt).eq.10).or.(dissocstate(ir,jt).eq.11)) then
c                  write(6,*) 'dstate 10/11 -> 8 for ',ir,jt
                  temph1=8
               elseif (dissocstate(ir,jt).eq.8) then
c                  write(6,*) 'dstate=8, do nothing'
               else
                  write(6,*) 'bad dstate for ',ir,jt,': ',dissocstate(ir,jt)
                  stop
               endif
               
               if ((dissocstate(ir,jr).eq.3).or.(dissocstate(ir,jr).eq.4)) then						!Right subunit
c                  write(6,*) 'check to see if right subunit is at seam'
                  if (jr.eq.13) then
c                     write(6,*) 'right subunit is at seam'
                     if ((state(1,jr).ne.0).and.(state(1,jr-1).ne.0).and.(state(1,jr-2).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',ir,jr
                        temph2=8
                     else
                        if (dissocstate(ir,jr).eq.3) then
                           if (state(ir,jr).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',ir,jr
                              temph2=10
                           elseif (state(ir,jr).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',ir,jr
                              temph2=11
                           else
                              write(6,*) 'bad state for ',ir,jr
                              stop
                           endif
                        elseif (dissocstate(ir,jr).eq.4) then
                           if (state(ir,jr).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',ir,jr
                              temph2=11
                           elseif (state(ir,jr).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',ir,jr
                              temph2=11
                           else
                              write(6,*) 'bad state for ',ir,jr
                              stop
                           endif
                        endif
                     endif
                  else
c                     write(6,*) 'right subunit is not at seam'
                     if ((state(ir+1,jr+1).ne.0).and.(state(ir+1,jr).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',ir,jr
                        temph2=8
                     else
                        if (dissocstate(ir,jr).eq.3) then
                           if (state(ir,jr).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',ir,jr
                              temph2=10
                           elseif (state(ir,jr).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',ir,jr
                              temph2=11
                           else
                              write(6,*) 'bad state for ',ir,jr
                              stop
                           endif
                        elseif (dissocstate(ir,jr).eq.4) then
                           if (state(ir,jr).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',ir,jr
                              temph2=11
                           elseif (state(ir,jr).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',ir,jr
                              temph2=11
                           else
                              write(6,*) 'bad state for ',ir,jr
                              stop
                           endif
                        endif
                     endif
                  endif
               elseif ((dissocstate(ir,jr).eq.5).or.(dissocstate(ir,jr).eq.6).or.
     @                (dissocstate(ir,jr).eq.10).or.(dissocstate(ir,jr).eq.11)) then
c                  write(6,*) 'dstate 5/6/10/11 -> 8 for ',ir,jr
                  temph2=8
               else
                  write(6,*) 'bad dstate for ',ir,jr,': ',dissocstate(ir,jr)
                  stop
               endif
            else
               write(6,*) 'bad dep/special case?'
               stop
            endif
            
c Update...
         if (tempv1.ne.dissocstate(it,jt)) then
            dissocstate(it,jt)=tempv1
c            write(6,*) 'resetting dissocstate of',it,jt,'to',dissocstate(it,jt)
            times(ev(it,jt,2))=get_evtime(dissocstate(it,jt),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                            K_thr_lat,K_all,k_ne,seammult(it,jt))
            call update(event,revmap,ev(it,jt,2),times(ev(it,jt,2)),times,totev)
         endif
         
         if (temph1.ne.dissocstate(ir,jt)) then
            dissocstate(ir,jt)=temph1
c            write(6,*) 'resetting dissocstate of',ir,jt,'to',dissocstate(ir,jt)
            times(ev(ir,jt,2))=get_evtime(dissocstate(ir,jt),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                            K_thr_lat,K_all,k_ne,seammult(ir,jt))
            if (temph1.eq.11) then
               if ((state(ir,jt).eq.-1).and.(state(ir,jt-1).eq.-1)) then
c                  write(6,*) 'double GDP, recalculate times'
                  times(ev(ir,jt,2))=times(ev(ir,jt,2))*GDP
               else
c                  write(6,*) 'single GDP, do nothing'
               endif
            endif
            call update(event,revmap,ev(ir,jt,2),times(ev(ir,jt,2)),times,totev)
         endif
         
         if (temph2.ne.dissocstate(ir,jr)) then
            dissocstate(ir,jr)=temph2
c            write(6,*) 'resetting dissocstate of',ir,jr,'to',dissocstate(ir,jr)
            times(ev(ir,jr,2))=get_evtime(dissocstate(ir,jr),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                            K_thr_lat,K_all,k_ne,seammult(ir,jr))
            if (temph2.eq.11) then
               if ((state(ir,jr).eq.-1).and.(state(ir,jr-1).eq.-1)) then
c                  write(6,*) 'double GDP, recalculate times'
                  times(ev(ir,jr,2))=times(ev(ir,jr,2))*GDP
               else
c                  write(6,*) 'single GDP, do nothing'
               endif
            endif
            call update(event,revmap,ev(ir,jr,2),times(ev(ir,jr,2)),times,totev)
         endif
         
         if (temph3.ne.dissocstate(ir,jb)) then
            dissocstate(ir,jb)=temph3
c            write(6,*) 'resetting dissocstate of',ir,jb,'to',dissocstate(ir,jb)
            times(ev(ir,jb,2))=get_evtime(dissocstate(ir,jb),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                            K_thr_lat,K_all,k_ne,seammult(ir,jb))
            if (temph3.eq.11) then
               if ((state(ir,jb).eq.-1).and.(state(ir,jb-1).eq.-1)) then
c                  write(6,*) 'double GDP, recalculate times'
                  times(ev(ir,jb,2))=times(ev(ir,jb,2))*GDP
               else
c                  write(6,*) 'single GDP, do nothing'
               endif
            endif
            call update(event,revmap,ev(ir,jb,2),times(ev(ir,jb,2)),times,totev)
         endif
         
         if (tempv2.ne.dissocstate(ib,jb)) then
            dissocstate(ib,jb)=tempv2
c            write(6,*) 'resetting dissocstate of',ib,jb,'to',dissocstate(ib,jb)
            times(ev(ib,jb,2))=get_evtime(dissocstate(ib,jb),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                            K_thr_lat,K_all,k_ne,seammult(ib,jb))
            call update(event,revmap,ev(ib,jb,2),times(ev(ib,jb,2)),times,totev)
         endif

       return
       end


       subroutine EIemptyright(i,j,dep,dissocstate,addstate,state,times,event,revmap,ev,totev,nev,
     @                        nrecyc,recyc,xloc,yloc,k_on,conc,GDP,K_lat,K_long,K_both,K_hyd,
     @                        K_thr_long,K_thr_lat,K_all,seammult,k_ne)

c i/o variables
       integer i,j,dep(13,*),dissocstate(13,*),addstate(13,*),state(13,*)
       integer event(*),revmap(*),ev(13,2000,*)
       integer totev,nev(13,*),nrecyc,recyc(*),xloc(*),yloc(*)
       double precision times(*)
       double precision k_on,conc,GDP,K_lat,K_long,K_both,K_hyd
       double precision K_thr_long,K_thr_lat,K_all,k_ne
       double precision seammult(13,*)
       
c local variables
       integer il,jl,it,jt,ib,jb,tempv1,temph1,temph2,temph3,tempv2,ll
       
            il=i-1
            jl=j
            it=i
            jt=j+1
            ib=i
            jb=j-1
            
            tempv1=dissocstate(it,jt)
            temph1=dissocstate(il,jt)
            temph2=dissocstate(il,jl)
            temph3=dissocstate(il,jb)
            tempv2=dissocstate(ib,jb)

c            write(6,*) 'Starting Elemptyright'
            
c            write(6,*) 'Bottom/bottom left should always be special unless special case'
            if (((dep(il,jb).eq.7).or.(dep(il,jb).eq.8)).or.((dep(ib,jb).eq.7).or.
     @         (dep(ib,jb).eq.8))) then
               
c               write(6,*) 'deps are only checked/changed for ',it,jt,', ',il,jt,'and ',il,jl
               dep(i,j)=8                                                                      		!Assign new dependencies
               dep(it,jt)=8
               if (dep(il,jt).eq.8) then
c                  write(6,*) 'dep stays 8 for ',il,jt
               else
                  dep(il,jt)=7
               endif
               if (dep(il,jl).eq.8) then
c                  write(6,*) 'dep stays 8 for ',il,jl
               else
                  dep(il,jl)=7
               endif
               
               if (dissocstate(it,jt).eq.2) then													!Top subunit
c                  write(6,*) 'dstate 2 -> 5 for ',it,jt
                  tempv1=5
               elseif (dissocstate(it,jt).eq.5) then
c                  write(6,*) 'dstate 5 -> 10 for ',it,jt
                  tempv1=10
               elseif (dissocstate(it,jt).eq.6) then
c                  write(6,*) 'dstate 6 -> 11, single GDP for ',it,jt
                  tempv1=11
               elseif ((dissocstate(it,jt).eq.12).or.(dissocstate(it,jt).eq.13)) then
c                  write(6,*) 'dstate 12/13 -> 8 for ',it,jt
                  tempv1=8
               else
                  write(6,*) 'bad dstate for ',it,jt,': ',dissocstate(it,jt)
                  stop
               endif
               
               if ((dissocstate(il,jt).eq.3).or.(dissocstate(il,jt).eq.4)) then						!Top left subunit
c                  write(6,*) 'check to see if top left subunit is at seam'
                  if (jt.eq.13) then
c                     write(6,*) 'top left subunit is at seam'
                     if ((state(il,jt+1).ne.0).and.(state(il+1,jt+1).ne.0).and.
     @                  (state(13,jt+1).ne.0).and.(state(13,jt+2).ne.0).and.(state(13,jt+3).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',il,jt
                        temph1=8
                     elseif ((state(il,jt+1).ne.0).and.(state(il+1,jt+1).ne.0)) then
                        if (dissocstate(il,jt).eq.3) then
                           if (state(il,jt).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',il,jt
                              temph1=10
                           elseif (state(il,jt).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',il,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',il,jt
                              stop
                           endif
                        elseif (dissocstate(il,jt).eq.4) then
                           if (state(il,jt).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',il,jt
                              temph1=11
                           elseif (state(il,jt).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',il,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',il,jt
                              stop
                           endif
                        endif
                     else
                        if (dissocstate(il,jt).eq.3) then
                           temph1=5
                        elseif (dissocstate(il,jt).eq.4) then
                           temph1=6
                        endif
                     endif
                  else
c                     write(6,*) 'top left subunit is not at seam'
                     if ((state(il-1,jt).ne.0).and.(state(il-1,jt+1).ne.0).and.
     @                  (state(il,jt+1).ne.0).and.(state(il+1,jt+1).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',il,jt
                        temph1=8
                     elseif ((state(il,jt+1).ne.0).and.(state(il+1,jt+1).ne.0)) then
                        if (dissocstate(il,jt).eq.3) then
                           if (state(il,jt).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',il,jt
                              temph1=10
                           elseif (state(il,jt).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',il,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',il,jt
                              stop
                           endif
                        elseif (dissocstate(il,jt).eq.4) then
                           if (state(il,jt).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',il,jt
                              temph1=11
                           elseif (state(il,jt).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',il,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',il,jt
                              stop
                           endif
                        endif
                     else
                        if (dissocstate(il,jt).eq.3) then
                           temph1=5
                        elseif (dissocstate(il,jt).eq.4) then
                           temph1=6
                        endif
                     endif
                  endif
               elseif ((dissocstate(il,jt).eq.5).or.(dissocstate(il,jt).eq.6)) then
                  if ((state(il,jt+1).ne.0).and.(state(il+1,jt+1).ne.0)) then
c                     write(6,*) 'dstate 5/6 -> 8 for ',il,jt
                     temph1=8
                  else
                     if (dissocstate(il,jt).eq.5) then
c                        write(6,*) 'dstate 5 -> 12 for ',il,jt
                        temph1=12
                     elseif (dissocstate(il,jt).eq.6) then
c                        write(6,*) 'dstate 6 -> 13 for ',il,jt
                        temph1=13
                     endif
                  endif
               elseif ((dissocstate(il,jt).eq.10).or.(dissocstate(il,jt).eq.11)) then
c                  write(6,*) 'dstate 10/11 -> 8 for ',il,jt
                  temph1=8
               elseif (dissocstate(il,jt).eq.8) then
c                  write(6,*) 'dstate=8, do nothing'
               else
                  write(6,*) 'bad dstate for ',il,jt,': ',dissocstate(il,jt)
                  stop
               endif
               
               if ((dissocstate(il,jl).eq.3).or.(dissocstate(il,jl).eq.4)) then						!left subunit
c                  write(6,*) 'check to see if left subunit is at seam'
                  if (jl.eq.13) then
c                     write(6,*) 'left subunit is at seam'
                     if ((state(13,jl+1).ne.0).and.(state(13,jl+2).ne.0).and.(state(13,jl+3).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',il,jl
                        temph2=8
                     else
                        if (dissocstate(il,jl).eq.3) then
                           if (state(il,jl).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',il,jl
                              temph2=10
                           elseif (state(il,jl).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',il,jl
                              temph2=11
                           else
                              write(6,*) 'bad state for ',il,jl
                              stop
                           endif
                        elseif (dissocstate(il,jl).eq.4) then
                           if (state(il,jl).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',il,jl
                              temph2=11
                           elseif (state(il,jl).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',il,jl
                              temph2=11
                           else
                              write(6,*) 'bad state for ',il,jl
                              stop
                           endif
                        endif
                     endif
                  else
c                     write(6,*) 'left subunit is not at seam'
                     if ((state(il-1,jl+1).ne.0).and.(state(il-1,jl).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',il,jl
                        temph2=8
                     else
                        if (dissocstate(il,jl).eq.3) then
                           if (state(il,jl).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',il,jl
                              temph2=10
                           elseif (state(il,jl).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',il,jl
                              temph2=11
                           else
                              write(6,*) 'bad state for ',il,jl
                              stop
                           endif
                        elseif (dissocstate(il,jl).eq.4) then
                           if (state(il,jl).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',il,jl
                              temph2=11
                           elseif (state(il,jl).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',il,jl
                              temph2=11
                           else
                              write(6,*) 'bad state for ',il,jl
                              stop
                           endif
                        endif
                     endif
                  endif
               elseif ((dissocstate(il,jl).eq.5).or.(dissocstate(il,jl).eq.6).or.
     @                (dissocstate(il,jl).eq.10).or.(dissocstate(il,jl).eq.11)) then
c                  write(6,*) 'dstate 5/6/10/11 -> 8 for ',il,jl
                  temph2=8
               else
                  write(6,*) 'bad dstate for ',il,jl,': ',dissocstate(il,jl)
                  stop
               endif
               
               if (dissocstate(il,jb).eq.2) then													!Bottom left subunit
                  
c                  write(6,*) 'for dstate=2 may need to change dep for ',il,jb
                  if (dep(il,jb).eq.3) then
                     dep(il,jb)=5
                  else
                     write(6,*) 'bad dep/special case for ',il,jb
                     stop
                  endif
                  
c                  write(6,*) 'check if bottom left subunit is on seam'
                  if (jb.eq.13) then
c                     write(6,*) 'bottom left subunit is on seam'
                     if ((state(13,jb+1).ne.0).and.(state(13,jb+2).ne.0).and.(state(13,jb+3).ne.0)) then
                        if (state(il,jb).eq.1) then
c                           write(6,*) 'dstate 2 -> 12 for ',il,jb
                           temph3=12
                        elseif (state(il,jb).eq.-1) then
c                           write(6,*) 'dstate 2 -> 13 for ',il,jb
                           temph3=13
                        else
                           write(6,*) 'bad state for ',il,jb
                           stop
                        endif
                     else
                        if (state(il,jb).eq.1) then
c                           write(6,*) 'dstate 2 -> 5 for ',il,jb
                           temph3=5
                        elseif (state(il,jb).eq.-1) then
c                           write(6,*) 'dstate 2 -> 6 for ',il,jb
                           temph3=6
                        else
                           write(6,*) 'bad state for ',il,jb
                           stop
                        endif
                     endif
                  else
c                     write(6,*) 'bottom left subunit is not on seam'
                     if ((state(il-1,jb+1).ne.0).and.(state(il-1,jb).ne.0)) then
                        if (state(il,jb).eq.1) then
c                           write(6,*) 'dstate 2 -> 12 for ',il,jb
                           temph3=12
                        elseif (state(il,jb).eq.-1) then
c                           write(6,*) 'dstate 2 -> 13 for ',il,jb
                           temph3=13
                        else
                           write(6,*) 'bad state for ',il,jb
                           stop
                        endif
                     else
                        if (state(il,jb).eq.1) then
c                           write(6,*) 'dstate 2 -> 5 for ',il,jb
                           temph3=5
                        elseif (state(il,jb).eq.-1) then
c                           write(6,*) 'dstate 2 -> 6 for ',il,jb
                           temph3=6
                        else
                           write(6,*) 'bad state for ',il,jb
                           stop
                        endif
                     endif
                  endif
               elseif ((dissocstate(il,jb).eq.5).or.(dissocstate(il,jb).eq.6)) then
c                  write(6,*) 'check to see if bottom left subunit is at seam'
                  if (jb.eq.13) then
c                     write(6,*) 'bottom left subunit is at seam'
                     if (((state(il+1,jb-1).eq.0).and.(state(13,jb+3).eq.0)).and.
     @                  ((state(il,jb-1).ne.0).and.(state(13,jb+2).ne.0).and.
     @                  (state(13,jb+1).ne.0))) then
c                        write(6,*) 'dstate stays 5/6 for ',il,jb
                     elseif ((state(13,jb+3).ne.0).and.(state(13,jb+2).ne.0).and.
     @                      (state(13,jb+1).ne.0)) then
c                        write(6,*) 'dstate 5/6 -> 8 for ',il,jb
                        temph3=8
                     else
                        if (dissocstate(il,jb).eq.5) then
                           if (state(il,jb).eq.1) then
c                              write(6,*) 'dstate 5 -> 10 for ',il,jb
                              temph3=10
                           elseif (state(il,jb).eq.-1) then
c                              write(6,*) 'dstate 5 -> 11, single GDP for ',il,jb
                              temph3=11
                           else
                              write(6,*) 'bad state for ',il,jb
                              stop
                           endif
                        elseif (dissocstate(il,jb).eq.6) then
                           if (state(il,jb).eq.1) then
c                              write(6,*) 'dstate 6 -> 11, single GDP for ',il,jb
                              temph3=11
                           elseif (state(il,jb).eq.-1) then
c                              write(6,*) 'dstate 6 -> 11, double GDP for ',il,jb
                              temph3=11
                           else
                              write(6,*) 'bad state for ',il,jb
                              stop
                           endif
                        endif
                     endif
                  else
c                     write(6,*) 'bottom left subunit is not at seam'
                     if (((state(il-1,jb+1).eq.0).and.(state(il+1,jb-1).eq.0)).and.
     @                  ((state(il-1,jb).ne.0).and.(state(il-1,jb-1).ne.0).and.
     @                  (state(il,jb-1).ne.0))) then
c                        write(6,*) 'dstate stays 5/6 for ',il,jb
                     elseif ((state(il-1,jb+1).ne.0).and.(state(il-1,jb).ne.0)) then
c                        write(6,*) 'dstate 5/6 -> 8 for ',il,jb
                        temph3=8
                     else
                        if (dissocstate(il,jb).eq.5) then
                           if (state(il,jb).eq.1) then
c                              write(6,*) 'dstate 5 -> 10 for ',il,jb
                              temph3=10
                           elseif (state(il,jb).eq.-1) then
c                              write(6,*) 'dstate 5 -> 11, single GDP for ',il,jb
                              temph3=11
                           else
                              write(6,*) 'bad state for ',il,jb
                              stop
                           endif
                        elseif (dissocstate(il,jb).eq.6) then
                           if (state(il,jb).eq.1) then
c                              write(6,*) 'dstate 6 -> 11, single GDP for ',il,jb
                              temph3=11
                           elseif (state(il,jb).eq.-1) then
c                              write(6,*) 'dstate 6 -> 11, double GDP for ',il,jb
                              temph3=11
                           else
                              write(6,*) 'bad state for ',il,jb
                              stop
                           endif
                        endif
                     endif
                  endif
               elseif ((dissocstate(il,jb).eq.10).or.(dissocstate(il,jb).eq.11).or.
     @                (dissocstate(il,jb).eq.12).or.(dissocstate(il,jb).eq.13)) then
c                  write(6,*) 'dstate 10/11/12/13 -> 8 for ',il,jb
                  temph3=8
               elseif (dissocstate(il,jb).eq.8) then
c                  write(6,*) 'dstate stays 8 for ',il,jb
               else
                  write(6,*) 'bad dstate for ',il,jb
                  stop
               endif
               
               if (dissocstate(ib,jb).eq.2) then													!Bottom subunit
                  
c                  write(6,*) 'for dstate=2 may need to change dep for ',ib,jb
                  if (dep(ib,jb).eq.4) then
                     dep(ib,jb)=6
                  else
                     write(6,*) 'bad dep/special case for ',ib,jb
                     stop
                  endif
                  
c                  write(6,*) 'dstate 2 -> 5 for ',ib,jb
                  tempv2=5
               elseif ((dissocstate(ib,jb).eq.5).or.(dissocstate(ib,jb).eq.6)) then
                  if ((state(ib-1,jb-1).eq.0).and.((state(ib,jb-1).ne.0).and.
     @               (state(ib+1,jb-1).ne.0).and.(state(ib+1,jb).ne.0))) then
c                     write(6,*) 'dstate stays 5/6 for ',ib,jb
                  else
                     if (dissocstate(ib,jb).eq.5) then
c                        write(6,*) 'dstate 5 -> 10 for ',ib,jb
                        tempv2=10
                     elseif (dissocstate(ib,jb).eq.6) then
c                        write(6,*) 'dstate 6 -> 11, single GDP for ',ib,jb
                        tempv2=11
                     endif
                  endif
               elseif ((dissocstate(ib,jb).eq.12).or.(dissocstate(ib,jb).eq.13)) then
c                  write(6,*) 'dstate 12/13 -> 8 for ',ib,jb
                  tempv2=8
               else
                  write(6,*) 'bad dstate for ',ib,jb
                  stop
               endif
            elseif ((dep(il,jb).eq.0).or.(dep(ib,jb).eq.0)) then
c               write(6,*) 'bottom 2 subunits in template, dont change'
               if (dissocstate(it,jt).eq.2) then													!Top subunit
c                  write(6,*) 'dstate 2 -> 5 for ',it,jt
                  tempv1=5
               elseif (dissocstate(it,jt).eq.5) then
c                  write(6,*) 'dstate 5 -> 10 for ',it,jt
                  tempv1=10
               elseif (dissocstate(it,jt).eq.6) then
c                  write(6,*) 'dstate 6 -> 11, single GDP for ',it,jt
                  tempv1=11
               elseif ((dissocstate(it,jt).eq.12).or.(dissocstate(it,jt).eq.13)) then
c                  write(6,*) 'dstate 12/13 -> 8 for ',it,jt
                  tempv1=8
               else
                  write(6,*) 'bad dstate for ',it,jt,': ',dissocstate(it,jt)
                  stop
               endif
               
               if ((dissocstate(il,jt).eq.3).or.(dissocstate(il,jt).eq.4)) then						!Top left subunit
c                  write(6,*) 'check to see if top left subunit is at seam'
                  if (jt.eq.13) then
c                     write(6,*) 'top left subunit is at seam'
                     if ((state(il,jt+1).ne.0).and.(state(il+1,jt+1).ne.0).and.
     @                  (state(13,jt+1).ne.0).and.(state(13,jt+2).ne.0).and.(state(13,jt+3).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',il,jt
                        temph1=8
                     elseif ((state(il,jt+1).ne.0).and.(state(il+1,jt+1).ne.0)) then
                        if (dissocstate(il,jt).eq.3) then
                           if (state(il,jt).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',il,jt
                              temph1=10
                           elseif (state(il,jt).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',il,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',il,jt
                              stop
                           endif
                        elseif (dissocstate(il,jt).eq.4) then
                           if (state(il,jt).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',il,jt
                              temph1=11
                           elseif (state(il,jt).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',il,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',il,jt
                              stop
                           endif
                        endif
                     else
                        if (dissocstate(il,jt).eq.3) then
                           temph1=5
                        elseif (dissocstate(il,jt).eq.4) then
                           temph1=6
                        endif
                     endif
                  else
c                     write(6,*) 'top left subunit is not at seam'
                     if ((state(il-1,jt).ne.0).and.(state(il-1,jt+1).ne.0).and.
     @                  (state(il,jt+1).ne.0).and.(state(il+1,jt+1).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',il,jt
                        temph1=8
                     elseif ((state(il,jt+1).ne.0).and.(state(il+1,jt+1).ne.0)) then
                        if (dissocstate(il,jt).eq.3) then
                           if (state(il,jt).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',il,jt
                              temph1=10
                           elseif (state(il,jt).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',il,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',il,jt
                              stop
                           endif
                        elseif (dissocstate(il,jt).eq.4) then
                           if (state(il,jt).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',il,jt
                              temph1=11
                           elseif (state(il,jt).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',il,jt
                              temph1=11
                           else
                              write(6,*) 'bad state for ',il,jt
                              stop
                           endif
                        endif
                     else
                        if (dissocstate(il,jt).eq.3) then
                           temph1=5
                        elseif (dissocstate(il,jt).eq.4) then
                           temph1=6
                        endif
                     endif
                  endif
               elseif ((dissocstate(il,jt).eq.5).or.(dissocstate(il,jt).eq.6)) then
                  if ((state(il,jt+1).ne.0).and.(state(il+1,jt+1).ne.0)) then
c                     write(6,*) 'dstate 5/6 -> 8 for ',il,jt
                     temph1=8
                  else
                     if (dissocstate(il,jt).eq.5) then
c                        write(6,*) 'dstate 5 -> 12 for ',il,jt
                        temph1=12
                     elseif (dissocstate(il,jt).eq.6) then
c                        write(6,*) 'dstate 6 -> 13 for ',il,jt
                        temph1=13
                     endif
                  endif
               elseif ((dissocstate(il,jt).eq.10).or.(dissocstate(il,jt).eq.11)) then
c                  write(6,*) 'dstate 10/11 -> 8 for ',il,jt
                  temph1=8
               elseif (dissocstate(il,jt).eq.8) then
c                  write(6,*) 'dstate=8, do nothing'
               else
                  write(6,*) 'bad dstate for ',il,jt,': ',dissocstate(il,jt)
                  stop
               endif
               
               if ((dissocstate(il,jl).eq.3).or.(dissocstate(il,jl).eq.4)) then						!Left subunit
c                  write(6,*) 'check to see if left subunit is at seam'
                  if (jl.eq.13) then
c                     write(6,*) 'left subunit is at seam'
                     if ((state(13,jl+1).ne.0).and.(state(13,jl+2).ne.0).and.(state(13,jl+3).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',il,jl
                        temph2=8
                     else
                        if (dissocstate(il,jl).eq.3) then
                           if (state(il,jl).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',il,jl
                              temph2=10
                           elseif (state(il,jl).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',il,jl
                              temph2=11
                           else
                              write(6,*) 'bad state for ',il,jl
                              stop
                           endif
                        elseif (dissocstate(il,jl).eq.4) then
                           if (state(il,jl).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',il,jl
                              temph2=11
                           elseif (state(il,jl).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',il,jl
                              temph2=11
                           else
                              write(6,*) 'bad state for ',il,jl
                              stop
                           endif
                        endif
                     endif
                  else
c                     write(6,*) 'left subunit is not at seam'
                     if ((state(il-1,jl+1).ne.0).and.(state(il-1,jl).ne.0)) then
c                        write(6,*) 'dstate 3/4 -> 8 for ',il,jl
                        temph2=8
                     else
                        if (dissocstate(il,jl).eq.3) then
                           if (state(il,jl).eq.1) then
c                              write(6,*) 'dstate 3 -> 10 for ',il,jl
                              temph2=10
                           elseif (state(il,jl).eq.-1) then
c                              write(6,*) 'dstate 3 -> 11, single GDP for ',il,jl
                              temph2=11
                           else
                              write(6,*) 'bad state for ',il,jl
                              stop
                           endif
                        elseif (dissocstate(il,jl).eq.4) then
                           if (state(il,jl).eq.1) then
c                              write(6,*) 'dstate 4 -> 11, single GDP for ',il,jl
                              temph2=11
                           elseif (state(il,jl).eq.-1) then
c                              write(6,*) 'dstate 4 -> 11, double GDP for ',il,jl
                              temph2=11
                           else
                              write(6,*) 'bad state for ',il,jl
                              stop
                           endif
                        endif
                     endif
                  endif
               elseif ((dissocstate(il,jl).eq.5).or.(dissocstate(il,jl).eq.6).or.
     @                (dissocstate(il,jl).eq.10).or.(dissocstate(il,jl).eq.11)) then
c                  write(6,*) 'dstate 5/6/10/11 -> 8 for ',il,jl
                  temph2=8
               else
                  write(6,*) 'bad dstate for ',il,jl,': ',dissocstate(il,jl)
                  stop
               endif
            else
               write(6,*) 'bad dep/special case?'
               stop
            endif
            
c Update...
         if (tempv1.ne.dissocstate(it,jt)) then
            dissocstate(it,jt)=tempv1
c            write(6,*) 'resetting dissocstate of',it,jt,'to',dissocstate(it,jt)
            times(ev(it,jt,2))=get_evtime(dissocstate(it,jt),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                            K_thr_lat,K_all,k_ne,seammult(it,jt))
            call update(event,revmap,ev(it,jt,2),times(ev(it,jt,2)),times,totev)
         endif
         
         if (temph1.ne.dissocstate(il,jt)) then
            dissocstate(il,jt)=temph1
c            write(6,*) 'resetting dissocstate of',il,jt,'to',dissocstate(il,jt)
            times(ev(il,jt,2))=get_evtime(dissocstate(il,jt),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                            K_thr_lat,K_all,k_ne,seammult(il,jt))
            if (temph1.eq.11) then
               if ((state(il,jt).eq.-1).and.(state(il,jt-1).eq.-1)) then
c                  write(6,*) 'double GDP, recalculate times'
                  times(ev(il,jt,2))=times(ev(il,jt,2))*GDP
               else
c                  write(6,*) 'single GDP, do nothing'
               endif
            endif
            call update(event,revmap,ev(il,jt,2),times(ev(il,jt,2)),times,totev)
         endif
         
         if (temph2.ne.dissocstate(il,jl)) then
            dissocstate(il,jl)=temph2
c            write(6,*) 'resetting dissocstate of',il,jl,'to',dissocstate(il,jl)
            times(ev(il,jl,2))=get_evtime(dissocstate(il,jl),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                            K_thr_lat,K_all,k_ne,seammult(il,jl))
            if (temph2.eq.11) then
               if ((state(il,jl).eq.-1).and.(state(il,jl-1).eq.-1)) then
c                  write(6,*) 'double GDP, recalculate times'
                  times(ev(il,jl,2))=times(ev(il,jl,2))*GDP
               else
c                  write(6,*) 'single GDP, do nothing'
               endif
            endif
            call update(event,revmap,ev(il,jl,2),times(ev(il,jl,2)),times,totev)
         endif
         
         if (temph3.ne.dissocstate(il,jb)) then
            dissocstate(il,jb)=temph3
c            write(6,*) 'resetting dissocstate of',il,jb,'to',dissocstate(il,jb)
            times(ev(il,jb,2))=get_evtime(dissocstate(il,jb),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                            K_thr_lat,K_all,k_ne,seammult(il,jb))
            if (temph3.eq.11) then
               if ((state(il,jb).eq.-1).and.(state(il,jb-1).eq.-1)) then
c                  write(6,*) 'double GDP, recalculate times'
                  times(ev(il,jb,2))=times(ev(il,jb,2))*GDP
               else
c                  write(6,*) 'single GDP, do nothing'
               endif
            endif
            call update(event,revmap,ev(il,jb,2),times(ev(il,jb,2)),times,totev)
         endif
         
         if (tempv2.ne.dissocstate(ib,jb)) then
            dissocstate(ib,jb)=tempv2
c            write(6,*) 'resetting dissocstate of',ib,jb,'to',dissocstate(ib,jb)
            times(ev(ib,jb,2))=get_evtime(dissocstate(ib,jb),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                            K_thr_lat,K_all,k_ne,seammult(ib,jb))
            call update(event,revmap,ev(ib,jb,2),times(ev(ib,jb,2)),times,totev)
         endif

       return
       end
C
C
C +++++
C       
C       
      subroutine CheckLatNeighb(k,j,state,addstate,ev,nrecyc,recyc,dissocstate,
     @                      event,revmap,times,totev,nev,qdebug,dep)
C i/o
      integer k,j,state(13,*),addstate(13,*),ev(13,2000,*),nrecyc
      integer recyc(*),dissocstate(13,*),event(*),revmap(*)
      integer totev,nev(13,*),dep(13,*)
      logical qdebug
      double precision times(*)
C local
      integer index,temp,count,temph,tempv,tempd,ih,jh,iv,jv
         
c         write(6,*) 'inside CheckLatNeighb',k,j,state(k,j)
         if (state(k,j).ne.0) then
         
c            write(6,*) 'this site is already taken: ',k,j,dissocstate(k,j)
            addstate(k,j)=addstate(k,j)-1
            
         else
c            if (qdebug) write(6,*) 'Site is unoccupied: ',k,j,ev(k,j,1)
            if (addstate(k,j).eq.1) then
               if (ev(k,j,1).ne.0)	then
c                  if (qdebug) write(6,*) 'Lose Addition at : ',k,j,ev(k,j,1),totev
                  nrecyc = nrecyc+1
      			  recyc(nrecyc) = ev(k,j,1)
      			  index=revmap(ev(k,j,1))
      			  ev(k,j,1)=0
      			  addstate(k,j)=addstate(k,j)-1
      			  dissocstate(k,j)=0
      			  
      			  temp=event(index)
	  			  event(index)=event(totev)
	  			  event(totev)=temp
	  			  revmap(event(totev))=totev
	  			  revmap(event(index))=index
	  			  times(event(totev))=1d15

                  totev=totev-1

	  			  call min_heapify(event,revmap,times,index,totev)
 
      			  call hpsort(nrecyc,recyc)
      		   else
      			  write(6,*) 'trouble1'
      			  stop
      		   endif
      		   nev(k,j)=nev(k,j)-1
      		elseif (addstate(k,j).gt.1) then 
c      		   write(6,*) 'Was two more neighbors at : ',k,j,
c     @                      dissocstate(k,j)
               addstate(k,j)=addstate(k,j)-1
                  
               temp=0
               
               if (dissocstate(k,j).eq.2) then
               	  temp=2
               elseif(dissocstate(k,j).eq.3) then
                  temp=3
               elseif (dissocstate(k,j).eq.5) then
               	  temp=3
c Start nucleotide exchange fun here...               	  
               elseif (dissocstate(k,j).eq.6) then
               	  temp=4
               elseif (dissocstate(k,j).eq.12) then
                  temp=5
               elseif (dissocstate(k,j).eq.13) then
                  temp=6
c End nucleotide exchange fun here...                  
               else
               	  temp=0
               	  write(6,*) 'why are we here?, addstate',addstate(k,j)
               	  write(6,*) 'dissociation state equals garbage',dissocstate(k,j)
               	  stop
               endif
               
c               write(6,*) 'updating dissocstate',k,j,dissocstate(k,j),'->',temp
               dissocstate(k,j) = temp
            endif
         endif
         
      return
      end
C
C
C +++++
C
C
      subroutine AddTo1(i,j,dissocstate,state,addstate,dep,nev,totev,
     @                   xloc,yloc,ev,nrecyc,recyc,times,k_on,conc,
     @                   GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                   K_thr_lat,K_all,event,revmap,seammult,ntub,k_ne)

      implicit none
      
      integer i,j,nrecyc,totev,recyc(*),xloc(*),yloc(*)
      integer revmap(*),event(*)
      integer dissocstate(13,*),addstate(13,*),state(13,*)
      integer nev(13,*),dep(13,*),ev(13,2000,*)
      double precision k_on,conc,GDP,K_lat,K_long,K_both,k_hyd,times(*)      
      double precision K_thr_long,K_thr_lat,K_all,k_ne
      double precision get_evtime
      double precision seammult(13,*)
      logical Qadd
      
      integer lmax,ll
      integer ntub	!declared
         
c         write(6,*) 'At the seam, pf#1, need to look at',13,j+1,13,j+2
         if (dissocstate(i,j).eq.2) then
c            write(6,*) 'adding into dstate2 at pf1'
            ! if the neighb is to the right, easy
            if (state(i+1,j).ne.0) then
c               write(6,*) 'neighb is to the right, leave that dstate alone'
               dep(i,j)=4
               addstate(i+1,j)=addstate(i+1,j)+1
            else
c               write(6,*) 'neighbs are across the seam, leave their dstates alone'
c               write(6,*) 'eventually calc new time for the j+2'
               dep(i,j)=3
               call UpdateEmptyRi(state,i,j,addstate,dissocstate)
            endif
            call UpdateEmptyUp(state,i,j,addstate,dissocstate,event,revmap,
     @                         totev,nev,ev,nrecyc,recyc,xloc,yloc,
     @                         times,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,seammult,k_ne)
            call UpdateEmptyDo(state,i,j,addstate,dissocstate)
c Have some nucleotide exchange fun here...
         elseif ((dissocstate(i,j).eq.3).or.(dissocstate(i,j).eq.4)) then
c            write(6,*) 'adding into dstate3/4 at pf1'
c Stop nucleotide exchange fun here...

            if (state(i,j-1).ne.0) then
               dep(i,j)=2
               addstate(i,j-1)=addstate(i,j-1)+1
               call UpdateEmptyUp(state,i,j,addstate,dissocstate,event,revmap,
     @                         totev,nev,ev,nrecyc,recyc,xloc,yloc,
     @                         times,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,seammult,k_ne)
            else
               dep(i,j)=1
               addstate(i,j+1)=addstate(i,j+1)+1
               call UpdateEmptyDo(state,i,j,addstate,dissocstate)
            endif
            call UpdateEmptyRi(state,i,j,addstate,dissocstate,Qadd)
            if (Qadd) then
c               write(6,*) 'insert the new addition event'
               dissocstate(i+1,j)=2
               call AddNewAdditionEvent(i+1,j,addstate,totev,nev,ev,nrecyc,recyc,
     @                               xloc,yloc,times,k_on,conc,GDP,K_lat,
     @                               K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                               K_all,event,revmap,seammult,k_ne)            
            endif



               if (addstate(13,j+1).eq.0) then
c                  write(6,*) 'making new type 2 addn across seam'
                  addstate(13,j+1)=addstate(13,j+1)+1
                  dissocstate(13,j+1)=2
                  totev=totev+1
                  nev(13,j+1)=nev(13,j+1)+1
                  if (nrecyc.eq.0) then
                     xloc(totev)=13
                     yloc(totev)=j+1
                     ev(13,j+1,1)=totev
                  else
                     ev(13,j+1,1)=recyc(1)
	                 xloc(recyc(1))=13
				     yloc(recyc(1))=j+1
			         if (nrecyc.gt.1) then
		                recyc(1)=recyc(nrecyc)
	   	                call hpsort(nrecyc-1,recyc)
	 	             endif
				     nrecyc=nrecyc-1
                  endif
                  
                  times(ev(13,j+1,1))=get_evtime(1,k_on,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                             K_thr_lat,K_all,k_ne,seammult(13,j+1))
    
    		      event(totev)=ev(13,j+1,1)
    		      revmap(ev(13,j+1,1))=totev
	              call build_min_heap(event,revmap,times,totev)
	           else
	              if (dissocstate(13,j+1).eq.2) then
c	                 write(6,*) 'dstate 2 next door stays that way'
	                 addstate(13,j+1)=addstate(13,j+1)+1
	              elseif (dissocstate(13,j+1).eq.3) then
	                 dissocstate(13,j+1)=5
	                 addstate(13,j+1)=addstate(13,j+1)+1
ccccccccccccccccccccccccccccccccccccccccccccccccccccc
	                 seammult(13,j+1)=1.0															
	                 if (state(13,j+1).ne.0) then
c	                    write(6,*) 'gaining full lateral contact, make seammult = 1'
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccccccccccccccccccccccccccccc    
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                        if ((dissocstate(13,j).eq.5).and.(state(13,j).eq.1)) then
                           if (j.gt.102) then
c                           write(6,*) 'dstate 2 below across seam 5->10'
                           dissocstate(13,j)=10
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j))
    
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           endif
c                        elseif ((dissocstate(13,j).eq.5).and.(state(13,j).eq.-1)) then
c                           if (j.gt.102) then
c                           write(6,*) 'dstate 2 below across seam 5->11'
c                           dissocstate(13,j)=11
c                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
c     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,seammult(13,j))
c    
c                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
c                           endif
                        elseif (dissocstate(13,j).eq.6) then										!(13,j) can be dissocstate=6 only if (13,j-1) has a
                           if (j.gt.102) then														!state=-1. This allows for (13,j+1) to have a
c                           write(6,*) 'dstate 2 below across seam 6->11'							!dissocstate=3.
                           dissocstate(13,j)=11														!
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,				!
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j))		!
    																								!
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)		!
                           endif																	!
                        elseif ((dissocstate(13,j).eq.12).or.(dissocstate(13,j).eq.13)) then
                           if (j.gt.102) then
c                           write(6,*) 'dstate 2 below across seam 12/13->8'
                           dissocstate(13,j)=8
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j))
    
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           endif
                        elseif (dissocstate(13,j).eq.8) then
c                           write(6,*) 'dstate already 8, nothing to do'
                        else
                           write(6,*) 'ran out of dstate checks special 2-below seam'
                           stop
                        endif
	                 endif
	              elseif (dissocstate(13,j+1).eq.4) then
	                 dissocstate(13,j+1)=6
	                 addstate(13,j+1)=addstate(13,j+1)+1
cccccccccccccccccccccccccccccccccccccccccccccccccccccc
	                 seammult(13,j+1)=1.0
	                 if (state(13,j+1).ne.0) then
c	                    write(6,*) 'gaining full lateral contact, make seammult = 1'
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccccccccccccccccccccccccccc    
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
c                        if ((dissocstate(13,j).eq.5).and.(state(13,j).eq.1)) then
c                           if (j.gt.102) then
c                           write(6,*) 'dstabe 2 below across seam 5->10'
c                           dissocstate(13,j)=10
c                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
c     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,seammult(13,j))
c    
c                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
c                           endif
                        if (dissocstate(13,j).eq.5) then
                           if (j.gt.102) then
c                           write(6,*) 'dstate 2 below across seam 5->11'
                           dissocstate(13,j)=11
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j))
    
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           endif
                        elseif ((dissocstate(13,j).eq.6).and.(state(13,j-1).eq.1)) then
                           if (j.gt.102) then
c                           write(6,*) 'dstate 2 below across seam 6->11'
                           dissocstate(13,j)=11
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j))
    
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           endif
                        elseif ((dissocstate(13,j).eq.6).and.(state(13,j-1).eq.-1)) then
                           if (j.gt.102) then
c                           write(6,*) 'dstate 2 below across seam 6->11'
c                           write(6,*) 'double GDP'
                           dissocstate(13,j)=11
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j))
    
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           endif
                        elseif ((dissocstate(13,j).eq.12).or.(dissocstate(13,j).eq.13)) then
                           if (j.gt.102) then
c                           write(6,*) 'dstate 2 below across seam 12/13->8'
                           dissocstate(13,j)=8
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j))
    
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           endif
                        else
                           write(6,*) 'ran out of dstate checks special 2-below seam'
                           stop
                        endif
	                 endif
	              elseif (dissocstate(13,j+1).eq.5) then
	                 dissocstate(13,j+1)=12
	                 addstate(13,j+1)=addstate(13,j+1)+1
ccccccccccccccccccccccccccccccccccccccccccccccccccccccc
	                 seammult(13,j+1)=1.0
	                 if (state(13,j+1).ne.0) then
c	                    write(6,*) 'gaining full lateral contact, make seammult = 1'
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccccccccccccccccccccccccccccccc    
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
	                 endif
	              elseif (dissocstate(13,j+1).eq.6) then
	                 dissocstate(13,j+1)=13
	                 addstate(13,j+1)=addstate(13,j+1)+1
ccccccccccccccccccccccccccccccccccccccccccccccccccccccc
	                 seammult(13,j+1)=1.0
	                 if (state(13,j+1).ne.0) then
c	                    write(6,*) 'gaining full lateral contact, make seammult = 1'
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccccccccccccccccccccccccccccccc    
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
	                 endif
	              elseif ((dissocstate(13,j+1).eq.10).or.(dissocstate(13,j+1).eq.11)) then
	                 dissocstate(13,j+1)=8
	                 addstate(13,j+1)=addstate(13,j+1)+1
ccccccccccccccccccccccccccccccccccccccccccccccccccccccc
	                 seammult(13,j+1)=1.0
	                 if (state(13,j+1).ne.0) then
c	                    write(6,*) 'gaining full lateral contact, make seammult = 1'
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccccccccccccccccccccccccccccccc    
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
	                 endif
	              elseif (dissocstate(13,j+1).eq.8) then
	                 write(6,*) 'already dstate8, makes no sense'
	                 stop
	              else
	                 write(6,*) 'not handled dstates yet'
	                 stop
	              endif
	           endif
c Start nucleotide exchange fun here...
         elseif ((dissocstate(i,j).eq.5).or.(dissocstate(i,j).eq.6)) then
c            write(6,*) 'adding into dstate5/6 at pf1'
c Stop nucleotide exchange fun here...
            if (state(i,j-1).ne.0) then
               addstate(i,j-1)=addstate(i,j-1)+1
            else
               write(6,*) 'empty below?'
               stop
            endif
            if (state(i+1,j).ne.0) then
c               write(6,*) 'corn neighb is to the right, across seam should be empty'
               addstate(i+1,j)=addstate(i+1,j)+1
                  if (addstate(13,j+1).eq.0) then
c                     write(6,*) 'making new type 2 addn across seam'
                     addstate(13,j+1)=addstate(13,j+1)+1
                     dissocstate(13,j+1)=2
                     totev=totev+1
                     nev(13,j+1)=nev(13,j+1)+1
                     if (nrecyc.eq.0) then
                        xloc(totev)=13
                        yloc(totev)=j+1
                        ev(13,j+1,1)=totev
                     else
                        ev(13,j+1,1)=recyc(1)
	                    xloc(recyc(1))=13
				        yloc(recyc(1))=j+1
			            if (nrecyc.gt.1) then
		                   recyc(1)=recyc(nrecyc)
	   	                   call hpsort(nrecyc-1,recyc)
	 	                endif
				        nrecyc=nrecyc-1
                     endif
                  
                     times(ev(13,j+1,1))=get_evtime(1,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                             K_thr_lat,K_all,k_ne,seammult(13,j+1))
    
    		         event(totev)=ev(13,j+1,1)
    		         revmap(ev(13,j+1,1))=totev
	                 call build_min_heap(event,revmap,times,totev)
	              else
	                 if (dissocstate(13,j+1).eq.2) then
	                    if (state(13,j+1).ne.0) then
	                       write(6,*) 'neighbor in dstate=2 across seam?'
	                       stop
	                    else
c	                       write(6,*) 'leave dstate at 2'
	                       addstate(13,j+1)=addstate(13,j+1)+1
	                    endif
	                 elseif (dissocstate(13,j+1).eq.3) then
	                    dissocstate(13,j+1)=5
	                    addstate(13,j+1)=addstate(13,j+1)+1
cccccccccccccccccccccccccccccccccccccccccccccccc
	                    seammult(13,j+1)=1.0
	                    if (state(13,j+1).ne.0) then
c	                       write(6,*) 'gaining full lateral contact, make seammult = 1'
                           times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccccccccccccccccccccc    
                           call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                           if (state(13,j).eq.0) then
                              write(6,*) 'empty below??'
                              stop
                           else
c                              write(6,*) 'special case, change two below potentially'
                              if (dissocstate(13,j).eq.5) then
                                 dissocstate(13,j)=10
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j))
    
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                              elseif (dissocstate(13,j).eq.6) then
                                 dissocstate(13,j)=11
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j))
c Adding code to check for double GDP for dstate 11.
                                 if ((state(13,j).eq.-1).and.(state(13,j-1).eq.-1)) then
c                                    write(6,*) 'double GDP, recalculate times'
                                    times(ev(13,j,2))=times(ev(13,j,2))*GDP
                                 else
c                                    write(6,*) 'single GDP, do nothing'
                                 endif
cccccccccccccccccccccccccccccccccccccccccccccccccccc
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
c                                 write(6,*) 'double gtp/gdp not tested here'
c                                 stop
                              elseif ((dissocstate(13,j).eq.12).or.(dissocstate(13,j).eq.13)) then
                                 dissocstate(13,j)=8
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j))
    
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                              elseif (dissocstate(13,j).eq.8) then
c                                 write(6,*) 'dstate=8, do nothing'
                              else
                                 write(6,*) 'not treated 10/11 yet'
                                 stop
                              endif
                           endif
	                    endif
	                 elseif (dissocstate(13,j+1).eq.4) then
	                    dissocstate(13,j+1)=6
	                    addstate(13,j+1)=addstate(13,j+1)+1
cccccccccccccccccccccccccccccccccccccccccccccccccccc
	                    seammult(13,j+1)=1.0
	                    if (state(13,j+1).ne.0) then
c	                       write(6,*) 'gaining full lateral contact, make seammult = 1'
                           times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
	                       if (state(13,j).eq.0) then
                              write(6,*) 'empty below??'
                              stop
                           else
c                              write(6,*) 'special case, change two below potentially'
                              if (dissocstate(13,j).eq.5) then
                                 dissocstate(13,j)=10
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j))
    
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                              elseif (dissocstate(13,j).eq.6) then
                                 dissocstate(13,j)=11
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j))
c Adding code to check for double GDP for dstate 11.
                                 if ((state(13,j).eq.-1).and.(state(13,j-1).eq.-1)) then
c                                    write(6,*) 'double GDP, recalculate times'
                                    times(ev(13,j,2))=times(ev(13,j,2))*GDP
                                 else
c                                    write(6,*) 'single GDP, do nothing'
                                 endif
cccccccccccccccccccccccccccccccccccccccccccccccccccc    
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
c                                 write(6,*) 'double gtp/gdp not tested here'
c                                 stop
                              elseif ((dissocstate(13,j).eq.12).or.(dissocstate(13,j).eq.13)) then
                                 dissocstate(13,j)=8
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j))

                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                              elseif (dissocstate(13,j).eq.8) then
c                                 write(6,*) 'dstate=8, do nothing'
                              else
                                 write(6,*) 'not treated 10/11 yet'
                                 stop
                              endif
                           endif
	                    endif
	                 elseif (dissocstate(13,j+1).eq.5) then
	                    dissocstate(13,j+1)=12
	                    addstate(13,j+1)=addstate(13,j+1)+1
ccccccccccccccccccccccccccccccccccccccccccccccccccc	                    
	                    seammult(13,j+1)=1.0
	                    if (state(13,j+1).ne.0) then
c	                       write(6,*) 'gaining full lateral contact, make seammult = 1'
                           times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
	                    endif
	                 elseif (dissocstate(13,j+1).eq.6) then
	                    dissocstate(13,j+1)=13
	                    addstate(13,j+1)=addstate(13,j+1)+1
ccccccccccccccccccccccccccccccccccccccccccccccccccc	                    
	                    seammult(13,j+1)=1.0
	                    if (state(13,j+1).ne.0) then
c	                       write(6,*) 'gaining full lateral contact, make seammult = 1'
                           times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
	                    endif
	                 elseif ((dissocstate(13,j+1).eq.10).or.(dissocstate(13,j+1).eq.11)) then
	                    dissocstate(13,j+1)=8
	                    addstate(13,j+1)=addstate(13,j+1)+1
cccccccccccccccccccccccccccccccccccccccccccccccccc	                    
	                    seammult(13,j+1)=1.0
	                    if (state(13,j+1).ne.0) then
c	                       write(6,*) 'gaining full lateral contact, make seammult = 1'
                           times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
	                    endif
	                 else
	                    write(6,*) 'not handled dstates yet'
	                    stop
	                 endif
	              endif
c               write(6,*) 'find diag'
               if ((state(i,j-1).ne.0).and.(state(i,j+1).eq.0)) then
c                  write(6,*) 'diag is down'
c                  write(6,*) 'diag is lower right'

                  ! always do the horizontal neighbor
                  dep(i,j)=7
                  if (dissocstate(i+1,j).eq.3) then
                     dep(i+1,j)=8
                     dissocstate(i+1,j) = 5
                     times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j))
                     call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                  elseif (dissocstate(i+1,j).eq.4) then
                     dep(i+1,j)=8
                     dissocstate(i+1,j) = 6
                     times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j))
                     call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                  elseif (dissocstate(i+1,j).eq.5) then
                     dep(i+1,j)=8
                     dissocstate(i+1,j) = 12
                     times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j))
                     call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                  elseif (dissocstate(i+1,j).eq.6) then
                     dep(i+1,j)=8
                     dissocstate(i+1,j) = 13
                     times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j))
                     call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                  elseif ((dissocstate(i+1,j).eq.10).or.(dissocstate(i+1,j).eq.11)) then
                     dep(i+1,j)=8
                     dissocstate(i+1,j) = 8
                     times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j))
                     call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                  else
                     write(6,*) 'Bad Dstate for right neighbor'
                     stop
                  endif
                  
                  ! Do the vertical/diagonal neighbors *IF* j > 103
                  if (j.gt.103) then
                     ! first the vertical ones
                     if (dissocstate(i,j-1).eq.5) then
                        dissocstate(i,j-1) = 10
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                     
                     elseif (dissocstate(i,j-1).eq.6) then
                        dissocstate(i,j-1) = 11
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i,j-1))
c Adding code to check for double GDP for dstate 11.
                        if ((state(i,j-1).eq.-1).and.(state(i,j-2).eq.-1)) then
c                           write(6,*) 'double GDP, recalculate times'
                           times(ev(i,j-1,2))=times(ev(i,j-1,2))*GDP
                        else
c                           write(6,*) 'single GDP, do nothing'
                        endif
cccccccccccccccccccccccccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                                          
                     elseif ((dissocstate(i,j-1).eq.12).or.(dissocstate(i,j-1).eq.13)) then
                        dissocstate(i,j-1) = 8
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                                          
                     else
                        write(6,*) 'Bad Dstate for vert neighbor'
                        stop                     
                     endif
                     ! then the diagonal ones
                     if (dissocstate(i+1,j-1).eq.5) then
                        dissocstate(i+1,j-1) = 10
                        times(ev(i+1,j-1,2))=get_evtime(dissocstate(i+1,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j-1))
                        call update(event,revmap,ev(i+1,j-1,2),times(ev(i+1,j-1,2)),times,totev)                     
                     elseif (dissocstate(i+1,j-1).eq.6) then
                        dissocstate(i+1,j-1) = 11
                        times(ev(i+1,j-1,2))=get_evtime(dissocstate(i+1,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j-1))
c Adding code to check for double GDP for dstate 11.
                        if ((state(i+1,j-1).eq.-1).and.(state(i+1,j-2).eq.-1)) then
c                           write(6,*) 'double GDP, recalculate times'
                           times(ev(i+1,j-1,2))=times(ev(i+1,j-1,2))*GDP
                        else
c                           write(6,*) 'single GDP, do nothing'
                        endif
cccccccccccccccccccccccccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(i+1,j-1,2),times(ev(i+1,j-1,2)),times,totev)                                          
                     elseif ((dissocstate(i+1,j-1).eq.12).or.(dissocstate(i+1,j-1).eq.13)) then
                        dissocstate(i+1,j-1) = 8
                        times(ev(i+1,j-1,2))=get_evtime(dissocstate(i+1,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j-1))
                        call update(event,revmap,ev(i+1,j-1,2),times(ev(i+1,j-1,2)),times,totev)                                          
                     elseif (dissocstate(i+1,j-1).eq.8) then
c                        write(6,*) 'diagdstate=8, leave alone'
                     else
                        write(6,*) 'Bad Dstate for diag neighbor'
                        stop                     
                     endif
                  endif

                  call UpdateEmptyUp(state,i,j,addstate,dissocstate,event,revmap,
     @                         totev,nev,ev,nrecyc,recyc,xloc,yloc,
     @                         times,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,seammult,k_ne)

               elseif ((state(i,j-1).eq.0).and.(state(i,j+1).ne.0)) then
                  write(6,*) 'diag is up, not handled'
                  stop
               else
                  write(6,*) 'cant find diag'
                  stop
               endif
            else
c               write(6,*) 'corn neighb is across the seam, right should be empty'

               if ( (state(13,j+1).eq.0).or.(state(13,j+2).eq.0) ) then
                  write(6,*) 'bad config across seam at 13'
                  stop
               endif
               dep(i,j)=8
               addstate(13,j+1)=addstate(13,j+1)+1
               if (dissocstate(13,j+1).eq.3) then
c                  write(6,*) 'make dstate go from 3->5'
cccccccccccccccccccccccccccccccccccccccccccccccc                  
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'
                  dissocstate(13,j+1) = 5
                  seammult(13,j+1)=1.0
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                  if (dissocstate(13,j).eq.5) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 5->10'
                        dissocstate(13,j)=10
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
 
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
c                  elseif ((dissocstate(13,j).eq.5).and.(state(13,j).eq.-1)) then
c                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 5->11'
c                        dissocstate(13,j)=11
c                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
c     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,seammult(13,j))
c    
c                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
c                     endif
                  elseif (dissocstate(13,j).eq.6) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 6->11'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.12).or.(dissocstate(13,j).eq.13)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 12/13->8'
                        dissocstate(13,j)=8
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  else
                     write(6,*) 'ran out of dstate checks special 2-below seam'
                     stop
                  endif
               elseif (dissocstate(13,j+1).eq.4) then
c                  write(6,*) 'make dstate go from 4->6'
ccccccccccccccccccccccccccccccccccccccccccccccccccccc                  
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'
                  dissocstate(13,j+1) = 6
                  seammult(13,j+1)=1.0
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                       K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
c                  if ((dissocstate(13,j).eq.5).and.(state(13,j).eq.1)) then
c                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 5->10'
c                        dissocstate(13,j)=10
c                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
c     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,seammult(13,j))
c    
c                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
c                     endif
                  if (dissocstate(13,j).eq.5) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 5->11'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.6).and.(state(13,j-1).eq.1)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 6->11'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.6).and.(state(13,j-1).eq.-1)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 6->11'
c                        write(6,*) 'double GDP'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif 
                  elseif ((dissocstate(13,j).eq.12).or.(dissocstate(13,j).eq.13)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 12/13->8'
                        dissocstate(13,j)=8
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  else
                     write(6,*) 'ran out of dstate checks special 2-below seam'
                     stop
                  endif
               elseif (dissocstate(13,j+1).eq.5) then
c                  write(6,*) 'make dstate go from 5->12'
ccccccccccccccccccccccccccccccccccccccccccccc                  
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'
                  dissocstate(13,j+1) = 12
                  seammult(13,j+1)=1.0
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                       K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                  if (dissocstate(13,j).eq.5) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 5->10'
                        dissocstate(13,j)=10
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif (dissocstate(13,j).eq.6) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 6->11'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.12).or.(dissocstate(13,j).eq.13)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 12/13->8'
                        dissocstate(13,j)=8
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif (dissocstate(13,j).eq.8) then
c                     write(6,*) 'already dstate 8, leave alone'
                  else
                     write(6,*) 'ran out of dstate checks special 2-below seam'
                     stop
                  endif
               elseif (dissocstate(13,j+1).eq.6) then
c                  write(6,*) 'make dstate go from 6->13'
cccccccccccccccccccccccccccccccccccccccccccccc                  
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'
                  dissocstate(13,j+1) = 13
                  seammult(13,j+1)=1.0
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                       K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                  if (dissocstate(13,j).eq.5) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 5->11'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.6).and.(state(13,j-1).eq.1)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 6->11'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.6).and.(state(13,j-1).eq.-1)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 6->11'
c                        write(6,*) 'double GDP'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.12).or.(dissocstate(13,j).eq.13)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 12/13->8'
                        dissocstate(13,j)=8
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif (dissocstate(13,j).eq.8) then
c                     write(6,*) 'dstate already 8, leave alone'
                  else
                     write(6,*) 'ran out of dstate checks special 2-below seam'
                     stop
                  endif
               elseif ((dissocstate(13,j+1).eq.10).or.(dissocstate(13,j+1).eq.11)) then
c                  write(6,*) 'make dstate go from 10,11->8'
ccccccccccccccccccccccccccccccccccccccccccccccccc                  
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'
                  dissocstate(13,j+1) = 8
                  seammult(13,j+1)=1.0
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                       K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccccccccccccccccccccc
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                  if (dissocstate(13,j).eq.5) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 5->10'
                        dissocstate(13,j)=10
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif (dissocstate(13,j).eq.6) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 6->11'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.12).or.(dissocstate(13,j).eq.13)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 12/13->8'
                        dissocstate(13,j)=8
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif (dissocstate(13,j).eq.8) then
c                     write(6,*) 'already 8, nothing to change'
                  else
                     write(6,*) 'ran out of dstate checks special 2-below seam'
                     stop
                  endif
               else
                  write(6,*) 'bad dstate for lower seam neighb?'
                  stop
               endif

                  if (j.gt.103) then
                     ! first the vertical ones
                     if (dissocstate(i,j-1).eq.5) then
                        dissocstate(i,j-1) = 10
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                     
                     elseif (dissocstate(i,j-1).eq.6) then
                        dissocstate(i,j-1) = 11
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                                          
                     elseif ((dissocstate(i,j-1).eq.12).or.(dissocstate(i,j-1).eq.13)) then
                        dissocstate(i,j-1) = 8
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                                          
                     else
                        write(6,*) 'Bad Dstate for vert neighbor'
                        stop                     
                     endif
                  endif                              
                  call UpdateEmptyUp(state,i,j,addstate,dissocstate,event,revmap,
     @                         totev,nev,ev,nrecyc,recyc,xloc,yloc,
     @                         times,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,seammult,k_ne)
                  call UpdateEmptyRi(state,i,j,addstate,dissocstate,Qadd)               
                  if (Qadd) then
c                     write(6,*) 'insert the new addition event'
                     dissocstate(i+1,j)=2
                     call AddNewAdditionEvent(i+1,j,addstate,totev,nev,ev,nrecyc,recyc,
     @                               xloc,yloc,times,k_on,conc,GDP,K_lat,
     @                               K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                               K_all,event,revmap,seammult,k_ne)                           
               endif
            endif




c Start nucleotide exchange fun here...
         elseif ((dissocstate(i,j).eq.12).or.(dissocstate(i,j).eq.13)) then
c            write(6,*) 'adding into dstate12/13 at pf1'
c Stop nucleotide exchange fun here...            
            if (state(i,j-1).ne.0) then
               addstate(i,j-1)=addstate(i,j-1)+1
            else
               write(6,*) 'empty below?'
               stop
            endif
c               write(6,*) 'looking to the right, first'
               addstate(i+1,j)=addstate(i+1,j)+1
               if ((state(i,j-1).ne.0).and.(state(i,j+1).eq.0)) then
c                  write(6,*) 'diag is down'
c                  write(6,*) 'diag is lower right'

                  ! always do the horizontal neighbor
                  dep(i,j)=7
                  if (dissocstate(i+1,j).eq.3) then
                     dep(i+1,j)=8
                     dissocstate(i+1,j) = 5
                     times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j))
                     call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                  elseif (dissocstate(i+1,j).eq.4) then
                     dep(i+1,j)=8
                     dissocstate(i+1,j) = 6
                     times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j))
                     call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                  elseif (dissocstate(i+1,j).eq.5) then
                     dep(i+1,j)=8
                     dissocstate(i+1,j) = 12
                     times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j))
                     call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                  elseif (dissocstate(i+1,j).eq.6) then
                     dep(i+1,j)=8
                     dissocstate(i+1,j) = 13
                     times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j))
                     call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                  elseif ((dissocstate(i+1,j).eq.10).or.(dissocstate(i+1,j).eq.11)) then
                     dep(i+1,j)=8
                     dissocstate(i+1,j) = 8
                     times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j))
                     call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                  else
                     write(6,*) 'Bad Dstate for right neighbor'
                     stop
                  endif
                  
                  if (j.gt.103) then
                     ! first the vertical ones
                     if (dissocstate(i,j-1).eq.5) then
                        dissocstate(i,j-1) = 10
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                     
                     elseif (dissocstate(i,j-1).eq.6) then
                        dissocstate(i,j-1) = 11
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i,j-1))
c Adding code to check for double GDP for dstate 11.
                        if ((state(i,j-1).eq.-1).and.(state(i,j-2).eq.-1)) then
c                           write(6,*) 'double GDP, recalculate times'
                           times(ev(i,j-1,2))=times(ev(i,j-1,2))*GDP
                        else
c                           write(6,*) 'single GDP, do nothing'
                        endif
cccccccccccccccccccccccccccccccccccccccccccccccccccc
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                                          
                     elseif ((dissocstate(i,j-1).eq.12).or.(dissocstate(i,j-1).eq.13)) then
                        dissocstate(i,j-1) = 8
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                                          
                     else
                        write(6,*) 'Bad Dstate for vert neighbor'
                        stop                     
                     endif
                     ! then the diagonal ones
                     if (dissocstate(i+1,j-1).eq.5) then
                        dissocstate(i+1,j-1) = 10
                        times(ev(i+1,j-1,2))=get_evtime(dissocstate(i+1,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j-1))
                        call update(event,revmap,ev(i+1,j-1,2),times(ev(i+1,j-1,2)),times,totev)                     
                     elseif (dissocstate(i+1,j-1).eq.6) then
                        dissocstate(i+1,j-1) = 11
                        times(ev(i+1,j-1,2))=get_evtime(dissocstate(i+1,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j-1))
c Adding code to check for double GDP for dstate 11.
                        if ((state(i+1,j-1).eq.-1).and.(state(i+1,j-2).eq.-1)) then
c                           write(6,*) 'double GDP, recalculate times'
                           times(ev(i+1,j-1,2))=times(ev(i+1,j-1,2))*GDP
                        else
c                           write(6,*) 'single GDP, do nothing'
                        endif
cccccccccccccccccccccccccccccccccccccccccccccccccccc
                        call update(event,revmap,ev(i+1,j-1,2),times(ev(i+1,j-1,2)),times,totev)                                          
                     elseif ((dissocstate(i+1,j-1).eq.12).or.(dissocstate(i+1,j-1).eq.13)) then
                        dissocstate(i+1,j-1) = 8
                        times(ev(i+1,j-1,2))=get_evtime(dissocstate(i+1,j-1),k_on,conc,GDP,K_lat,
     @                             K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i+1,j-1))
                        call update(event,revmap,ev(i+1,j-1,2),times(ev(i+1,j-1,2)),times,totev)                                          
                     elseif (dissocstate(i+1,j-1).eq.8) then
c                        write(6,*) 'diagdstate=8, leave alone'
                     else
                        write(6,*) 'Bad Dstate for diag neighbor'
                        stop                     
                     endif
                  endif

                  call UpdateEmptyUp(state,i,j,addstate,dissocstate,event,revmap,
     @                         totev,nev,ev,nrecyc,recyc,xloc,yloc,
     @                         times,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,seammult,k_ne)

               elseif ((state(i,j-1).eq.0).and.(state(i,j+1).ne.0)) then
                  write(6,*) 'diag is up, not handled'
                  stop
               else
                  write(6,*) 'cant find diag'
                  stop
               endif
c               write(6,*) 'now check across the diagonal'
               if ( (state(13,j+1).eq.0).or.(state(13,j+2).eq.0) ) then
                  write(6,*) 'bad config across seam at 13'
                  stop
               endif
               addstate(13,j+1)=addstate(13,j+1)+1
               if (dissocstate(13,j+1).eq.3) then
c                  write(6,*) 'make dstate go from 3->5'
ccccccccccccccccccccccccccccccccccccccccccc                  
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'
                  dissocstate(13,j+1) = 5
                  seammult(13,j+1)=1.0
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                       K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                       K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                  if (dissocstate(13,j).eq.5) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 5->10'
                        dissocstate(13,j)=10
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.6).and.(state(13,j-1).eq.1)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 6->11'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
   
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.6).and.(state(13,j-1).eq.-1)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 6->11'
c                        write(6,*) 'double GDP'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
   
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.12).or.(dissocstate(13,j).eq.13)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 12/13->8'
                        dissocstate(13,j)=8
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  else
                     write(6,*) 'ran out of dstate checks special 2-below seam'
                     stop
                  endif
               elseif (dissocstate(13,j+1).eq.4) then
c                  write(6,*) 'make dstate go from 4->6'
ccccccccccccccccccccccccccccccccccccccccccccc                  
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'
                  dissocstate(13,j+1) = 6
                  seammult(13,j+1)=1.0
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                       K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                  if (dissocstate(13,j).eq.5) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 5->11'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif (dissocstate(13,j).eq.6) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 6->11'
c                        write(6,*) 'double GDP'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.12).or.(dissocstate(13,j).eq.13)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 12/13->8'
                        dissocstate(13,j)=8
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  else
                     write(6,*) 'ran out of dstate checks special 2-below seam'
                     stop
                  endif
               elseif (dissocstate(13,j+1).eq.5) then
c                  write(6,*) 'make dstate go from 5->12'
cccccccccccccccccccccccccccccccccccccccccccccccccc                  
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'
                  dissocstate(13,j+1) = 12
                  seammult(13,j+1)=1.0
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                       K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                  if ((dissocstate(13,j).eq.5).and.(state(13,j).eq.1)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 5->10'
                        dissocstate(13,j)=10
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.6).and.(state(13,j-1).eq.1)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 6->11'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.6).and.(state(13,j-1).eq.-1)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 6->11'
c                        write(6,*) 'double GDP'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.12).or.(dissocstate(13,j).eq.13)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 12/13->8'
                        dissocstate(13,j)=8
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif (dissocstate(13,j).eq.8) then
c                     write(6,*) 'dtsate already 8, leave alone'
                  else
                     write(6,*) 'ran out of dstate checks special 2-below seam'
                     stop
                  endif
               elseif (dissocstate(13,j+1).eq.6) then
c                  write(6,*) 'make dstate go from 6->13'
cccccccccccccccccccccccccccccccccccccccc                  
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'
                  dissocstate(13,j+1) = 13
                  seammult(13,j+1)=1.0
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                       K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                  if (dissocstate(13,j).eq.5) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 5->11'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif (dissocstate(13,j).eq.6) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 6->11'
c                        write(6,*) 'double GDP'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.12).or.(dissocstate(13,j).eq.13)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 12/13->8'
                        dissocstate(13,j)=8
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif (dissocstate(13,j).eq.8) then
c                     write(6,*) 'already 8 down there'
                  else
                     write(6,*) 'ran out of dstate checks special 2-below seam'
                     stop
                  endif
               elseif ((dissocstate(13,j+1).eq.10).or.(dissocstate(13,j+1).eq.11)) then
c                  write(6,*) 'make dstate go from 10,11->8'
cccccccccccccccccccccccccccccccccccccccccccccc                  
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'
                  dissocstate(13,j+1) = 8
                  seammult(13,j+1)=1.0
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                       K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                  if ((dissocstate(13,j).eq.5).and.(state(13,j).eq.1)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 5->10'
                        dissocstate(13,j)=10
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif (dissocstate(13,j).eq.6) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 6->11'
                        dissocstate(13,j)=11
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
   
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif ((dissocstate(13,j).eq.12).or.(dissocstate(13,j).eq.13)) then
                     if (j.gt.102) then
c                        write(6,*) 'dstabe 2 below across seam 12/13->8'
                        dissocstate(13,j)=8
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j))
    
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     endif
                  elseif (dissocstate(13,j).eq.8) then
c                     write(6,*) 'already 8, nothing to do'
                  else
                     write(6,*) 'ran out of dstate checks special 2-below seam', dissocstate(13,j)
                     stop
                  endif
               else
                  write(6,*) 'bad dstate for lower seam neighb?'
                  stop
               endif
         else
            write(6,*) 'adding into 8: gotta implement'
            stop
         endif
         
c going to look and see if upper seam neighbor needs seam multiplier...
         if (state(13,j+2).ne.0) then
            if (state(i,j+1).eq.0) then
c               write(6,*) 'upper seam neighbor has half neighbor: ',13,j+2
c               write(6,*) 'update seammult'
               seammult(13,j+2)=17.2
c               seammult(13,j+2)=1.0		!to turn off
               times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j+2))
               call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
            else
c               write(6,*) 'gaining full lateral contact: ',13,j+2
c               write(6,*) 'update seammult'
               seammult(13,j+2)=1.0
               times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(13,j+2))
               call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
            endif
         else
c if upper seam neighbor not present and lower seam neighbor present then new addition should get seam multiplier updated.
            if (state(13,j+1).ne.0) then
c               write(6,*) 'new addition has half neighbor'
c               write(6,*) 'update seammult'
               seammult(i,j)=17.2	!update in get_evtime should occur below
c               seammult(i,j)=1.0		!to turn off
            else
               write(6,*) 'do nothing for new addition seammult-wise'
            endif
         endif

c		 write(6,*) 'new dissociation: ',i,j
		totev=totev+1
		nev(i,j)=nev(i,j)+1
		if (nrecyc.eq.0) then
			xloc(totev)=i
			yloc(totev)=j
			ev(i,j,2)=totev
		else
			ev(i,j,2)=recyc(1)
			xloc(recyc(1))=i
			yloc(recyc(1))=j
			if (nrecyc.gt.1) then
				recyc(1)=recyc(nrecyc)
				call hpsort(nrecyc-1,recyc)
			endif
			nrecyc=nrecyc-1
	  	 endif
	  	
	  	 times(ev(i,j,2))=get_evtime(dissocstate(i,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(i,j))

		  event(totev)=ev(i,j,2)
    	  revmap(ev(i,j,2))=totev
  		  call build_min_heap(event,revmap,times,totev)

c Start nucleotide exchange fun here...
c         write(6,*) 'check to see if subunit below needs have hydrolysis event'
         if ((state(i,j-1).eq.1).and.(j.gt.103)) then
c            write(6,*) 'there is a new hydrolysis at site: ',i,j-1
            totev=totev+1
            nev(i,j-1)=nev(i,j-1)+1
            if (nrecyc.eq.0) then
               xloc(totev)=i
               yloc(totev)=j-1
               ev(i,j-1,3)=totev
            else
			   ev(i,j-1,3)=recyc(1)
			   xloc(recyc(1))=i
			   yloc(recyc(1))=j-1
			   if (nrecyc.gt.1) then
				   recyc(1)=recyc(nrecyc)
				   call hpsort(nrecyc-1,recyc)
			   endif
			   nrecyc=nrecyc-1
            endif
         
            times(ev(i,j-1,3))=get_evtime(7,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(i,j-1))

		     event(totev)=ev(i,j-1,3)
    	     revmap(ev(i,j-1,3))=totev
  			 call build_min_heap(event,revmap,times,totev)
  		 elseif ((state(i,j-1).eq.-1).and.(j.gt.103)) then
c  		    write(6,*) 'subunit below already hydrolyzed, do nothing for: ',i,j-1
       	 endif
c End nucleotide exchange fun here...       	 

      return
      end
C
C
C +++++
C
C
      subroutine AddTo13(i,j,dissocstate,state,addstate,dep,nev,totev,
     @                   xloc,yloc,ev,nrecyc,recyc,times,k_on,conc,
     @                   GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,
     @                   K_thr_lat,K_all,event,revmap,seammult,ntub,k_ne)

      implicit none
      
      integer i,j,nrecyc,totev,recyc(*),xloc(*),yloc(*)
      integer revmap(*),event(*)
      integer dissocstate(13,*),addstate(13,*),state(13,*)
      integer nev(13,*),dep(13,*),ev(13,2000,*),temp
      double precision k_on,conc,GDP,K_lat,K_long,K_both,k_hyd,times(*)
      double precision K_thr_long,K_thr_lat,K_all,k_ne
      logical Qadd
      double precision get_evtime
      double precision seammult(13,*)
      
      integer lmax,ll
      integer ntub	!declared
         
c         write(6,*) 'At the seam, pf#13, need to look at',1,j-2,1,j-1
         if (dissocstate(i,j).eq.2) then
c            write(6,*) 'adding into dstate2 at pf13'
            ! in the neighb is to the left, easy
            if (state(i-1,j).ne.0) then
c               write(6,*) 'neighb is to the left, leave that dstate alone'
               dep(i,j)=3
               addstate(i-1,j)=addstate(i-1,j)+1
               if ( (state(1,j-2).ne.0).or.(state(1,j-1).ne.0) ) then
c                  write(6,*) 'making half hole across seam'
               endif
            else
c               write(6,*) 'neighbs are across the seam, leave their dstates alone'
c               write(6,*) 'eventually calc new time for the j-1'
               dep(i,j)=4
               call UpdateEmptyLe(state,i,j,addstate,dissocstate,Qadd)
               if (nev(i-1,j).eq.0) then
c                  write(6,*) 'making new type 2 addn to the left'
c                  addstate(i-1,j)=addstate(i-1,j)+1
                  dissocstate(i-1,j)=2
                  totev=totev+1
                  nev(i-1,j)=nev(i-1,j)+1
                  if (nrecyc.eq.0) then
                     xloc(totev)=i-1
                     yloc(totev)=j
                     ev(i-1,j,1)=totev
                  else
                     ev(i-1,j,1)=recyc(1)
	                 xloc(recyc(1))=i-1
				     yloc(recyc(1))=j
			         if (nrecyc.gt.1) then
		                recyc(1)=recyc(nrecyc)
	   	                call hpsort(nrecyc-1,recyc)
	 	             endif
				     nrecyc=nrecyc-1
                  endif
                  
                  times(ev(i-1,j,1))=get_evtime(1,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(i-1,j))
    
    		      event(totev)=ev(i-1,j,1)
    		      revmap(ev(i-1,j,1))=totev
	              call build_min_heap(event,revmap,times,totev)
	           endif
            endif
            call UpdateEmptyUp(state,i,j,addstate,dissocstate,event,revmap,
     @                         totev,nev,ev,nrecyc,recyc,xloc,yloc,
     @                         times,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,seammult,k_ne)
            call UpdateEmptyDo(state,i,j,addstate,dissocstate)
c Start nucleotide exchange fun here...
         elseif ((dissocstate(i,j).eq.3).or.(dissocstate(i,j).eq.4)) then
c            write(6,*) 'adding into dstate3/4 at pf13'
c Stop nucleotide exchange fun here...            
            if (state(i,j-1).ne.0) then
               dep(i,j)=2
               addstate(i,j-1)=addstate(i,j-1)+1
            call UpdateEmptyUp(state,i,j,addstate,dissocstate,event,revmap,
     @                         totev,nev,ev,nrecyc,recyc,xloc,yloc,
     @                         times,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,seammult,k_ne)
            else
               dep(i,j)=1
               addstate(i,j+1)=addstate(i,j+1)+1
               call UpdateEmptyDo(state,i,j,addstate,dissocstate)
            endif
            temp = dissocstate(i-1,j)
c            write(6,*) 'dstate before empty left check: ',temp
            call UpdateEmptyLe(state,i,j,addstate,dissocstate,Qadd)
c            write(6,*) 'dstate after empty left check: ',dissocstate(i-1,j)
            if ((temp.ne.dissocstate(i-1,j)).and.Qadd) then
c               write(6,*) 'insert the new addition event'
C
C there is something wrong with my logic here - add new event iven if one there already?
C
                  dissocstate(i-1,j)=2
                  call AddNewAdditionEvent(i-1,j,addstate,totev,nev,ev,nrecyc,recyc,
     @                               xloc,yloc,times,k_on,conc,GDP,K_lat,
     @                               K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                               K_all,event,revmap,seammult,k_ne)            
            endif
            if (j-2.ge.103) then
               if (addstate(1,j-2).eq.0) then
c                  write(6,*) 'making new type 2 addn across seam'
                  addstate(1,j-2)=addstate(1,j-2)+1
                  dissocstate(1,j-2)=2
                  totev=totev+1
                  nev(1,j-2)=nev(1,j-2)+1
                  if (nrecyc.eq.0) then
                     xloc(totev)=1
                     yloc(totev)=j-2
                     ev(1,j-2,1)=totev
                  else
                     ev(1,j-2,1)=recyc(1)
	                 xloc(recyc(1))=1
				     yloc(recyc(1))=j-2
			         if (nrecyc.gt.1) then
		                recyc(1)=recyc(nrecyc)
	   	                call hpsort(nrecyc-1,recyc)
	 	             endif
				     nrecyc=nrecyc-1
                  endif
                  
                  times(ev(1,j-2,1))=get_evtime(1,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-2))
    
    		      event(totev)=ev(1,j-2,1)
    		      revmap(ev(1,j-2,1))=totev
	              call build_min_heap(event,revmap,times,totev)
	           else
	              if (dissocstate(1,j-2).eq.2) then
c	                 write(6,*) 'leave dstate at 2 next door, crash if occupied'
	                 addstate(1,j-2)=addstate(1,j-2)+1
	                 if (state(1,j-2).eq.0) then
c	                    write(6,*) 'empty'
	                 else
	                    write(6,*) 'occupied and dstate=2?'
	                    stop
	                 endif
	              elseif (dissocstate(1,j-2).eq.3) then
	                 dissocstate(1,j-2)=5
	                 addstate(1,j-2)=addstate(1,j-2)+1
cccccccccccccccccccccccccccccccc	                 
	                 seammult(1,j-2)=1.0
	                 if (state(1,j-2).ne.0) then
c	                    write(6,*) 'gaining full lateral contact, make seammult = 1'
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-2))
cccccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                        if (j.gt.105) then
c                           write(6,*) 'special case, checking 2 below'
                           if ((dissocstate(1,j-3).eq.12).or.(dissocstate(1,j-3).eq.13)) then
                              dissocstate(1,j-3)=8
                              times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(1,j-3))
                              call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                           elseif (dissocstate(1,j-3).eq.5) then
                              ! NB: we are dstate=5, so only our nt state dictates 10/11
                              if (state(1,j-3).eq.1) then
                                 dissocstate(1,j-3)=10
                              elseif (state(1,j-3).eq.-1) then
                                 dissocstate(1,j-3)=11
                              endif
                              times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(1,j-3))
                              call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)                                    
                           elseif (dissocstate(1,j-3).eq.6) then
                              ! NB: we are dstate=6, so go to 11 no matter what. if we are dp, then 2X
                              dissocstate(1,j-3)=11
                              times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(1,j-3))
                              if (state(1,j-3).eq.-1) then
                                 times(ev(1,j-3,2))=GDP*times(ev(1,j-3,2))
                              endif
                              call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)                                    
                           elseif (dissocstate(1,j-3).eq.8) then
c                              write(6,*) 'already 8'
                           else
                              write(6,*) 'need to implement the rest of the conditions'
                              stop
                           endif
                        endif
	                 endif
	              elseif (dissocstate(1,j-2).eq.4) then
	                 dissocstate(1,j-2)=6
	                 addstate(1,j-2)=addstate(1,j-2)+1
ccccccccccccccccccccccccccccccc	                 
	                 seammult(1,j-2)=1.0
	                 if (state(1,j-2).ne.0) then
c	                    write(6,*) 'gaining full lateral contact, make seammult = 1'
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-2))
ccccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                        if (j.gt.105) then
c                           write(6,*) 'special case, chaecking 2 below'
                           if ((dissocstate(1,j-3).eq.12).or.(dissocstate(1,j-3).eq.13)) then
                              dissocstate(1,j-3)=8
                              times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(1,j-3))
                              call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                           elseif (dissocstate(1,j-3).eq.5) then
                              ! NB: we are dstate=5, so only our nt state dictates 10/11
                              if (state(1,j-3).eq.1) then
                                 dissocstate(1,j-3)=10
                              elseif (state(1,j-3).eq.-1) then
                                 dissocstate(1,j-3)=11
                              endif
                              times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(1,j-3))
                              call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)                                    
                           elseif (dissocstate(1,j-3).eq.6) then
                              ! NB: we are dstate=6, so go to 11 no matter what. if we are dp, then 2X
                              dissocstate(1,j-3)=11
                              times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(1,j-3))
                              if (state(1,j-3).eq.-1) then
                                 times(ev(1,j-3,2))=GDP*times(ev(1,j-3,2))
                              endif
                              call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)                                    
                           elseif (dissocstate(1,j-3).eq.8) then
c                              write(6,*) 'already 8'
                           else
                              write(6,*) 'need to implement the rest of the conditions'
                              stop
                           endif
                        endif
	                 endif
	              elseif (dissocstate(1,j-2).eq.5) then
	                 dissocstate(1,j-2)=12
	                 addstate(1,j-2)=addstate(1,j-2)+1
ccccccccccccccccccccccccccccccc	                 
	                 seammult(1,j-2)=1.0
	                 if (state(1,j-2).ne.0) then
c	                    write(6,*) 'gaining full lateral contact, make seammult = 1'
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-2))
ccccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
	                 endif
	              elseif (dissocstate(1,j-2).eq.6) then
	                 dissocstate(1,j-2)=13
	                 addstate(1,j-2)=addstate(1,j-2)+1
ccccccccccccccccccccccccccccccc	                 
	                 seammult(1,j-2)=1.0
	                 if (state(1,j-2).ne.0) then
c	                    write(6,*) 'gaining full lateral contact, make seammult = 1'
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-2))
ccccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
	                 endif
	              else
	                 write(6,*) 'not handled dstates yet', dissocstate(1,j-2)
	                 stop
	              endif
	           endif
	        endif
c Start nucleotide exchange fun here...
         elseif ((dissocstate(i,j).eq.5).or.(dissocstate(i,j).eq.6)) then
c            write(6,*) 'adding into dstate5/6 at pf13'
c Stop nucleotide exchange fun here...            
            if (state(i-1,j).ne.0) then
c               write(6,*) 'corn neighb is to the left, across seam should be empty'
               addstate(i-1,j)=addstate(i-1,j)+1
               if (j-2.ge.103) then
                  if (addstate(1,j-2).eq.0) then
c                     write(6,*) 'making new type 2 addn across seam'
                     addstate(1,j-2)=addstate(1,j-2)+1
                     dissocstate(1,j-2)=2
                     totev=totev+1
                     nev(1,j-2)=nev(1,j-2)+1
                     if (nrecyc.eq.0) then
                        xloc(totev)=1
                        yloc(totev)=j-2
                        ev(1,j-2,1)=totev
                     else
                        ev(1,j-2,1)=recyc(1)
	                    xloc(recyc(1))=1
				        yloc(recyc(1))=j-2
			            if (nrecyc.gt.1) then
		                   recyc(1)=recyc(nrecyc)
	   	                   call hpsort(nrecyc-1,recyc)
	 	                endif
				        nrecyc=nrecyc-1
                     endif
                  
                     times(ev(1,j-2,1))=get_evtime(1,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-2))
    
    		         event(totev)=ev(1,j-2,1)
    		         revmap(ev(1,j-2,1))=totev
	                 call build_min_heap(event,revmap,times,totev)
	              else
	                 if (dissocstate(1,j-2).eq.2) then
c	                    write(6,*) 'dstate 2 across seam, leave alone'
	                    addstate(1,j-2)=addstate(1,j-2)+1
	                    if (state(1,j-2).ne.0) then
	                       write(6,*) 'accupied dstate 2 across seam'
	                       stop
	                    endif
	                 elseif (dissocstate(1,j-2).eq.3) then
	                    dissocstate(1,j-2)=5
	                    addstate(1,j-2)=addstate(1,j-2)+1
ccccccccccccccccccccccccccccccc	                    
	                    seammult(1,j-2)=1.0
	                    if (state(1,j-2).ne.0) then
c	                       write(6,*) 'gaining full lateral contact, make seammult = 1'
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-2))
ccccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                           if (j.gt.105) then
c                              write(6,*) 'special case, chaecking 2 below'
                              if ((dissocstate(1,j-3).eq.12).or.(dissocstate(1,j-3).eq.13)) then
                                 dissocstate(1,j-3)=8
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (dissocstate(1,j-3).eq.5) then
                                 ! NB: we are dstate=5, so only our nt state dictates 10/11
                                 if (state(1,j-3).eq.1) then
                                    dissocstate(1,j-3)=10
                                 elseif (state(1,j-3).eq.-1) then
                                    dissocstate(1,j-3)=11
                                 endif
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              !added May 31st
                              elseif (dissocstate(1,j-3).eq.6) then
                                 dissocstate(1,j-3)=11
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (dissocstate(1,j-3).eq.8) then		!May 31: changed i to 1
c                                 write(6,*) 'already 8'
                              else
                                 write(6,*) 'need to implement the rest of the conditions'
                                 stop
                              endif
                           endif
	                    endif
c Start nucleotide exchange fun here...
                     elseif (dissocstate(1,j-2).eq.4) then
	                    dissocstate(1,j-2)=6
	                    addstate(1,j-2)=addstate(1,j-2)+1
ccccccccccccccccccccccccccccccc	                    
	                    seammult(1,j-2)=1.0
	                    if (state(1,j-2).ne.0) then
c	                       write(6,*) 'gaining full lateral contact, make seammult = 1'
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-2))
ccccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                           if (j.gt.105) then
c                              write(6,*) 'special case, chaecking 2 below'
                              if ((dissocstate(1,j-3).eq.12).or.(dissocstate(1,j-3).eq.13)) then
                                 dissocstate(1,j-3)=8
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (dissocstate(1,j-3).eq.5) then
                                 ! NB: we are dstate=5, so only our nt state dictates 10/11
                                 if (state(1,j-3).eq.1) then
                                    dissocstate(1,j-3)=10
                                 elseif (state(1,j-3).eq.-1) then
                                    dissocstate(1,j-3)=11
                                 endif
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              !added May 31st
                              elseif (dissocstate(1,j-3).eq.6) then
                                 dissocstate(1,j-3)=11
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (dissocstate(1,j-3).eq.8) then		!May 31: changed i to 1
c                                 write(6,*) 'already 8'
                              else
                                 write(6,*) 'need to implement the rest of the conditions'
                                 stop
                              endif
                           endif
	                    endif
c End nucleotide exchange fun here...	                    
	                 elseif (dissocstate(1,j-2).eq.5) then
	                    dissocstate(1,j-2)=12
	                    addstate(1,j-2)=addstate(1,j-2)+1
ccccccccccccccccccccccccccccc	                    
	                    seammult(1,j-2)=1.0
	                    if (state(1,j-2).ne.0) then
c	                       write(6,*) 'gaining full lateral contact, make seammult = 1'
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-2))
ccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
	                    endif
	                 elseif (dissocstate(1,j-2).eq.6) then
	                    dissocstate(1,j-2)=13
	                    addstate(1,j-2)=addstate(1,j-2)+1
ccccccccccccccccccccccccccccc	                    
	                    seammult(1,j-2)=1.0
	                    if (state(1,j-2).ne.0) then
c	                       write(6,*) 'gaining full lateral contact, make seammult = 1'
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-2))
ccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
	                    endif
	                 else
	                    write(6,*) 'not handled dstates yet'
	                    stop
	                 endif
	              endif
	           endif               
c               write(6,*) 'find diag'
               if ((state(i,j-1).ne.0).and.(state(i,j+1).eq.0)) then
c                  write(6,*) 'diag is down'
C
C I changed .or. to .and. below, and eq to ne b/c it did not make sense - possible to have a upp right corner
C at pf13 with nothing in pf1.
                  if ((state(1,j-2).ne.0).and.(state(1,j-1).ne.0)) then
                     write(6,*) 'bad config across seam?'
                     stop
                  endif
                  
c                  write(6,*) 'diag is lower left'
C
C new corner stuff here
C
                  dep(i,j)=8
                  dep(i-1,j)=7
                  ! first do the horizontal checks
                  if (dissocstate(i-1,j).eq.3) then
                        dissocstate(i-1,j) = 5
                        times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                                K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                                K_all,k_ne,seammult(i-1,j))
                        call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)                  
                  elseif (dissocstate(i-1,j).eq.4) then
                        dissocstate(i-1,j) = 6
                        times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                                K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                                K_all,k_ne,seammult(i-1,j))
                        call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)                  
                  elseif (dissocstate(i-1,j).eq.5) then
                        dissocstate(i-1,j) = 12
                        times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                                K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                                K_all,k_ne,seammult(i-1,j))
                        call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)                  
                  elseif (dissocstate(i-1,j).eq.6) then
                        dissocstate(i-1,j) = 13
                        times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                                K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                                K_all,k_ne,seammult(i-1,j))
                        call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)                  
                  elseif ((dissocstate(i-1,j).eq.10).or.(dissocstate(i-1,j).eq.11)) then
                        dissocstate(i-1,j) = 8
                        times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                                K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                                K_all,k_ne,seammult(i-1,j))
                        call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)                  
                  else
                     write(6,*) 'weird right dstate'
                     stop
                  endif
                  ! do vertical and diagonal if j > 103
                  if (j.gt.103) then
                     !vertical
                     addstate(i,j-1)=addstate(i,j-1)+1
                     if (dissocstate(i,j-1).eq.5) then
                        dissocstate(i,j-1) = 10
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                                K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                                K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                                       
                     elseif (dissocstate(i,j-1).eq.6) then
                        dissocstate(i,j-1) = 11
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                                K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                                K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                                                            
                     elseif ((dissocstate(i,j-1).eq.12).or.(dissocstate(i,j-1).eq.13)) then
                        dissocstate(i,j-1) = 8
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                                K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                                K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                                       
                     else
                        write(6,*) 'Bad vertical dstate'
                        stop
                     endif
                     !diagonal
                     if (dissocstate(i-1,j-1).eq.5) then
                        dissocstate(i-1,j-1) = 10
                        times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                                                K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                                K_all,k_ne,seammult(i-1,j-1))
                        call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)                                       
                     elseif (dissocstate(i-1,j-1).eq.6) then
                        dissocstate(i-1,j-1) = 11
                        times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                                                K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                                K_all,k_ne,seammult(i-1,j-1))
                        call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)                                                            
                     elseif ((dissocstate(i-1,j-1).eq.12).or.(dissocstate(i-1,j-1).eq.13)) then
                        dissocstate(i-1,j-1) = 8
                        times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                                                K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                                K_all,k_ne,seammult(i-1,j-1))
                        call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)                                       
                     elseif (dissocstate(i-1,j-1).eq.8) then
c                        write(6,*) 'diag is 8, nothing to do'
                     else
                        write(6,*) 'Bad diagonal dstate'
                        stop
                     endif
                  endif
            call UpdateEmptyUp(state,i,j,addstate,dissocstate,event,revmap,
     @                         totev,nev,ev,nrecyc,recyc,xloc,yloc,
     @                         times,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,seammult,k_ne)



               else if ((state(i,j-1).eq.0).and.(state(i,j+1).ne.0)) then
                  write(6,*) 'diag is up, not handled'
                  stop
               else
                  write(6,*) 'cant find diag'
                  stop
               endif
               
            else
c               write(6,*) 'corn neighb is across the seam, left should be empty'
               if ((state(i,j-1).ne.0).and.(state(i,j+1).eq.0)) then
c                  write(6,*) 'diag is lower right across seam'
                  dep(i,j)=7
                  if ( (state(1,j-1).eq.0).or.(state(1,j-2).eq.0) ) then
                     write(6,*) 'bad config across seam at 13'
                     stop
                  endif
                  if (j.gt.103) then
                     if (dissocstate(1,j-1).eq.3) then
                        write(6,*) 'leave dstate at 3, but eventually calc a new time'
                     elseif (dissocstate(1,j-1).eq.4) then											!Did not have case for
                        write(6,*) 'leave dstate at 4, but eventually calc a new time'				!dstate=4.
                     elseif (dissocstate(1,j-1).eq.5) then
                        write(6,*) 'leave dstate at 5, but eventually calc a new time'                  
                     elseif (dissocstate(1,j-1).eq.6) then
                        write(6,*) 'leave dstate at 6, but eventually calc a new time'                  
                     elseif (dissocstate(1,j-1).eq.8) then
                        write(6,*) 'leave dstate at 8'                                    
                     elseif (dissocstate(1,j-1).eq.10) then
                        write(6,*) 'leave dstate at 10'                                    
                     elseif (dissocstate(1,j-1).eq.11) then
                        write(6,*) 'leave dstate at 11'                                    
                     else
                        write(6,*) 'put in more dstates'
                        stop
                     endif
                     if (j.ge.105) then
c                        write(6,*) 'j ge 105: I think I have to implement stuff for the lower seam neigb'
                        if (dissocstate(1,j-2).eq.3) then
                           dissocstate(1,j-2) = 5
cccccccccccccccccccccccccccccccccccccccc                           
                           seammult(1,j-2)=1.0
c                           write(6,*) 'gaining full lateral contact, make seammult = 1'
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                            K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                            K_all,k_ne,seammult(1,j-2))
cccccccccccccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                           addstate(1,j-2)=addstate(1,j-2)+1                                                                  
c                              write(6,*) 'special case, chaecking 2 below'
                              if ((dissocstate(1,j-3).eq.12).or.(dissocstate(1,j-3).eq.13)) then
                                 dissocstate(1,j-3)=8
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (dissocstate(1,j-3).eq.5) then
                                 ! NB: we are dstate=5, so only our nt state dictates 10/11
                                 if (state(1,j-3).eq.1) then
                                    dissocstate(1,j-3)=10
                                 elseif (state(1,j-3).eq.-1) then
                                    dissocstate(1,j-3)=11
                                 endif
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              !added May 31st
                              elseif (dissocstate(1,j-3).eq.6) then
                                 dissocstate(1,j-3)=11
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)   
                              elseif (dissocstate(1,j-3).eq.8) then		!May 31: changed i to 1
c                                 write(6,*) 'already 8'
                              else
                                 write(6,*) 'need to implement the rest of the conditions'
                                 stop
                              endif
                        elseif (dissocstate(1,j-2).eq.4) then
                           dissocstate(1,j-2) = 6
cccccccccccccccccccccccccccccccccccccccc                           
                           seammult(1,j-2)=1.0
c                           write(6,*) 'gaining full lateral contact, make seammult = 1'                           
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                            K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                            K_all,k_ne,seammult(1,j-2))
cccccccccccccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                           addstate(1,j-2)=addstate(1,j-2)+1                                                                                          
                              if ((dissocstate(1,j-3).eq.12).or.(dissocstate(1,j-3).eq.13)) then
                                 dissocstate(1,j-3)=8
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (dissocstate(1,j-3).eq.5) then
                                 ! NB: we are dstate=5, so only our nt state dictates 10/11
                                 if (state(1,j-3).eq.1) then
                                    dissocstate(1,j-3)=10
                                 elseif (state(1,j-3).eq.-1) then
                                    dissocstate(1,j-3)=11
                                 endif
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              !added May 31st
                              elseif (dissocstate(1,j-3).eq.6) then
                                 dissocstate(1,j-3)=11
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                             K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)   
                              elseif (dissocstate(1,j-3).eq.8) then		!May 31: changed i to 1
c                                 write(6,*) 'already 8'
                              else
                                 write(6,*) 'need to implement the rest of the conditions'
                                 stop
                              endif
                        elseif (dissocstate(1,j-2).eq.5) then                        
                           dissocstate(1,j-2) = 12
cccccccccccccccccccccccccccccccccccccccc                           
                           seammult(1,j-2)=1.0
c                           write(6,*) 'gaining full lateral contact, make seammult = 1'                           
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                            K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                            K_all,k_ne,seammult(1,j-2))
cccccccccccccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                           addstate(1,j-2)=addstate(1,j-2)+1                                                                  
                        elseif (dissocstate(1,j-2).eq.6) then
                           dissocstate(1,j-2) = 13
cccccccccccccccccccccccccccccccccccccccc                           
                           seammult(1,j-2)=1.0
c                           write(6,*) 'gaining full lateral contact, make seammult = 1'                           
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                            K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                            K_all,k_ne,seammult(1,j-2))
cccccccccccccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                           addstate(1,j-2)=addstate(1,j-2)+1                                                                  
                        elseif ((dissocstate(1,j-2).eq.10).or.(dissocstate(1,j-2).eq.11)) then                        
                           dissocstate(1,j-2) = 8
cccccccccccccccccccccccccccccccccccccccc                           
                           seammult(1,j-2)=1.0
c                           write(6,*) 'gaining full lateral contact, make seammult = 1'                           
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                            K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                            K_all,k_ne,seammult(1,j-2))
cccccccccccccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                           addstate(1,j-2)=addstate(1,j-2)+1                                                                  
                        else
                           write(6,*) 'dissocstate not 3,4,5,6,10,11 across seam'
                           stop
                        endif
                     endif
                  endif
C
C putting in some new stuff
C
                  ! WHEN DO I DO ADDSTATE????
                  ! check vertical if j.gt.103
                  if (j.gt.103) then																
                     if (dissocstate(i,j-1).eq.5) then												
                           dissocstate(i,j-1) = 10
                           times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                            K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                            K_all,k_ne,seammult(i,j-1))
                           call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)
                           addstate(i,j-1)=addstate(i,j-1)+1                     
                     elseif (dissocstate(i,j-1).eq.6) then
                           dissocstate(i,j-1) = 11
                           times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                            K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                            K_all,k_ne,seammult(i,j-1))
                           call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)
                           addstate(i,j-1)=addstate(i,j-1)+1                                          
                     elseif ((dissocstate(i,j-1).eq.12).or.(dissocstate(i,j-1).eq.13)) then
                           dissocstate(i,j-1) = 8
                           times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                            K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                            K_all,k_ne,seammult(i,j-1))
                           call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)
                           addstate(i,j-1)=addstate(i,j-1)+1                                          
                     else
c                        write(6,*) 'vertical dstate is not right?'
                        stop
                     endif
                    
                 endif
                  
                  
            call UpdateEmptyUp(state,i,j,addstate,dissocstate,event,revmap,
     @                         totev,nev,ev,nrecyc,recyc,xloc,yloc,
     @                         times,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,seammult,k_ne)
c                  call UpdateEmptyLe(state,i,j,addstate,dissocstate)

               elseif ((state(i,j-1).eq.0).and.(state(i,j+1).ne.0)) then
                  write(6,*) 'diag is upper right across seam, not handled'
                  stop
               else
                  write(6,*) 'cant find diag'
                  stop
               endif
               
               call UpdateEmptyLe(state,i,j,addstate,dissocstate,Qadd)
               if (Qadd) then
c               write(6,*) 'insert the new addition event'
               dissocstate(i-1,j)=2
               call AddNewAdditionEvent(i-1,j,addstate,totev,nev,ev,nrecyc,recyc,
     @                               xloc,yloc,times,k_on,conc,GDP,K_lat,
     @                               K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                               K_all,event,revmap,seammult,k_ne)                           
               endif
            endif
            
         elseif (dissocstate(i,j).eq.8) then
            write(6,*) 'adding into 8: STOP'
            stop
            if (state(i,j+1).eq.0) then
               write(6,*) 'empty above, neighbs on both sides'
               write(6,*) 'take care of site above'
               call UpdateEmptyUp(state,i,j,addstate,dissocstate,event,revmap,
     @                         totev,nev,ev,nrecyc,recyc,xloc,yloc,
     @                         times,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,seammult,k_ne)
               if (j.eq.103) then
                  write(6,*) 'adding to dstate 8 in first row'
                  if (dissocstate(i-1,j).eq.8) then
                     write(6,*) 'dstate to left is already 8'
                     dep(i,j)=8
                  elseif (dissocstate(i-1,j).eq.5) then
                     write(6,*) 'dstate to left is 5'
                     dep(i,j) = 8
                     dissocstate(i-1,j)=8
                     times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j))
                     call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                     addstate(i-1,j)=addstate(i-1,j)+1
                  elseif (dissocstate(i-1,j).eq.3) then
                     write(6,*) 'dstate to left is 3'
                     dep(i,j) = 8
                     dep(i-1,j)=7
                     dissocstate(i-1,j)=5
                     times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j))
                     call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                     addstate(i-1,j)=addstate(i-1,j)+1
                  else
                     write(6,*) 'bad dstate near 8',dissocstate(i-1,j)
                     stop
                  endif
               endif
            else
               write(6,*) 'subunit above, more complicated, gotta do'
               stop
            endif

c Start nucleotide exchange fun here...
         elseif ((dissocstate(i,j).eq.12).or.(dissocstate(i,j).eq.13)) then
c            write(6,*) 'adding into 12/13',i,j,dissocstate(i,j)
c Stop nucleotide exchange fun here...            
            if (j.eq.103) then
c               write(6,*) 'first row, special case, only look left'
               if (dissocstate(i-1,j).eq.3) then !dstate=3 goes to 5
                  dep(i,j)=8
                  dep(i-1,j)=7
                  dissocstate(i-1,j)=5
                  times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j))
                  call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                  addstate(i-1,j)=addstate(i-1,j)+1               
               elseif (dissocstate(i-1,j).eq.4) then !dstate=4 goes to 6
                  dep(i,j)=8
                  dep(i-1,j)=7
                  dissocstate(i-1,j)=6
                  times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j))
                  call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                  addstate(i-1,j)=addstate(i-1,j)+1                              
               elseif (dissocstate(i-1,j).eq.5) then !dstate=5 goes to 12
                  dep(i,j)=8
                  dissocstate(i-1,j)=12
                  times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j))
                  call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                  addstate(i-1,j)=addstate(i-1,j)+1                  
               elseif (dissocstate(i-1,j).eq.6) then !dstate=6 goes to 13
                  dep(i,j)=8
                  dissocstate(i-1,j)=13
                  times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j))
                  call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                  addstate(i-1,j)=addstate(i-1,j)+1                                 
               elseif ((dissocstate(i-1,j).eq.10).or.(dissocstate(i-1,j).eq.11)) then
                  dep(i,j)=8
                  dissocstate(i-1,j)=8
                  times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j))
                  call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                  addstate(i-1,j)=addstate(i-1,j)+1                                                
               else
                  write(6,*) 'dstate ne 3,4,5,6,10,11: no sense'
                  stop
               endif
                        call UpdateEmptyUp(state,i,j,addstate,dissocstate,event,revmap,
     @                         totev,nev,ev,nrecyc,recyc,xloc,yloc,
     @                         times,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,seammult,k_ne)
            else
c               write(6,*) 'above first row, need to work this out'
               
               if (state(i,j+1).ne.0) then
                  write(6,*) 'crash out: not empty above'
                  stop
               endif
               ! first do the left neighbor
               if (dissocstate(i-1,j).eq.3) then !dstate=3 goes to 5
                  dep(i,j)=8
                  dep(i-1,j)=7
                  dissocstate(i-1,j)=5
                  times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j))
                  call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                  addstate(i-1,j)=addstate(i-1,j)+1               
               elseif (dissocstate(i-1,j).eq.4) then !dstate=4 goes to 6
                  dep(i,j)=8
                  dep(i-1,j)=7
                  dissocstate(i-1,j)=6
                  times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j))
                  call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                  addstate(i-1,j)=addstate(i-1,j)+1                              
               elseif (dissocstate(i-1,j).eq.5) then !dstate=5 goes to 12
                  dep(i,j)=8
                  dissocstate(i-1,j)=12
                  times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j))
                  call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                  addstate(i-1,j)=addstate(i-1,j)+1                  
               elseif (dissocstate(i-1,j).eq.6) then !dstate=6 goes to 13
                  dep(i,j)=8
                  dissocstate(i-1,j)=13
                  times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j))
                  call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                  addstate(i-1,j)=addstate(i-1,j)+1                                 
               elseif ((dissocstate(i-1,j).eq.10).or.(dissocstate(i-1,j).eq.11)) then
                  dep(i,j)=8
                  dissocstate(i-1,j)=8
                  times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j))
                  call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                  addstate(i-1,j)=addstate(i-1,j)+1                                                
               else
                  write(6,*) 'dstate ne 3,4,5,6,10,11: no sense',i-1,j,dissocstate(i-1,j)
                  stop
               endif
               !now do the empty above
                        call UpdateEmptyUp(state,i,j,addstate,dissocstate,event,revmap,
     @                         totev,nev,ev,nrecyc,recyc,xloc,yloc,
     @                         times,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,seammult,k_ne)
               !now do the bottom one
               if ((dissocstate(i,j-1).eq.12).or.(dissocstate(i,j-1).eq.13)) then
                  dissocstate(i,j-1)=8
                  times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i,j-1))
                  call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)
                  addstate(i,j-1)=addstate(i,j-1)+1    
               else
                  write(6,*) 'below neighb not dstate=12/13'
                  stop
               endif
               ! potentially need to check the left diagonal
               if (dissocstate(i-1,j-1).eq.5) then !dstate 5 goes to 10/11
                  if (state(i-1,j-1).eq.1) then
c                     write(6,*) 'left diag 5->10'
                     dissocstate(i-1,j-1)=10
                     times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j-1))
                     call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)
                  elseif (state(i-1,j-1).eq.-1) then
c                     write(6,*) 'left diag 5->11'
                     dissocstate(i-1,j-1)=11
                     times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j-1))
                     call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)
                  else
                     write(6,*) 'left diag not state 1 or state -1'
                     stop
                  endif
               elseif (dissocstate(i-1,j-1).eq.6) then !dstate 6 goes to 11
                  if (state(i-1,j-1).eq.1) then
c                     write(6,*) 'left diag 6->11'
                     dissocstate(i-1,j-1)=11
                     times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j-1))
                     call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)
                  elseif (state(i-1,j-1).eq.-1) then
c                     write(6,*) 'left diag 6->11, double GDP'		!added June 10, never told to go to dstate 11
                     dissocstate(i-1,j-1)=11						!added June 10
                     times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j-1))
                     times(ev(i-1,j-1,2))=times(ev(i-1,j-1,2))*GDP
                     call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)
                  else
                     write(6,*) 'left diag not state 1 or state -1'
                     stop
                  endif
               elseif ((dissocstate(i-1,j-1).eq.12).or.(dissocstate(i-1,j-1).eq.13)) then !dstate 6 goes to 11
c                  write(6,*) 'left diag 12/13->8'
                  dissocstate(i-1,j-1)=8
                  times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(i-1,j-1))
                  call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)
               elseif (dissocstate(i-1,j-1).eq.8) then
c                  write(6,*) 'already 8 at left diag, leave alone'
               else
                  write(6,*) 'dissocstate not handled for left diag',dissocstate(i-1,j-1)
                  stop
               endif
               ! now do across seam
c               write(6,*) 'eventually need to alter time for the lower seam neighb'
               if (j.ge.105) then 
c                  write(6,*) 'updating lower seam neighb'
               if (dissocstate(1,j-2).eq.3) then !dstate=3 goes to 5
                  dep(1,j-2)=7
                  dissocstate(1,j-2)=5
cccccccccccccccccccccccccccccccccccccccc                           
                  seammult(1,j-2)=1.0
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'                  
                  times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(1,j-2))
cccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                  addstate(1,j-2)=addstate(1,j-2)+1
c Special case, check 2 below                  
c                  write(6,*) 'Special case, check 2 below unless in template'
                  if (j.gt.105) then	!May 31: changed j-3 to j
                     if (dissocstate(1,j-3).eq.5) then
c                        write(6,*) 'dstate 5 -> 10 for ',1,j-3
                        dissocstate(1,j-3)=10
                        times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(1,j-3))
                        call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                     elseif (dissocstate(1,j-3).eq.6) then
c                        write(6,*) 'dstate 6 -> 11 for ',1,j-3
                        dissocstate(1,j-3)=11
                        times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(1,j-3))
                        call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                     elseif ((dissocstate(1,j-3).eq.12).or.(dissocstate(1,j-3).eq.13)) then
c                        write(6,*) 'dstate 12/13 -> 8 for ',1,j-3
                        dissocstate(1,j-3)=8
                        times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(1,j-3))
                        call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                     else
                        write(6,*) 'bad dstate for ',1,j-3,': ',dissocstate(1,j-3)
                        stop
                     endif
                  else
c                     write(6,*) '2 below is in template, dont touch'
                  endif
               elseif (dissocstate(1,j-2).eq.4) then !dstate=4 goes to 6
                  dep(1,j-2)=7
                  dissocstate(1,j-2)=6
cccccccccccccccccccccccccccccccccccccccc                           
                  seammult(1,j-2)=1.0
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'                   
                  times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(1,j-2))
cccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                  addstate(1,j-2)=addstate(1,j-2)+1
c Special case, check 2 below                  
c                  write(6,*) 'Special case, check 2 below unless in template'
                  if (j.gt.105) then		!May 31: changed j-3 to j
                     if (dissocstate(1,j-3).eq.5) then
c                        write(6,*) 'should be GDP'
                        if (state(1,j-3).eq.-1) then
c                           write(6,*) 'dstate 5 -> 11 for ',1,j-3
                           dissocstate(1,j-3)=11
                           times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(1,j-3))
                           call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                        else
                           write(6,*) 'bad dstate/state somewhere'
                           stop
                        endif
                     elseif (dissocstate(1,j-3).eq.6) then
c                        write(6,*) 'dstate 6 -> 11 for ',1,j-3
                        dissocstate(1,j-3)=11
                        times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(1,j-3))
c                        write(6,*) 'should be double GDP'
                        if ((state(1,j-3).eq.-1).and.(state(1,j-4).eq.-1)) then
                           times(ev(1,j-3,2))=times(ev(1,j-3,2))*GDP
                        else
                           write(6,*) 'bad dstate/state somewhere'
                           stop
                        endif
                        call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                     elseif ((dissocstate(1,j-3).eq.12).or.(dissocstate(1,j-3).eq.13)) then
c                        write(6,*) 'dstate 12/13 -> 8 for ',1,j-3
                        dissocstate(1,j-3)=8
                        times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(1,j-3))
                        call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                     else
                        write(6,*) 'bad dstate for ',1,j-3,': ',dissocstate(1,j-3)
                        stop
                     endif
                  else
c                     write(6,*) '2 below is in template, dont touch'
                  endif
               elseif (dissocstate(1,j-2).eq.5) then !dstate=5 goes to 12
                  dissocstate(1,j-2)=12
cccccccccccccccccccccccccccccccccccccccc                           
                  seammult(1,j-2)=1.0
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'                   
                  times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(1,j-2))
cccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                  addstate(1,j-2)=addstate(1,j-2)+1               
               elseif (dissocstate(1,j-2).eq.6) then !dstate=6 goes to 13
                  dissocstate(1,j-2)=13
cccccccccccccccccccccccccccccccccccccccc                           
                  seammult(1,j-2)=1.0
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'                   
                  times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(1,j-2))
cccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                  addstate(1,j-2)=addstate(1,j-2)+1               
               elseif ((dissocstate(1,j-2).eq.10).or.(dissocstate(1,j-2).eq.11)) then
                  dissocstate(1,j-2)=8
cccccccccccccccccccccccccccccccccccccccc                           
                  seammult(1,j-2)=1.0
c                  write(6,*) 'gaining full lateral contact, make seammult = 1'                   
                  times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                          K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                          K_all,k_ne,seammult(1,j-2))
cccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                  addstate(1,j-2)=addstate(1,j-2)+1               
               else
                  write(6,*) 'seam dstate ne 3,4,5,6,10,11: no sense',1,j-2,dissocstate(1,j-2)
                  stop
               endif
               
               endif
            endif
         else
            write(6,*) 'adding into not 8: weird',i,j,dissocstate(i,j)
            stop
         endif
         
c going to look and see if upper seam neighbor needs seam multiplier if not in template...
         if (state(1,j-1).ne.0) then
            if (j.gt.103) then
               if (state(i,j+1).eq.0) then
c                  write(6,*) 'upper seam neighbor has half neighbor: ',1,j-1
c                  write(6,*) 'update seammult'
                  seammult(1,j-1)=17.2
c                  seammult(1,j-1)=1.0		!to turn off
                  times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(1,j-1))
                  call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
               else
c                  write(6,*) 'gaining full lateral contact: ',1,j-1
c                  write(6,*) 'update seammult'
                  seammult(1,j-1)=1.0
                  times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,
     @                          GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                          K_all,k_ne,seammult(1,j-1))
                  call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
               endif
            else
c               write(6,*) 'upper seam neighbor in template, do nothing'
            endif
         else
c if upper seam neighbor not present and lower seam neighbor present then new addition should get seam multiplier updated.
            if (state(1,j-2).ne.0) then
c               write(6,*) 'new addition has half neighbor'
c               write(6,*) 'update seammult'
               seammult(i,j)=17.2	!update in get_evtime should occur below
c               seammult(i,j)=1.0		!to turn off
            else
c               write(6,*) 'do nothing for new addition seammult-wise'
            endif
         endif         
         
c		write(6,*) 'new dissociation: ',i,j
		totev=totev+1
		nev(i,j)=nev(i,j)+1
		if (nrecyc.eq.0) then
			xloc(totev)=i
			yloc(totev)=j
			ev(i,j,2)=totev
		else
			ev(i,j,2)=recyc(1)
			xloc(recyc(1))=i
			yloc(recyc(1))=j
			if (nrecyc.gt.1) then
				recyc(1)=recyc(nrecyc)
				call hpsort(nrecyc-1,recyc)
			endif
			nrecyc=nrecyc-1
	  	 endif
	  	
	  	 times(ev(i,j,2))=get_evtime(dissocstate(i,j),k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(i,j))

		  event(totev)=ev(i,j,2)
    	  revmap(ev(i,j,2))=totev
  		  call build_min_heap(event,revmap,times,totev)
  		  
c Start nucleotide exchange fun here...
c         write(6,*) 'check to see if subunit below needs hydrolysis event'
         if ((state(i,j-1).eq.1).and.(j.gt.103)) then
c            write(6,*) 'there is a new hydrolysis at site: ',i,j-1
            totev=totev+1
            nev(i,j-1)=nev(i,j-1)+1
            if (nrecyc.eq.0) then
               xloc(totev)=i
               yloc(totev)=j-1
               ev(i,j-1,3)=totev
            else
			   ev(i,j-1,3)=recyc(1)
			   xloc(recyc(1))=i
			   yloc(recyc(1))=j-1
			   if (nrecyc.gt.1) then
				   recyc(1)=recyc(nrecyc)
				   call hpsort(nrecyc-1,recyc)
			   endif
			   nrecyc=nrecyc-1
            endif
         
            times(ev(i,j-1,3))=get_evtime(7,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(i,j-1))

		     event(totev)=ev(i,j-1,3)
    	     revmap(ev(i,j-1,3))=totev
  			 call build_min_heap(event,revmap,times,totev)
  	     elseif ((state(i,j-1).eq.-1).and.(j.gt.103)) then
c  	        write(6,*) 'subunit below already hydrolyzed, do nothing for: ',i,j-1
       	 endif
c Stop nucleotide exchange fun here...       	 
       	 
      return
      end
C
C
C +++++
C
C
      subroutine SubFrom1(ntub,i,j,state,addstate,dissocstate,dep,ev,nev,
     @                    nrecyc,recyc,event,revmap,totev,times,k_on,
     @                    conc,GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,seammult,k_ne)
     
      implicit none
      
      integer ntub,i,j,nrecyc,totev,recyc(*)
      integer revmap(*),event(*)     
      integer dissocstate(13,*),addstate(13,*),state(13,*)
      integer nev(13,*),dep(13,*),ev(13,2000,*)
      double precision k_on,conc,GDP,K_lat,K_long,K_both,k_hyd,times(*) 
      double precision K_thr_long,K_thr_lat,K_all,k_ne
      double precision seammult(13,*)
      
      integer temph,tempv,tempd,temp,index,nremove
      double precision get_evtime
      logical qdebug
      
      integer lmax,ll
                  
c         write(6,*) 'dissociating from pf #1'
c         write(6,*) 'make seammult 1 at i,j no matter what'
         seammult(i,j)=1.0
         
         if (dissocstate(i,j).eq.2) then
c            write(6,*) 'dstate 2 from pf#1'
c            write(6,*) 'check above'
            if (state(i,j+1).eq.0) then
               if (addstate(i,j+1).ge.2) then
                  addstate(1,j+1)=addstate(1,j+1)-1
c                  write(6,*) 'empty above, more than 1 neighbor'
                  if (dissocstate(1,j+1).eq.5) then
                     dissocstate(1,j+1)=2
                  else
                     write(6,*) 'have not yet handled this check'
                     stop
                  endif
               elseif (addstate(i,j+1).eq.1) then
c                  write(6,*) 'empty above, 1 neighbor, remove event'
                  addstate(i,j+1) = addstate(i,j+1)-1
                  dissocstate(i,j+1)=0
                  if (ev(i,j+1,1).ne.0) then
c               if (qdebug) write(6,*) 'Lose Addition at : ',i,k
                     nrecyc = nrecyc+1
      		         recyc(nrecyc) = ev(i,j+1,1)
      		         index=revmap(ev(i,j+1,1))
      		         nev(i,j+1)=nev(i,j+1)-1
      		         ev(i,j+1,1)=0
      			  			
      		         temp=event(index)
	  		         event(index)=event(totev)
	  		         event(totev)=temp
	  		         revmap(event(totev))=totev
	  		         revmap(event(index))=index
	  		         times(event(totev))=1d15
                     totev=totev-1
	  		         call min_heapify(event,revmap,times,1,totev)
      		         call hpsort(nrecyc,recyc)
      		      endif
               else
                  write(6,*) 'pf#1 dissocstate=2, bad addstate'
                  stop
               endif
            else
               write(6,*) 'something above, change addstate and remove gtp hydro'
               stop
               addstate(i,j+1) = addstate(i,j+1)-1
               if (ev(i,j,3).ne.0) then
c            if (qdebug) write(6,*) 'Lose Hydrolysis at : ',i,j,ev(i,j,3)
                  nrecyc = nrecyc+1
      	          recyc(nrecyc) = ev(i,j,3)
      	          index=revmap(ev(i,j,3))
      	          nev(i,j)=nev(i,j)-1
      	          ev(i,j,3)=0
      	          call hpsort(nrecyc,recyc)
      	          temp=event(index)
	  	          event(index)=event(totev)
	  	          event(totev)=temp
	  	          revmap(event(totev))=totev
	  	          revmap(event(index))=index
	  	          times(event(totev))=1d15
c	  				       				do kk=1,totev+5
c         			write(6,*) 'times ',kk,times(event(kk)),event(kk),revmap(kk)
c      				end do            

                  totev=totev-1
	  	          call min_heapify(event,revmap,times,1,totev)      			  			
      	       endif
      	    endif
c      	    write(6,*) 'check below'
      	    if (j.eq.103) then
c      	       write(6,*) 'j=103, nothing to do below'
      	    else
c      	       write(6,*) 'j > 103, some work to do'
      	       if (state(i,j-1).eq.0) then
c      	          write(6,*) 'empty below, correct dstate'
      	          addstate(i,j-1)=addstate(i,j-1)-1
      	          if ((dissocstate(i,j-1).eq.5).or.(dissocstate(i,j-1).eq.6)) then	!changed June 10
c      	             write(6,*) 'make dissocstate go from 5 to 2'
      	             dissocstate(i,j-1) = 2
      	          elseif (dissocstate(i,j-1).eq.10) then
      	             dissocstate(i,j-1) = 5
      	          elseif (dissocstate(i,j-1).eq.11) then		!added June 10
      	             dissocstate(i,j-1) = 6
      	          elseif (dissocstate(i,j-1).eq.8) then
c      	             write(6,*) 'make dissocstate go from 8 to 5, test for seam neighbs?'
      	             if (state(13,j+1).ne.0) then
      	                write(6,*) 'something at lower seam neighbor'
      	                stop
      	             elseif (state(13,j+2).ne.0) then
      	                write(6,*) 'something at upper seam neighbor'
      	                stop
      	             else
c      	                write(6,*) 'nothing at seam neighbs'
      	                dissocstate(i,j-1) = 5
      	             endif
      	          else
      	             write(6,*) 'below not dstate 5/6/8/10/11'
      	             stop
      	          endif
      	       else
      	          write(6,*) 'occupied below, need to handle'
      	          stop
      	       endif
      	    endif
c      	    write(6,*) 'check seam neighbor'
c      	    write(6,*) 'the below logic is specific for dstate=2'
      	    if (state(2,j).ne.0) then
c      	       write(6,*) 'right neighb, check lefties now'
      	       if ( (state(13,j+1).ne.0).and.(state(13,j+2).ne.0) ) then
c      	          write(6,*) 'inconsistent configuration, stuff on both sides'
      	       elseif ((state(13,j+2).ne.0).and.(state(13,j+1).eq.0) ) then
      	          write(6,*) 'upper half seam neighbor, gotta go'
      	          stop
      	       else
c      	          write(6,*) 'nothing on seam side!'
c      	          write(6,*) 'only worry about removing possible lateral add'
c      	          write(6,*) 'since we are dtype=2, only remove lateral iff multiple dissoc'
      	          if ( (state(i,j+1).eq.0).and.(state(i,j-1).eq.0) ) then
c      	             write(6,*) 'singleton type 2, will not affect existing lateral add'
      	          else
      	             write(6,*) 'need to work out how to handle this'
      	             stop
      	          endif
c      	          if (addstate(13,j+1).eq.1) then
c      	             write(6,*) 'remove lateral add across seam'
c      	             addstate(13,j+1)=addstate(13,j+1)-1
c                     dissocstate(13,j+1)=0
c                     if (ev(13,j+1,1).ne.0) then
c                        if (qdebug) write(6,*) 'Lose Addition at : ',13,j+1
c                        nrecyc = nrecyc+1
c      		            recyc(nrecyc) = ev(13,j+1,1)
c      		            index=revmap(ev(13,j+1,1))
c      		            nev(13,j+1)=nev(13,j+1)-1
c      		            ev(13,j+1,1)=0
      			  			
c      		            temp=event(index)
c	  		            event(index)=event(totev)
c	  		            event(totev)=temp
c	  		            revmap(event(totev))=totev
c	  		            revmap(event(index))=index
c	  		            times(event(totev))=1d15
c                        totev=totev-1
c	  		            call min_heapify(event,revmap,times,1,totev)
c      		            call hpsort(nrecyc,recyc)
c      		         endif
c      	          elseif (addstate(13,j+1).eq.0) then
c      	             write(6,*) 'no add exists for lower seam, leave alone'
c      	          else
c      	             write(6,*) 'lower seam neighb has more than 1 neighb, remove one'
c      	             addstate(13,j+1)=addstate(13,j+1)-1
c      	          endif
c      	          if ((addstate(13,j+2).ne.0).or.(addstate(13,j+1).ne.0)) then
c      	             write(6,*) 'potential addstate trouble at seam check'
c      	          else
c      	             write(6,*) 'no seam addstates, no worries'
c      	          endif
      	       endif
      	    else
ccccccccccccccccccccccccccccccccccc      	    
c      	       write(6,*) 'neighbs all on seam side, just update seam multiplier'
      	       ! because i,j dstate was 2, seam neighbors should go from having a half neighbor
      	       ! to no neighbor
      	       if (state(13,j+1).ne.0) then
c      	          write(6,*) 'lower seam neighbor losing half neigbor, make seammult=1'
      	          seammult(13,j+1)=1.0
      	          times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+1))
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
               else
                  write(6,*) 'bad state for ',13,j+1
                  stop
               endif
               if (state(13,j+2).ne.0) then
c      	          write(6,*) 'upper seam neighbor losing half neigbor, make seammult=1'
      	          seammult(13,j+2)=1.0
      	          times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+2))
                  call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
               else
                  write(6,*) 'bad state for ',13,j+2
                  stop
               endif
cccccccccccccccccccccccccccccccccc               
      	    endif
      	    
c      	    write(6,*) 'check right neighbor'
      	    call CheckLatNeighb(i+1,j,state,addstate,ev,nrecyc,recyc,dissocstate,
     @                      event,revmap,times,totev,nev,qdebug,dep)


         elseif ((dissocstate(i,j).eq.3).or.(dissocstate(i,j).eq.4)) then
c            write(6,*) 'dissociating from pf#1, dstate=',dissocstate(i,j)
c            write(6,*) 'check above'
            if (state(i,j+1).eq.0) then
               if (addstate(i,j+1).ge.2) then
                  write(6,*) 'empty above, more than 1 neighbor, not possible?'
                  stop
               elseif (addstate(i,j+1).eq.1) then
c                  write(6,*) 'empty above, 1 neighbor, remove event'
                  addstate(i,j+1) = addstate(i,j+1)-1
                  dissocstate(i,j+1)=0
                  if (ev(i,j+1,1).ne.0) then
                     call RemoveAdditionEvent(i,j+1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
      		      endif
               else
                  write(6,*) 'pf#1 dissocstate=3/4, bad addstate'
                  stop
               endif
            else
c               write(6,*) 'something above, change addstate and remove gtp hydro'
c               write(6,*) 'wiping'
               addstate(i,j+1) = addstate(i,j+1)-1
               addstate(i,j)=addstate(i,j)-1 !correct for losing the above guy
               if (ev(i,j,3).ne.0) then
                  call RemoveHydroEvent(i,j,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)        		
      	       endif
               nremove=1
               call WipeFromSeam(i,j+1,nremove,ntub,dep,state,addstate,nrecyc,recyc,
     @                        ev,nev,dissocstate,event,revmap,totev,times,seammult)

      	    endif
c      	    write(6,*) 'check below'
      	    if (j.eq.103) then
c      	       write(6,*) 'j=103, nothing to do below'
      	    else
c      	       write(6,*) 'j > 103, some work to do'
      	       if (state(i,j-1).eq.0) then
c      	          write(6,*) 'empty below, correct dstate'
      	          addstate(i,j-1)=addstate(i,j-1)-1
      	          if (dissocstate(i,j-1).eq.5) then
c      	             write(6,*) 'make dissocstate go from 5 to 2'
      	             dissocstate(i,j-1) = 2
      	          elseif (dissocstate(i,j-1).eq.8) then
c      	             write(6,*) 'make dissocstate go from 8 to 5, test for seam neighbs?'
      	             if (state(13,j+1).ne.0) then
      	                write(6,*) 'something at lower seam neighbor'
      	                stop
      	             elseif (state(13,j+2).ne.0) then
      	                write(6,*) 'something at upper seam neighbor'
      	                stop
      	             else
c      	                write(6,*) 'nothing at seam neighbs'
      	                dissocstate(i,j-1) = 5
      	             endif
      	          else
      	             write(6,*) 'below not dstate 5/8'
      	             stop
      	          endif
      	       else
c      	          write(6,*) 'occupied below, need to handle'
c Start nucleotide exchange fun here...      	          
c      	          write(6,*) 'remove hydrolysis event if not hydrolyzed'
      	          if (state(i,j-1).eq.1) then
c      	             write(6,*) 'not hydrolyzed, remove event'
                     if (ev(i,j-1,3).ne.0) then
                        call RemoveHydroEvent(i,j-1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)        		
                     endif
                  else
c                     write(6,*) 'hydrolyzed, do nothing'
                  endif
c End nucleotide exchange fun here...                  
                  addstate(i,j-1)=addstate(i,j-1)-1
c      	          write(6,*) 'nothing else to do for vertical check?',i,j-1,addstate(i,j-1)
      	       endif
      	    endif
      	    
c Logic implemented above at line #10111
c      	    write(6,*) 'check seam neighbor'
c      	    write(6,*) 'the below logis is specific for dstate=3'
c      	    if (state(13,j+2).ne.0) then
c      	       write(6,*) 'upper half seam neighbor, gotta go'
c      	       stop
c      	    else
c      	       write(6,*) 'empty upper seam neighb, maybe correct dissocstate'
c      	       if (addstate(13,j+2).eq.0) then
c      	          write(6,*) 'no meaningful neighbors, nothing to do'
c      	       else
c      	          write(6,*) 'upper seam neighbor, do something'
c      	          if (state(i,j+1).eq.0) then
c      	             write(6,*) 'we are empty above -> lateral add not b/c of us'
c      	             write(6,*) 'leave upper neighb alone'
c      	          else
c      	             write(6,*) 'we are not empty above -> check if lateral add is b/c of us'
c      	             stop
c      	          endif
c      	       endif
c      	    endif

      	    if (state(13,j+1).ne.0) then
c      	       write(6,*) 'lower half seam neighbor, maybe correct dstate'
c      	       write(6,*) 'we are type=3, so we dont affect the seam neighbor TYPE'
c      	       write(6,*) 'ultimately, we should alter the rate just a bit to reflect the partial contact'
c      	       write(6,*) 'crashing here because there are actually things to change'
c      	       write(6,*) '12->5;13->6;5->3;6->4, otherwise error'
      	       addstate(13,j+1) = addstate(13,j+1)-1
      	       if (dissocstate(13,j+1).eq.2) then
      	          write(6,*) 'how can this be 2 and occupied?'
      	          stop
      	       elseif ((dissocstate(13,j+1).eq.5).or.(dissocstate(13,j+1).eq.6)) then
      	          if (dissocstate(13,j+1).eq.5) then
                     dissocstate(13,j+1)=3
                  elseif (dissocstate(13,j+1).eq.6) then
                     dissocstate(13,j+1)=4
                  else
                     write(6,*) 'dstate not 5 or 6 across seam, ',dissocstate(13,j+1)
                     stop
                  endif
ccccccccccccccccccccccccccc                  
c                  write(6,*) 'losing full lateral contact, seammult ne 1'
                  seammult(13,j+1)=17.2
c                  seammult(13,j+1)=1.0		!to turn off
c      		      write(6,*) 'resetting dissocstate to ',dissocstate(13,j+1)
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)   
                  if (dissocstate(13,j).eq.10) then
c                     write(6,*) 'special case, need to update below lower seam neighb'
                     dissocstate(13,j)=5
c      		         write(6,*) 'resetting dissocstate to ',dissocstate(13,j)
                     times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                     call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)   
                  elseif (dissocstate(13,j).eq.11) then
c                     write(6,*) 'special case, need to update below lower seam neighb'
                     if (state(13,j-1).eq.1) then
                        dissocstate(13,j)=5
c      		            write(6,*) 'resetting dissocstate to ',dissocstate(13,j)
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)   
                     elseif (state(13,j-1).eq.-1) then
                        dissocstate(13,j)=6
c      		            write(6,*) 'resetting dissocstate to ',dissocstate(13,j)
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                     else
                        write(6,*) 'neither 1 or -1 below 2 below?'
                        stop
                     endif
                  elseif (dissocstate(13,j).eq.8) then
                     if (state(13,j-1).eq.1) then
                        dissocstate(13,j)=12
c      		            write(6,*) 'resetting dissocstate to ',dissocstate(13,j)
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)   
                     elseif (state(13,j-1).eq.-1) then
                        dissocstate(13,j)=13
c      		            write(6,*) 'resetting dissocstate to ',dissocstate(13,j)
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)   
                     else
                        write(6,*) 'empty 2 below??'
                        stop
                     endif
                  else
                     write(6,*) 'not handled other dissocstates yet'
                     stop
                  endif
      	       elseif (dissocstate(13,j+1).eq.12) then
                  dissocstate(13,j+1)=5
ccccccccccccccccccccccccccc                  
c                  write(6,*) 'losing full lateral contact, seammult ne 1'
                  seammult(13,j+1)=17.2 
c                  seammult(13,j+1)=1.0		!to turn off
c      		      write(6,*) 'resetting dissocstate to ',dissocstate(13,j+1)
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)      	             	       
      	       elseif (dissocstate(13,j+1).eq.13) then
                  dissocstate(13,j+1)=6
ccccccccccccccccccccccccccc                  
c                  write(6,*) 'losing full lateral contact, seammult ne 1'
                  seammult(13,j+1)=17.2     
c                  seammult(13,j+1)=1.0		!to turn off
c      		      write(6,*) 'resetting dissocstate to ',dissocstate(13,j+1)
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)      	             	       
      	       elseif (dissocstate(13,j+1).eq.8) then
                  write(6,*) 'need to do tests for 10/11'
                  stop
      	       else
      	          write(6,*) 'dstate not 2,5,6,12,13,8'
      	          stop
      	       endif
      	    else
c      	       write(6,*) 'empty lower seam neighb, maybe correct dissocstate'
c Start nucleotide exchange fun here...      	       
      	       if (dissocstate(13,j+1).eq.6) then
                  addstate(13,j+1) = addstate(13,j+1)-1
      	          dissocstate(13,j+1)=4
      	       elseif (dissocstate(13,j+1).eq.5) then
                  addstate(13,j+1) = addstate(13,j+1)-1
      	          dissocstate(13,j+1)=3
      	       elseif (dissocstate(13,j+1).eq.2) then
      	          if (addstate(13,j+1).eq.1) then
c      	             write(6,*) 'remove addition event from here'
                     addstate(13,j+1) = addstate(13,j+1)-1
                     dissocstate(13,j+1)=0
                     if (ev(13,j+1,1).ne.0) then
c               if (qdebug) write(6,*) 'Lose Addition at : ',i,k
                        call RemoveAdditionEvent(13,j+1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
      		         endif
      		      else
c      		         write(6,*) 'more then 1 neighbor, decrement addstate and leave dstate alone'
      		         addstate(13,j+1)=addstate(13,j+1)-1
      		      endif
      	       elseif (dissocstate(13,j+1).eq.13) then
                  addstate(13,j+1) = addstate(13,j+1)-1
      	          dissocstate(13,j+1)=6
      	       elseif (dissocstate(13,j+1).eq.12) then
                  addstate(13,j+1) = addstate(13,j+1)-1
      	          dissocstate(13,j+1)=5
      	       elseif (dissocstate(13,j+1).eq.8) then
      	          write(6,*) 'how can this be an empty 8?'
      	          stop
      	       else
      	          write(6,*) 'need to treat rest of dstates',dissocstate(13,j+1)
      	          stop
      	       endif
c End nucleotide exchange fun here...   	       
      	    endif
      	    
c      	    write(6,*) 'check right neighbor'
      	    call CheckLatNeighb(i+1,j,state,addstate,ev,nrecyc,recyc,dissocstate,
     @                      event,revmap,times,totev,nev,qdebug,dep)

         elseif ((dissocstate(i,j).eq.5).or.(dissocstate(i,j).eq.6)) then
c            write(6,*) 'dissociating from type=5/6'

c            write(6,*) 'check above'
            if (state(i,j+1).eq.0) then
               if (addstate(i,j+1).ge.2) then
c                  write(6,*) 'empty above, more than 1 neighbor'
                  addstate(i,j+1)=addstate(i,j+1)-1
c Start nucleotide exchange fun here...                  
                  if ((dissocstate(1,j+1).eq.5).or.(dissocstate(1,j+1).eq.6)) then
                     dissocstate(1,j+1)=2
c End nucleotide exchange fun here...                     
                  else
                     write(6,*) 'have not yet handled this check'
                     stop
                  endif
               elseif (addstate(i,j+1).eq.1) then
c                  write(6,*) 'empty above, 1 neighbor, remove event'
                  addstate(i,j+1) = addstate(i,j+1)-1
                  dissocstate(i,j+1)=0
                  if (ev(i,j+1,1).ne.0) then
c               if (qdebug) write(6,*) 'Lose Addition at : ',i,k
                     call RemoveAdditionEvent(i,j+1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
      		      endif
               else
                  write(6,*) 'pf#1 dissocstate=5, bad addstate'
                  stop
               endif
            else
c Need to make sure we really do need to wipe with dstate 5/6.
c               write(6,*) 'first, check if something below'
               if (state(i,j-1).eq.0) then
c                  write(6,*) 'empty below'
c                  write(6,*) 'now check addstate'
                  if (addstate(i,j-1).eq.1) then
                     write(6,*) 'bad addstate for dstate 5/6'
                     stop
                  elseif (addstate(i,j-1).eq.2) then
c                     write(6,*) 'dont need to wipe'
c                     write(6,*) 'need to call SubLowLef later'
                  elseif (addstate(i,j-1).gt.2) then
                     write(6,*) 'need to horizontally wipe?'
                     stop
                  endif
               else
c                  write(6,*) 'something below'
c                  write(6,*) 'something above, change addstate and remove gtp hydro'
c                  write(6,*) 'wiping prob'
                  addstate(i,j+1) = addstate(i,j+1)-1
                  addstate(i,j)=addstate(i,j)-1 !correct for losing the above guy
                  if (ev(i,j,3).ne.0) then
                     call RemoveHydroEvent(i,j,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)        		
         	      endif
                  nremove=1
                  call WipeFromSeam(i,j+1,nremove,ntub,dep,state,addstate,nrecyc,recyc,
     @                        ev,nev,dissocstate,event,revmap,totev,times,seammult)
      	       endif
      	    endif
            if ((state(2,j).ne.0).and.(state(2,j-1).ne.0).and.(state(1,j-1).ne.0)) then					!changed so can include SubLowLef
c               write(6,*) 'diag is to the lower right, call SubUppLef'
               temph = dissocstate(i+1,j)
               tempv = dissocstate(i,j-1)
               tempd = dissocstate(i+1,j-1)
               call SubUppLef(dep,dissocstate,state,i+1,j,i,j-1,temph,tempv,tempd)
               addstate(i+1,j)=addstate(i+1,j)-1
               if (j.gt.103) addstate(i,j-1)=addstate(i,j-1)-1
               ! added above Aug 2
               if (temph.ne.dissocstate(i+1,j)) then
c                  write(6,*) 'new dissocstate for H-neighb'
                  dissocstate(i+1,j)=temph
c      		      write(6,*) 'resetting dissocstate of H-neighb to ',dissocstate(i+1,j),temph
                  times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(i+1,j))
c Need to add test for double GDP if dstate=11.
                  if (temph.eq.11) then
                     if ((state(i+1,j).eq.-1).and.(state(i+1,j-1).eq.-1)) then
c                        write(6,*) 'double GDP, recalculate times'
                        times(ev(i+1,j,2))=times(ev(i+1,j,2))*GDP
                     else
c                        write(6,*) 'single GDP, do nothing'
                     endif
                  endif
ccccccccccccccccccccccccccccccccccccccccccccccc
                  call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
               endif
               if (tempv.ne.dissocstate(i,j-1)) then
                  if (j.gt.103) then
c                     write(6,*) 'new dissocstate for V-neighb'
                     dissocstate(i,j-1)=tempv
c      		         write(6,*) 'resetting dissocstate of V-neighb to ',dissocstate(i,j-1)
                     times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(i,j-1))
                     call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)
                  else
c                     write(6,*)'on 1st row, leave 102 alone'
                  endif
               endif
               if (tempd.ne.dissocstate(i+1,j-1)) then
                  if (j.gt.103) then
c                     write(6,*) 'new dissocstate for D-neighb'
                     dissocstate(i+1,j-1)=tempd
c      		         write(6,*) 'resetting dissocstate of D-neighb to ',dissocstate(i+1,j-1)
                     times(ev(i+1,j-1,2))=get_evtime(dissocstate(i+1,j-1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(i+1,j-1))
c Need to add test for double GDP if dstate=11.
                     if (tempd.eq.11) then
                        if ((state(i+1,j-1).eq.-1).and.(state(i+1,j-2).eq.-1)) then
c                           write(6,*) 'double GDP, recalculate times'
                           times(ev(i+1,j-1,2))=times(ev(i+1,j-1,2))*GDP
                        else
c                           write(6,*) 'single GDP, do nothing'
                        endif
                     endif
ccccccccccccccccccccccccccccccccccccccccccccccc
                     call update(event,revmap,ev(i+1,j-1,2),times(ev(i+1,j-1,2)),times,totev)
                  else
c                     write(6,*)'on 1st row, leave 102 alone'
                  endif
               endif
c Start nucleotide exchange fun here...               
c      	       write(6,*) 'remove hydrolysis event if not hydrolyzed'
      	       if (state(i,j-1).eq.1) then
c      	          write(6,*) 'not hydrolyzed, remove event'
                  if (ev(i,j-1,3).ne.0) then
                     call RemoveHydroEvent(i,j-1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)        		
                  endif
               else
c                  write(6,*) 'hydrolyzed, do nothing'
               endif
c End nucleotide exchange fun here...      	       
      	    if (state(13,j+1).ne.0) then
c      	       write(6,*) 'lower half seam neighbor, maybe correct dstate'
               if ((dissocstate(13,j+1).eq.5).or.(dissocstate(13,j+1).eq.6)) then
c      	          write(6,*) 'dstate 5/6 goes to 3/4 across seam'
                  addstate(13,j+1) = addstate(13,j+1)-1
                  if (dissocstate(13,j+1).eq.5) then
      	             dissocstate(13,j+1)=3
      	          elseif (dissocstate(13,j+1).eq.6) then
      	             dissocstate(13,j+1)=4
      	          else
      	             write(6,*) 'dstate not 5 or 6 across seam??',dissocstate(13,j+1)
      	             stop
      	          endif
ccccccccccccccccccccccccccc                  
c                  write(6,*) 'losing full lateral contact, seammult ne 1'
                  seammult(13,j+1)=17.2 
c                  seammult(13,j+1)=1.0		!to turn off 
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)  
                  if (j.gt.102) then
c                     write(6,*) 'special case, check 2 below across seam'
                     if (dissocstate(13,j).eq.10) then
c                        write(6,*) 'dstate 2 below: 10->5'
      	                dissocstate(13,j)=5
                        times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                        call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                     elseif (dissocstate(13,j).eq.11) then
                        if (state(13,j-1).eq.1) then
c                           write(6,*) 'dstate 2 below: 11->5'
      	                   dissocstate(13,j)=5
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                        elseif (state(13,j-1).eq.-1) then
c                           write(6,*) 'dstate below: 11->6'
      	                   dissocstate(13,j)=6
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                        else
                           write(6,*) 'bad destate 2 below cross seam??'
                           stop
                        endif
                     elseif (dissocstate(13,j).eq.8) then
                        if (state(13,j-1).eq.1) then
c                           write(6,*) 'dstate 2 below: 8->12'
      	                   dissocstate(13,j)=12
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                        elseif (state(13,j-1).eq.-1) then
c                           write(6,*) 'dstate below: 8->13'
      	                   dissocstate(13,j)=13
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                        else
                           write(6,*) 'bad destate 2 below cross seam??'
                           stop
                        endif
                     else
                        write(6,*) 'dstate below is not 10,11,8'
                        stop
                     endif
                  endif
               elseif (dissocstate(13,j+1).eq.12) then
c      	          write(6,*) 'dstate 12 goes to 5 across seam'
                  addstate(13,j+1) = addstate(13,j+1)-1
      	          dissocstate(13,j+1)=5
ccccccccccccccccccccccccccc                  
c                  write(6,*) 'losing full lateral contact, seammult ne 1'
                  seammult(13,j+1)=17.2
c                  seammult(13,j+1)=1.0		!to turn off 
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                              
               elseif (dissocstate(13,j+1).eq.13) then
c      	          write(6,*) 'dstate 13 goes to 6 across seam'
                  addstate(13,j+1) = addstate(13,j+1)-1
      	          dissocstate(13,j+1)=6
ccccccccccccccccccccccccccc                  
c                  write(6,*) 'losing full lateral contact, seammult ne 1'
                  seammult(13,j+1)=17.2
c                  seammult(13,j+1)=1.0		!to turn off
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                              
               elseif (dissocstate(13,j+1).eq.8) then
                  addstate(13,j+1) = addstate(13,j+1)-1
c Adding code to check for dstate 10/11 and for single/double GDP.
      	          if ((state(13,j+1).eq.1).and.(state(13,j).eq.1)) then
c      	             write(6,*) 'dstate 8 goes to 10 across seam'      	             
      	             dissocstate(13,j+1)=10
ccccccccccccccccccccccccccc                  
c                     write(6,*) 'losing full lateral contact, seammult ne 1'
                     seammult(13,j+1)=17.2
c                     seammult(13,j+1)=1.0		!to turn off
                     times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccc     
                     call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                  elseif ((state(13,j+1).eq.-1).or.(state(13,j).eq.-1)) then
c      	             write(6,*) 'dstate 8 goes to 11 across seam'
c      	             write(6,*) 'check for single/double GDP'
      	             dissocstate(13,j+1)=11
ccccccccccccccccccccccccccc                  
c                     write(6,*) 'losing full lateral contact, seammult ne 1'
                     seammult(13,j+1)=17.2
c                     seammult(13,j+1)=1.0		!to turn off
                     times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+1))
ccccccccccccccccccccccccccc     
                     if ((state(13,j+1).eq.-1).and.(state(13,j).eq.-1)) then
c                        write(6,*) 'double GDP, recalculate times'
                        times(ev(13,j+1,2))=times(ev(13,j+1,2))*GDP
                     else
c                        write(6,*) 'single GDP, do nothing'
                     endif
                     call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                  else
                     write(6,*) 'bad state for ',13,j+1,'or ',13,j
                     stop
                  endif
               else
                  write(6,*) 'dstate not 5,6,12,13,8 across seam'
                  stop
               endif
      	    else
c      	       write(6,*) 'empty lower seam neighb, maybe correct dissocstate'
c Start nucleotide exchange fun here...      	       
      	       if (dissocstate(13,j+1).eq.8) then
      	          if (state(13,j).eq.1) then
c      	             write(6,*) 'make it go from 8->5, dbl check this is ok'
                     addstate(13,j+1) = addstate(13,j+1)-1
      	             dissocstate(13,j+1)=5
      	          elseif (state(13,j).eq.-1) then
c      	             write(6,*) 'goes from 8->6'
      	             addstate(13,j+1) = addstate(13,j+1)-1
      	             dissocstate(13,j+1)=6
      	          else
      	             write(6,*) 'bad state for: ',13,j
      	             stop
      	          endif
      	       elseif (dissocstate(13,j+1).eq.6) then
                  addstate(13,j+1) = addstate(13,j+1)-1
      	          dissocstate(13,j+1)=4
      	       elseif (dissocstate(13,j+1).eq.5) then
                  addstate(13,j+1) = addstate(13,j+1)-1
      	          dissocstate(13,j+1)=3
      	       elseif (dissocstate(13,j+1).eq.13) then
                  addstate(13,j+1) = addstate(13,j+1)-1
      	          dissocstate(13,j+1)=6
      	       elseif (dissocstate(13,j+1).eq.12) then
                  addstate(13,j+1) = addstate(13,j+1)-1
      	          dissocstate(13,j+1)=5
      	       elseif (dissocstate(13,j+1).eq.2) then
      	          if (addstate(13,j+1).eq.1) then
c      	             write(6,*) 'remove addition event from here'
                     addstate(13,j+1) = addstate(13,j+1)-1
                     dissocstate(13,j+1)=0
                     if (ev(13,j+1,1).ne.0) then
c               if (qdebug) write(6,*) 'Lose Addition at : ',i,k
                        call RemoveAdditionEvent(13,j+1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
      		         endif
      		      else
c      		         write(6,*) 'more then one neigb at dstate 2, leave alone'
      		         addstate(13,j+1)=addstate(13,j+1)-1
      		      endif
      	       elseif (dissocstate(13,j+1).eq.0) then
c      	          write(6,*) 'no addition event, nothing to do'
      	       else
      	          write(6,*) 'need to treat rest of dstates'
      	          stop
      	       endif
c Stop nucleotide exchange fun here...      	       
            endif
c Now SubLowLef inclusion...            
            elseif ((state(2,j+1).ne.0).and.(state(2,j).ne.0).and.(state(1,j+1).ne.0)) then			!now SubLowLef
c               write(6,*) 'diag is to the upper right, call SubLowLef'
               temph = dissocstate(i+1,j)
               tempv = dissocstate(i,j+1)
               tempd = dissocstate(i+1,j+1)
               call SubLowLef(dep,dissocstate,state,i+1,j,i,j+1,temph,tempv,tempd)
               addstate(i+1,j)=addstate(i+1,j)-1
               addstate(i,j+1)=addstate(i,j+1)-1
               if (temph.ne.dissocstate(i+1,j)) then
c                  write(6,*) 'new dissocstate for H-neighb'
                  dissocstate(i+1,j)=temph
c      		      write(6,*) 'resetting dissocstate of H-neighb to ',dissocstate(i+1,j),temph
                  times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(i+1,j))
c Need to add test for double GDP if dstate=11.
                  if (temph.eq.11) then
                     if ((state(i+1,j).eq.-1).and.(state(i+1,j-1).eq.-1)) then
c                        write(6,*) 'double GDP, recalculate times'
                        times(ev(i+1,j,2))=times(ev(i+1,j,2))*GDP
                     else
c                        write(6,*) 'single GDP, do nothing'
                     endif
                  endif
ccccccccccccccccccccccccccccccccccccccccccccccc
                  call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
               endif
               if (tempv.ne.dissocstate(i,j+1)) then
c                  write(6,*) 'new dissocstate for V-neighb'
                  dissocstate(i,j+1)=tempv
c      	          write(6,*) 'resetting dissocstate of V-neighb to ',dissocstate(i,j+1)
                  times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(i,j+1))
                  call update(event,revmap,ev(i,j+1,2),times(ev(i,j+1,2)),times,totev)
               endif
               if (tempd.ne.dissocstate(i+1,j+1)) then
c                  write(6,*) 'new dissocstate for D-neighb'
                  dissocstate(i+1,j+1)=tempd
c      		      write(6,*) 'resetting dissocstate of D-neighb to ',dissocstate(i+1,j+1)
                  times(ev(i+1,j+1,2))=get_evtime(dissocstate(i+1,j+1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(i+1,j+1))
c Need to add test for double GDP if dstate=11.
                  if (tempd.eq.11) then
                     if ((state(i+1,j+1).eq.-1).and.(state(i+1,j).eq.-1)) then
c                        write(6,*) 'double GDP, recalculate times'
                        times(ev(i+1,j+1,2))=times(ev(i+1,j+1,2))*GDP
                     else
c                        write(6,*) 'single GDP, do nothing'
                     endif
                  endif
ccccccccccccccccccccccccccccccccccccccccccccccc
                  call update(event,revmap,ev(i+1,j+1,2),times(ev(i+1,j+1,2)),times,totev)
               endif
      	       if (state(13,j+1).ne.0) then
         	      write(6,*) 'should be no change for lower seam neighbor'
         	      write(6,*) 'possible recalculation for faster time (half neighbor less)'
      	       else
c      	          write(6,*) 'empty lower seam neighbor'
c      	          write(6,*) 'should be no change for lower seam neighbor'
               endif
               
c               write(6,*) 'may need to check upper seam neighbor'
               if (state(13,j+2).ne.0) then
c                  write(6,*) 'upper seam neighbor is present'
                  if (dissocstate(13,j+2).eq.2) then
                     if (addstate(13,j+2).eq.1) then
                        write(6,*) 'dstate=2 , addstate=1'
                        write(6,*) 'need to wipe ',13,j+2,'?'
                        stop
                     elseif (addstate(13,j+2).eq.2) then
c                        write(6,*) 'dstate=2 , addstate=2'
c                        write(6,*) 'update addstate for ',13,j+2
                        addstate(13,j+2)=addstate(13,j+2)-1
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+2)=17.2
c                        seammult(13,j+2)=1.0		!to turn off
                        times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+2))
                        call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
cccccccccccccccccccccccccccccc                        
                     else
                        write(6,*) 'bad addstate/dstate for ',13,j+2
                        stop
                     endif
cccccccccccccccccccccccccccccc                     
                  elseif ((dissocstate(13,j+2).eq.3).or.(dissocstate(13,j+2).eq.4)) then
c                     write(6,*) 'losing full lateral contact, seammult ne 1'
                     seammult(13,j+2)=17.2
c                     seammult(13,j+2)=1.0		!to turn off
                     times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+2))
                     call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
cccccccccccccccccccccccccccccc                     
                  elseif (dissocstate(13,j+2).eq.5) then
c                     write(6,*) 'dstate=5, make sure nothing below ',13,j+2             
                     if (state(13,j+1).eq.0) then
c                        write(6,*) 'dstate 5 -> 3, should be slow 3'
                        addstate(13,j+2)=addstate(13,j+2)-1
                        dissocstate(13,j+2)=3
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+2)=17.2
c                        seammult(13,j+2)=1.0		!to turn off
                        times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+2))
cccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                     else
                        write(6,*) 'bad dstate somewhere?'
                        stop
                     endif
                  elseif (dissocstate(13,j+2).eq.6) then
c                     write(6,*) 'dstate=6, make sure nothing below ',13,j+2             
                     if (state(13,j+1).eq.0) then
c                        write(6,*) 'dstate 6 -> 4, should be slow 4'
                        addstate(13,j+2)=addstate(13,j+2)-1
                        dissocstate(13,j+2)=4
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+2)=17.2
c                        seammult(13,j+2)=1.0		!to turn off
                        times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+2))
cccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                     else
                        write(6,*) 'bad dstate somewhere?'
                        stop
                     endif
                  elseif (dissocstate(13,j+2).eq.12) then
c                     write(6,*) 'dstate=12, make sure nothing below ',13,j+2
                     if (state(13,j+1).eq.0) then
c                        write(6,*) 'dstate 12 -> 5, should be slow 5'
                        addstate(13,j+2)=addstate(13,j+2)-1
                        dissocstate(13,j+2)=5
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+2)=17.2
c                        seammult(13,j+2)=1.0		!to turn off
                        times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+2))
cccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                     else
                        write(6,*) 'bad dstate somewhere?'
                        stop
                     endif
                  elseif (dissocstate(13,j+2).eq.13) then
c                     write(6,*) 'dstate=13, make sure nothing below ',13,j+2
                     if (state(13,j+1).eq.0) then
c                        write(6,*) 'dstate 13 -> 6, should be slow 6'
                        addstate(13,j+2)=addstate(13,j+2)-1
                        dissocstate(13,j+2)=6
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+2)=17.2
c                        seammult(13,j+2)=1.0		!to turn off
                        times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j+2))
cccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                     else
                        write(6,*) 'bad dstate somewhere?'
                        stop
                     endif
                  else
                     write(6,*) 'bad dissocstate for ',13,j+2
                     stop
                  endif
               else
c                  write(6,*) 'upper seam neighbor is not present'
                  if (dissocstate(13,j+2).eq.2) then
                     if (addstate(13,j+2).eq.1) then
c                        write(6,*) 'dstate=2 , addstate=1'
c                        write(6,*) 'remove event'
                        addstate(13,j+2)=0
                        dissocstate(13,j+2)=0
                        call RemoveAdditionEvent(13,j+2,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
                     elseif (addstate(13,j+2).eq.2) then
c                        write(6,*) 'dstate=2 , addstate=2'
c                        write(6,*) 'update addstate for ',13,j+2
                        addstate(13,j+2)=addstate(13,j+2)-1
                     else
                        write(6,*) 'bad addstate/dstate for ',13,j+2
                        stop
                     endif
                  elseif (dissocstate(13,j+2).eq.5) then
c                     write(6,*) 'dstate 5 -> 3'
                     addstate(13,j+2)=addstate(13,j+2)-1
                     dissocstate(13,j+2)=3
                  elseif (dissocstate(13,j+2).eq.12) then
c                     write(6,*) 'dstate 12 -> 5'
                     addstate(13,j+2)=addstate(13,j+2)-1
                     dissocstate(13,j+2)=5
                  else
                     write(6,*) 'bad dissocstate for ',13,j+2
                     stop
                  endif
               endif
            else
c               write(6,*) 'diag is across the seam, need to work out'
      	       call CheckLatNeighb(i+1,j,state,addstate,ev,nrecyc,recyc,dissocstate,
     @                      event,revmap,times,totev,nev,qdebug,dep)
c               write(6,*) 'check below'
c                  write(6,*) 'fixing dstate for j-1'
               if (j.gt.103) then																	!Was originally (j.gt.102)
                  addstate(i,j-1)=addstate(i,j-1)-1
                  if (dissocstate(i,j-1).eq.10) then
                        dissocstate(i,j-1)=5
c      		            write(6,*) 'resetting dissocstate of lower to ',dissocstate(i,j-1)
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                     
                  elseif (dissocstate(i,j-1).eq.11) then !if we are 5 and below is 11, test
                        if (state(i,j-2).eq.1) then
                           dissocstate(i,j-1)=5
c      		               write(6,*) 'resetting dissocstate of lower to ',dissocstate(i,j-1)
                           times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i,j-1))
                           call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev) 
                        elseif (state(i,j-2).eq.-1) then
                           dissocstate(i,j-1)=6
c      		               write(6,*) 'resetting dissocstate of lower to ',dissocstate(i,j-1)
                           times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i,j-1))
                           call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)
                        else
                           write(6,*) 'empty below?'
                           stop
                        endif
                  elseif (dissocstate(i,j-1).eq.8) then
                     if (state(i,j-2).eq.1) then
                        dissocstate(i,j-1)=12
c      		            write(6,*) 'resetting dissocstate of lower to ',dissocstate(i,j-1)
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                     
                     elseif (state(i,j-2).eq.-1) then
                        dissocstate(i,j-1)=13
c      		            write(6,*) 'resetting dissocstate of lower to ',dissocstate(i,j-1)
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                     
                     else
                        write(6,*) 'empty below ??'
                        stop
                     endif
                  else
                     write(6,*) 'dstate below not 10,11,8'
                     stop
                  endif
               else
c                  write(6,*) 'do not mess with template!!!'
               endif
c               write(6,*) 'now work across seam'

                     if (dissocstate(13,j+1).eq.5) then
                        addstate(13,j+1)=addstate(13,j+1)-1
                        dissocstate(13,j+1)=3
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+1)=17.2
c                        seammult(13,j+1)=1.0		!to turn off
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
c                        write(6,*) 'special case, check 2 below across seam if not in template'
                        if (j.gt.102) then
                           if (dissocstate(13,j).eq.10) then
c                              write(6,*) 'dstate 2 below: 10->5'
         	                  dissocstate(13,j)=5
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                           elseif (dissocstate(13,j).eq.11) then
                              if (state(13,j-1).eq.1) then
c                                 write(6,*) 'dstate 2 below: 11->5'
      	                         dissocstate(13,j)=5
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              elseif (state(13,j-1).eq.-1) then
c                                 write(6,*) 'dstate below: 11->6'
      	                         dissocstate(13,j)=6
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              else
                                 write(6,*) 'bad destate 2 below cross seam??'
                                 stop
                              endif
                           elseif (dissocstate(13,j).eq.8) then
                              if (state(13,j-1).eq.1) then
c                                 write(6,*) 'dstate 2 below: 8->12'
      	                         dissocstate(13,j)=12
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              elseif (state(13,j-1).eq.-1) then
c                                 write(6,*) 'dstate below: 8->13'
      	                         dissocstate(13,j)=13
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              else
                                 write(6,*) 'bad dstate 2 below cross seam??'
                                 stop
                              endif
                           else
                              write(6,*) 'dstate below is not 10,11,8'
                              stop
                           endif
                        else
c                           write(6,*) '2 below is in template, dont touch'
                        endif
                        !checking upper seam neighbor to see if seam mult needs to be changed...
                        if (state(13,j+2).ne.0) then
                           if ((dissocstate(13,j+2).eq.3).or.(dissocstate(13,j+2).eq.4)) then
c                              write(6,*) 'losing half neighbor at: ',13,j+2,'. Need to make seammult=1.'
                              seammult(13,j+2)=1.0
                              times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+2))
                              call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                           else
                              write(6,*) 'bad dissocstate?'
                              stop
                           endif
                        else
c                           write(6,*) 'do nothing for upper seam neighbor: ',13,j+2
                        endif
                     elseif (dissocstate(13,j+1).eq.6) then
                        addstate(13,j+1)=addstate(13,j+1)-1
                        dissocstate(13,j+1)=4
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+1)=17.2
c                        seammult(13,j+1)=1.0		!to turn off
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
c                        write(6,*) 'special case, check 2 below across seam if not in template'
                        if (j.gt.102) then 
                           if (dissocstate(13,j).eq.10) then
c                              write(6,*) 'dstate 2 below: 10->5'
         	                  dissocstate(13,j)=5
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                           elseif (dissocstate(13,j).eq.11) then
                              if (state(13,j-1).eq.1) then
c                                 write(6,*) 'dstate 2 below: 11->5'
      	                         dissocstate(13,j)=5
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              elseif (state(13,j-1).eq.-1) then
c                                 write(6,*) 'dstate below: 11->6'
      	                         dissocstate(13,j)=6
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              else
                                 write(6,*) 'bad destate 2 below cross seam??'
                                 stop
                              endif
                           elseif (dissocstate(13,j).eq.8) then
                              if (state(13,j-1).eq.1) then
c                                 write(6,*) 'dstate 2 below: 8->12'
      	                         dissocstate(13,j)=12
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              elseif (state(13,j-1).eq.-1) then
c                                 write(6,*) 'dstate below: 8->13'
      	                         dissocstate(13,j)=13
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              else
                                 write(6,*) 'bad destate 2 below cross seam??'
                                 stop
                              endif
                           else
                              write(6,*) 'dstate below is not 10,11,8'
                              stop
                           endif
                        else
c                           write(6,*) '2 below in template, dont touch'
                        endif
                        !checking upper seam neighbor to see if seam mult needs to be changed...
                        if (state(13,j+2).ne.0) then
                           if ((dissocstate(13,j+2).eq.3).or.(dissocstate(13,j+2).eq.4)) then
c                              write(6,*) 'losing half neighbor at: ',13,j+2,'. Need to make seammult=1.'
                              seammult(13,j+2)=1.0
                              times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+2))
                              call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                           else
                              write(6,*) 'bad dissocstate?'
                              stop
                           endif
                        else
c                           write(6,*) 'do nothing for upper seam neighbor: ',13,j+2
                        endif
c Dstate 10/11 can occur...
                     elseif (dissocstate(13,j+1).eq.10) then
                        addstate(13,j+1)=addstate(13,j+1)-1
                        dissocstate(13,j+1)=3
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+1)=17.2
c                        seammult(13,j+1)=1.0		!to turn off
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                        !added May 27: checking 2 below...
c                        write(6,*) 'removing next to dstate 10, need to look 2 below'
                        if (dissocstate(13,j).eq.8) then
                           if (state(13,j-1).eq.1) then
                              dissocstate(13,j)=12
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           elseif (state(13,j-1).eq.-1) then
                              dissocstate(13,j)=13
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           else
                              write(6,*) 'bad state for: ',13,j-1
                              stop
                           endif
                        elseif (dissocstate(13,j).eq.10) then
                           dissocstate(13,j)=5
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                        elseif (dissocstate(13,j).eq.11) then
                           if (state(13,j-1).eq.1) then		!May 31: changed dissocstate to state
                              dissocstate(13,j)=5
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           elseif (state(13,j-1).eq.-1) then
                              dissocstate(13,j)=6
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           else
                              write(6,*) 'bad state for: ',13,j-1
                              stop
                           endif
                        else
c                           write(6,*) 'not dstate 8/10/11 at 2 below'
                        endif
                     elseif (dissocstate(13,j+1).eq.11) then
                        addstate(13,j+1)=addstate(13,j+1)-1
                        if (state(13,j).eq.1) then
                           dissocstate(13,j+1)=3
cccccccccccccccccccccccccccccc                        
c                           write(6,*) 'losing full lateral contact, seammult ne 1'
                           seammult(13,j+1)=17.2
c                           seammult(13,j+1)=1.0		!to turn off
c                           write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                           times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                        elseif (state(13,j).eq.-1) then
                           dissocstate(13,j+1)=4
cccccccccccccccccccccccccccccc                        
c                           write(6,*) 'losing full lateral contact, seammult ne 1'
                           seammult(13,j+1)=17.2
c                           seammult(13,j+1)=1.0		!to turn off
c                           write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                           times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                        else
                           write(6,*) 'bad state for ',13,j
                           stop
                        endif
                        !added May 27: checking 2 below...
c                        write(6,*) 'removing next to dstate 11, need to look 2 below'
                        if (dissocstate(13,j).eq.8) then
                           if (state(13,j-1).eq.1) then
                              dissocstate(13,j)=12
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           elseif (state(13,j-1).eq.-1) then
                              dissocstate(13,j)=13
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           else
                              write(6,*) 'bad state for: ',13,j-1
                              stop
                           endif
                        elseif (dissocstate(13,j).eq.10) then
                           dissocstate(13,j)=5
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                        elseif (dissocstate(13,j).eq.11) then
                           if (state(13,j-1).eq.1) then		!May 31: changed dissocstate to state
                              dissocstate(13,j)=5
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           elseif (state(13,j-1).eq.-1) then
                              dissocstate(13,j)=6
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           else
                              write(6,*) 'bad state for: ',13,j-1
                              stop
                           endif
                        else
c                           write(6,*) 'not dstate 8/10/11 at 2 below'
                        endif
                     elseif (dissocstate(13,j+1).eq.12) then
                        addstate(13,j+1)=addstate(13,j+1)-1
                        dissocstate(13,j+1)=5
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+1)=17.2
c                        seammult(13,j+1)=1.0		!to turn off
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                        !checking upper seam neighbor to see if seam mult needs to be changed...
                        if (state(13,j+2).ne.0) then
                           if ((dissocstate(13,j+2).eq.3).or.(dissocstate(13,j+2).eq.4)) then
c                              write(6,*) 'losing half neighbor at: ',13,j+2,'. Need to make seammult=1.'
                              seammult(13,j+2)=1.0
                              times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+2))
                              call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                           else
                              write(6,*) 'bad dissocstate?'
                              stop
                           endif
                        else
c                           write(6,*) 'do nothing for upper seam neighbor: ',13,j+2
                        endif
                     elseif (dissocstate(13,j+1).eq.13) then
                        addstate(13,j+1)=addstate(13,j+1)-1
                        dissocstate(13,j+1)=6
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+1)=17.2
c                        seammult(13,j+1)=1.0		!to turn off
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                        !checking upper seam neighbor to see if seam mult needs to be changed...
                        if (state(13,j+2).ne.0) then
                           if ((dissocstate(13,j+2).eq.3).or.(dissocstate(13,j+2).eq.4)) then
c                              write(6,*) 'losing half neighbor at: ',13,j+2,'. Need to make seammult=1.'
                              seammult(13,j+2)=1.0
                              times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+2))
                              call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                           else
                              write(6,*) 'bad dissocstate?'
                              stop
                           endif
                        else
c                           write(6,*) 'do nothing for upper seam neighbor: ',13,j+2
                        endif
                     elseif (dissocstate(13,j+1).eq.8) then
                        addstate(13,j+1)=addstate(13,j+1)-1
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+1)=17.2
c                        seammult(13,j+1)=1.0		!to turn off
cccccccccccccccccccccccccccccc                        
                        
c Needs to be a special case that determines if subunit goes to dstate 5/6.
                        if (state(12,j+2).eq.0) then												!State of this coordinate
c                           write(6,*) 'space is empty: ',12,j+2										!determines if dstate goes
c                           write(6,*) 'special dstate 8 change for ',13,j+1							!to 5/6 or 10/11
                           if (state(13,j).eq.1) then
c                              write(6,*) 'dstate 8 -> 5, should be slow, need to recalculate'
                              dissocstate(13,j+1)=5
                              times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                              call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                           elseif (state(13,j).eq.-1) then
c                              write(6,*) 'dstate 8 -> 6, should be slow, need to recalculate'
                              dissocstate(13,j+1)=6
                              times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                              call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                           else
                              write(6,*) 'bad state for vertical subunit: ',13,j
                              stop
                           endif
                        else                        
                        
                           if ((state(13,j+1).eq.1).and.(state(13,j).eq.1)) then
                              dissocstate(13,j+1)=10
c      		                  write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                              times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                              call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                           elseif ((state(13,j+1).eq.1).and.(state(13,j).eq.-1)) then
                              dissocstate(13,j+1)=11
c      		                  write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                              times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                              call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                           elseif ((state(13,j+1).eq.-1).and.(state(13,j).eq.1)) then
                              dissocstate(13,j+1)=11
c      		                  write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                              times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                              call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                           elseif ((state(13,j+1).eq.-1).and.(state(13,j).eq.-1)) then
c                              write(6,*) 'double GDP at 8 across seam, need to treat'
                              dissocstate(13,j+1)=11
c      		                  write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                              times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                              times(ev(13,j+1,2))=GDP*times(ev(13,j+1,2))
                              call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                           else
                              write(6,*) 'bad nt states across seam'
                              stop
                           endif
                        endif
                        !checking upper seam neighbor to see if seam mult needs to be changed...
c                        write(6,*) 'check to see if upper seam neighbor needs seammult updated'
                        if (state(13,j+2).ne.0) then
                           if ((dissocstate(13,j+2).eq.5).or.(dissocstate(13,j+2).eq.6).or.
     @                        (dissocstate(13,j+2).eq.10).or.(dissocstate(13,j+2).eq.11)) then
c                              write(6,*) 'losing half neighbor at: ',13,j+2,'. Need to make seammult=1.'
                              seammult(13,j+2)=1.0
                              times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+2))
                              call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                           elseif ((dissocstate(13,j+2).eq.3).or.(dissocstate(13,j+2).eq.4).or.
     @                            (dissocstate(13,j+2).eq.12).or.(dissocstate(13,j+2).eq.13)) then
c                              write(6,*) 'if seammult not 1 already, make 1'
                              seammult(13,j+2)=1.0
                              times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+2))
                              call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                           else
                              write(6,*) 'bad dissocstate: ',dissocstate(13,j+2)
                              write(6,*) 'Printing configuration'
      			write(6,'(13A)') '  1 ',' 2 ',' 3 ',' 4 ',' 5 ',' 6 ',' 7 ',
     @                     ' 8 ',' 9 ',' 10',' 11',' 12',' 13'
            lmax = int(ntub/13)+112
         	do ll=lmax,102,-1
            	write(6,'(13I3)') state(1,ll),state(2,ll),state(3,ll),
     @ 	state(4,ll),state(5,ll),state(6,ll),state(7,ll),state(8,ll),
     @ 	state(9,ll),state(10,ll),state(11,ll),state(12,ll),state(13,ll)
       	 end do
       	 write(6,*) ''
       	  do ll=lmax,102,-1
     		write(6,'(13I3)') dissocstate(1,ll),dissocstate(2,ll),
     @		dissocstate(3,ll),
     @ 		dissocstate(4,ll),dissocstate(5,ll),dissocstate(6,ll),
     @		dissocstate(7,ll),
     @ 		dissocstate(8,ll),dissocstate(9,ll),dissocstate(10,ll),
     @		dissocstate(11,ll),
     @ 		dissocstate(12,ll),dissocstate(13,ll)
          end do
                              stop
                           endif
                        else
                           write(6,*) 'bad state for: ',13,j+2
                           stop
                        endif
                     else
                        write(6,*) 'have not handled this dtstate yet',dissocstate(13,j+1)
                        stop
                     endif
c Start nucleotide exchange fun here...                     
c      	       write(6,*) 'remove hydrolysis event if not hydrolyzed'
      	       if (state(i,j-1).eq.1) then
c      	          write(6,*) 'not hydrolyzed, remove event'
                  if (ev(i,j-1,3).ne.0) then
                     call RemoveHydroEvent(i,j-1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)        		
                  endif
               else
c                  write(6,*) 'hydrolyzed, do nothing'
               endif
c End nucleotide exchange fun here...

            endif

c New code for dissociating from dstate 10/11            
         elseif ((dissocstate(i,j).eq.10).or.(dissocstate(i,j).eq.11)) then
c            write(6,*) 'dissociating from dstate 10/11'
            
c            write(6,*) 'check above, something should be there'
            if (state(i,j+1).ne.0) then
c               write(6,*) 'subunit above: ',i,j+1
               
               addstate(i,j+1)=addstate(i,j+1)-1
               if ((dissocstate(i,j+1).eq.5).or.(dissocstate(i,j+1).eq.6)) then
c                  write(6,*) 'dstate 5/6 -> 2 for ',i,j+1
                  dissocstate(i,j+1)=2
                  times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j+1))
                  call update(event,revmap,ev(i,j+1,2),times(ev(i,j+1,2)),times,totev)  
               elseif (dissocstate(i,j+1).eq.10) then
c                  write(6,*) 'dstate 10 -> 5 for ',i,j+1
                  dissocstate(i,j+1)=5
                  times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j+1))
                  call update(event,revmap,ev(i,j+1,2),times(ev(i,j+1,2)),times,totev)  
               elseif (dissocstate(i,j+1).eq.11) then
                  if (state(i,j+1).eq.1) then
c                     write(6,*) 'dstate 11 -> 5 for ',i,j+1
                     dissocstate(i,j+1)=5
                     times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j+1))
                     call update(event,revmap,ev(i,j+1,2),times(ev(i,j+1,2)),times,totev)  
                  elseif (state(i,j+1).eq.-1) then
c                     write(6,*) 'dstate 11 -> 6 for ',i,j+1
                     dissocstate(i,j+1)=6
                     times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j+1))
                     call update(event,revmap,ev(i,j+1,2),times(ev(i,j+1,2)),times,totev)  
                  else
                     write(6,*) 'bad state for ',i,j+1
                     stop
                  endif
               elseif (dissocstate(i,j+1).eq.8) then
                  if (state(i,j+1).eq.1) then
c                     write(6,*) 'dstate 8 -> 12 for ',i,j+1
                     dissocstate(i,j+1)=12
                     times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j+1))
                     call update(event,revmap,ev(i,j+1,2),times(ev(i,j+1,2)),times,totev)  
                  elseif (state(i,j+1).eq.-1) then
c                     write(6,*) 'dstate 8 -> 13 for ',i,j+1
                     dissocstate(i,j+1)=13
                     times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j+1))
                     call update(event,revmap,ev(i,j+1,2),times(ev(i,j+1,2)),times,totev)  
                  else
                     write(6,*) 'bad state for ',i,j+1
                     stop
                  endif
               else
                  write(6,*) 'bad dstate/dstate not tested for ',i,j+1,': ',dissocstate(i,j+1)
                  stop
               endif
            else
               write(6,*) 'bad state for ',i,j+1
               stop
            endif
            
c            write(6,*) 'check below if not part of template'
            if (j.gt.103) then
c               write(6,*) 'not part of template'
               addstate(i,j-1)=addstate(i,j-1)-1
               if (state(i,j-1).ne.0) then
                  if (dissocstate(i,j-1).eq.10) then
c                     write(6,*) 'dstate 10 -> 5 for  ',i,j-1
                     dissocstate(i,j-1)=5
                     times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j-1))
                     call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)  
                  elseif (dissocstate(i,j-1).eq.11) then
                     if (state(i,j-2).eq.1) then
c                        write(6,*) 'dstate 11 -> 5'
                        dissocstate(i,j-1)=5
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)  
                     elseif (state(i,j-2).eq.-1) then
c                        write(6,*) 'dstate 11 -> 6'
                        dissocstate(i,j-2)=6
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)  
                     else
                        write(6,*) 'bad state for ',i,j-2
                        stop
                     endif
                  elseif (dissocstate(i,j-1).eq.8) then
                     if (state(i,j-2).eq.1) then
c                        write(6,*) 'dstate 8 -> 12'
                        dissocstate(i,j-1)=12
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)  
                     elseif (state(i,j-2).eq.-1) then
c                        write(6,*) 'dstate 8 -> 13'
                        dissocstate(i,j-1)=13														!changed (i,j-2) to (i,j-1)
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)  
                     else
                        write(6,*) 'bad state for ',i,j-2
                        stop
                     endif
                  else
                     write(6,*) 'bad dstate/dstate not tested for ',i,j-1,': ',dissocstate(i,j-1)
                     stop
                  endif
               else
                  write(6,*) 'bad state for ',i,j-1
                  stop
               endif
            else
c               write(6,*) 'dont mess with template, dont change ',i,j-1
            endif
            
c            write(6,*) 'look at how the 10/11 interactions are being made'
            if ((state(i+1,j+1).ne.0).and.(state(i+1,j).ne.0).and.(state(i+1,j-1).ne.0)) then
c               write(6,*) 'dstate 10/11 was not made across seam'
               
c               write(6,*) 'dep will have to change for ',i,j+1
c               write(6,*) 'dep before: ',dep(i,j+1)
               dep(i,j+1)=4
c               write(6,*) 'dep after: ',dep(i,j+1)
               
c               write(6,*) 'change dstates of ',i+1,j+1,', ',i+1,j,'and ',i+1,j-1
               
               if (dissocstate(i+1,j+1).eq.8) then
                  if ((state(i,j+2).ne.0).and.(state(i+1,j+2).ne.0).and.
     @               (state(i+2,j+2).ne.0).and.(state(i+2,j+1).ne.0).and.
     @               (state(i+2,j).ne.0)) then
c                     write(6,*) 'dissocstate stays 8 for ',i+1,j+1
                  elseif (state(i,j+2).eq.0) then
                     if ((state(i+1,j+1).eq.1).and.(state(i+1,j).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',i+1,j+1
                        dissocstate(i+1,j+1)=10
                        times(ev(i+1,j+1,2))=get_evtime(dissocstate(i+1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j+1))
                        call update(event,revmap,ev(i+1,j+1,2),times(ev(i+1,j+1,2)),times,totev)  
                     elseif ((state(i+1,j+1).eq.-1).or.(state(i+1,j).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',i+1,j+1
                        dissocstate(i+1,j+1)=11
                        times(ev(i+1,j+1,2))=get_evtime(dissocstate(i+1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j+1))
c Need to add test for double GDP if dstate=11.
                        if ((state(i+1,j+1).eq.-1).and.(state(i+1,j).eq.-1)) then
c                           write(6,*) 'double GDP, recalculate times'
                           times(ev(i+1,j+1,2))=times(ev(i+1,j+1,2))*GDP
                        else
c                           write(6,*) 'single GDP, do nothing'
                        endif
ccccccccccccccccccccccccccccccccccccccccccccccc
                        call update(event,revmap,ev(i+1,j+1,2),times(ev(i+1,j+1,2)),times,totev)  
c                        write(6,*) 'need to check for double GDP'
                     else
c                        write(6,*) 'empty subunit: ',i+1,j+1,'or ',i+1,j,'?'
                        stop
                     endif
                  elseif (state(i+2,j+2).eq.0) then
                     if (state(i+1,j).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',i+1,j+1
                        dissocstate(i+1,j+1)=5
                        times(ev(i+1,j+1,2))=get_evtime(dissocstate(i+1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j+1))
                        call update(event,revmap,ev(i+1,j+1,2),times(ev(i+1,j+1,2)),times,totev)  
                     elseif (state(i+1,j).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',i+1,j+1
                        dissocstate(i+1,j+1)=6
                        times(ev(i+1,j+1,2))=get_evtime(dissocstate(i+1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j+1))
                        call update(event,revmap,ev(i+1,j+1,2),times(ev(i+1,j+1,2)),times,totev)  
                     else
                        write(6,*) 'empty subunit: ',i+1,j,'?'
                        stop
                     endif
                  elseif (state(i+2,j).eq.0) then
                     if (state(i+1,j).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',i+1,j+1
                        dissocstate(i+1,j+1)=3
                        times(ev(i+1,j+1,2))=get_evtime(dissocstate(i+1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j+1))
                        call update(event,revmap,ev(i+1,j+1,2),times(ev(i+1,j+1,2)),times,totev)  
                     elseif (state(i+1,j).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',i+1,j+1
                        dissocstate(i+1,j+1)=4
                        times(ev(i+1,j+1,2))=get_evtime(dissocstate(i+1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j+1))
                        call update(event,revmap,ev(i+1,j+1,2),times(ev(i+1,j+1,2)),times,totev)  
                     else
                        write(6,*) 'empty subunit: ',i+1,j,'?'
                        stop
                     endif
                  endif
               elseif (dissocstate(i+1,j+1).eq.13) then
c                  write(6,*) 'dstate 13 -> 6 for ',i+1,j+1
                  dissocstate(i+1,j+1)=6
                  times(ev(i+1,j+1,2))=get_evtime(dissocstate(i+1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j+1))
                  call update(event,revmap,ev(i+1,j+1,2),times(ev(i+1,j+1,2)),times,totev)  
               elseif (dissocstate(i+1,j+1).eq.12) then
c                  write(6,*) 'dstate 12 -> 5 for ',i+1,j+1
                  dissocstate(i+1,j+1)=5
                  times(ev(i+1,j+1,2))=get_evtime(dissocstate(i+1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j+1))
                  call update(event,revmap,ev(i+1,j+1,2),times(ev(i+1,j+1,2)),times,totev)  
               elseif (dissocstate(i+1,j+1).eq.11) then
                  if (state(i+1,j).eq.1) then
c                     write(6,*) 'dstate 11 -> 3 for ',i+1,j+1
                     dissocstate(i+1,j+1)=3
                     times(ev(i+1,j+1,2))=get_evtime(dissocstate(i+1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j+1))
                     call update(event,revmap,ev(i+1,j+1,2),times(ev(i+1,j+1,2)),times,totev)  
                  elseif (state(i+1,j).eq.-1) then
c                     write(6,*) 'dstate 11 -> 4 for ',i+1,j+1
                     dissocstate(i+1,j+1)=4
                     times(ev(i+1,j+1,2))=get_evtime(dissocstate(i+1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j+1))
                     call update(event,revmap,ev(i+1,j+1,2),times(ev(i+1,j+1,2)),times,totev)  
                  else
                     write(6,*) 'empty subunit: ',i+1,j
                     stop
                  endif
               elseif (dissocstate(i+1,j+1).eq.6) then
c                  write(6,*) 'dstate 6 -> 4 for ',i+1,j+1
                  dissocstate(i+1,j+1)=4
                  times(ev(i+1,j+1,2))=get_evtime(dissocstate(i+1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j+1))
                  call update(event,revmap,ev(i+1,j+1,2),times(ev(i+1,j+1,2)),times,totev)  
               elseif ((dissocstate(i+1,j+1).eq.5).or.(dissocstate(i+1,j+1).eq.10)) then
c                  write(6,*) 'dstate 5/10 -> 3 for ',i+1,j+1
                  dissocstate(i+1,j+1)=3
                  times(ev(i+1,j+1,2))=get_evtime(dissocstate(i+1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j+1))
                  call update(event,revmap,ev(i+1,j+1,2),times(ev(i+1,j+1,2)),times,totev)  
               else
                  write(6,*) 'bad dissocstate',dissocstate(i+1,j+1),'for',i+1,j+1
                  stop
               endif
               
               if (dissocstate(i+1,j).eq.8) then								
                  addstate(i+1,j)=addstate(i+1,j)-1
                  if ((state(i+2,j+1).ne.0).and.(state(i+2,j).ne.0).and.
     @               (state(i+2,j-1).ne.0)) then
                     if ((state(i+1,j).eq.1).and.(state(i+1,j-1).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',i+1,j
                        dissocstate(i+1,j)=10
                        times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j))
                        call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                     elseif ((state(i+1,j).eq.-1).or.(state(i+1,j-1).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',i+1,j
                        dissocstate(i+1,j)=11
                        times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j))
c Need to add test for double GDP if dstate=11.
                        if ((state(i+1,j).eq.-1).and.(state(i+1,j-1).eq.-1)) then
c                           write(6,*) 'double GDP, recalculate times'
                           times(ev(i+1,j,2))=times(ev(i+1,j,2))*GDP
                        else
c                           write(6,*) 'single GDP, do nothing'
                        endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',i+1,j,'or ',i+1,j-1,'?'
                        stop
                     endif
                  elseif (state(i+2,j+1).eq.0) then
                     if (state(i+1,j-1).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',i+1,j
                        dissocstate(i+1,j)=5
                        times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j))
                        call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                     elseif (state(i+1,j-1).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',i+1,j
                        dissocstate(i+1,j)=6
                        times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j))
                        call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                     else
                        write(6,*) 'empty subunit: ',i+1,j-1,'?'
                        stop
                     endif
                  elseif (state(i+2,j-1).eq.0) then
                     if (state(i+1,j-1).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',i+1,j
                        dissocstate(i+1,j)=3
                        times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j))
                        call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                     elseif (state(i+1,j-1).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',i+1,j
                        dissocstate(i+1,j)=4
                        times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j))
                        call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                     else
                        write(6,*) 'empty subunit: ',i+1,j-1,'?'
                        stop
                     endif
                  endif
               elseif (dissocstate(i+1,j).eq.11) then
                  addstate(i+1,j)=addstate(i+1,j)-1
                  if (state(i+1,j-1).eq.1) then
c                     write(6,*) 'dstate 11 -> 3 for ',i+1,j
                     dissocstate(i+1,j)=3
                     times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j))
                     call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                  elseif (state(i+1,j-1).eq.-1) then
c                     write(6,*) 'dstate 11 -> 4 for ',i+1,j
                     dissocstate(i+1,j)=4
                     times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j))
                     call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
                  else
                     write(6,*) 'empty subunit: ',i+1,j-1,'?'
                     stop
                  endif
               elseif (dissocstate(i+1,j).eq.10) then
                  addstate(i+1,j)=addstate(i+1,j)-1
c                  write(6,*) 'dstate 10 -> 3 for ',i+1,j
                  dissocstate(i+1,j)=3
                  times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j))
                  call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
               else
                  write(6,*) 'bad dissocstate',dissocstate(i+1,j),'for',i+1,j
                  stop
               endif
               
               if (j.gt.103) then
c                  write(6,*) 'can change dstate of ',i+1,j-1,', not part of template'
                  if (dissocstate(i+1,j-1).eq.8) then
                     if (state(i+2,j).ne.0) then
c                        write(6,*) 'dstate should stay 8 for ',i+1,j-1
                     else
                        if (state(i+1,j-2).eq.1) then
c                           write(6,*) 'dstate 8 -> 12 for ',i+1,j-1
                           dissocstate(i+1,j-1)=12
                           times(ev(i+1,j-1,2))=get_evtime(dissocstate(i+1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j-1))
                           call update(event,revmap,ev(i+1,j-1,2),times(ev(i+1,j-1,2)),times,totev)
                        elseif (state(i+1,j-2).eq.-1) then
c                           write(6,*) 'dstate 8 -> 13 for ',i+1,j-1
                           dissocstate(i+1,j-1)=13
                           times(ev(i+1,j-1,2))=get_evtime(dissocstate(i+1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j-1))
                           call update(event,revmap,ev(i+1,j-1,2),times(ev(i+1,j-1,2)),times,totev)
                        else
                           write(6,*) 'bad state for ',i+1,j-2,'?'
                           stop
                        endif
                     endif
                  elseif (dissocstate(i+1,j-1).eq.11) then
                     if (state(i+1,j-2).eq.1) then
c                        write(6,*) 'dstate 11 -> 5 for ',i+1,j-1
                        dissocstate(i+1,j-1)=5
                        times(ev(i+1,j-1,2))=get_evtime(dissocstate(i+1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j-1))
                        call update(event,revmap,ev(i+1,j-1,2),times(ev(i+1,j-1,2)),times,totev)
                     elseif (state(i+1,j-2).eq.-1) then
c                        write(6,*) 'dstate 11 -> 6 for ',i+1,j-1
                        dissocstate(i+1,j-1)=6
                        times(ev(i+1,j-1,2))=get_evtime(dissocstate(i+1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j-1))
                        call update(event,revmap,ev(i+1,j-1,2),times(ev(i+1,j-1,2)),times,totev)
                     else
                        write(6,*) 'empty subunit: ',i+1,j-2,'?'
                        stop
                     endif
                  elseif (dissocstate(i+1,j-1).eq.10) then
c                     write(6,*) 'dstate 10 -> 5 for ',i+1,j-1
                     dissocstate(i+1,j-1)=5
                     times(ev(i+1,j-1,2))=get_evtime(dissocstate(i+1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i+1,j-1))
                     call update(event,revmap,ev(i+1,j-1,2),times(ev(i+1,j-1,2)),times,totev)
                  else
                     write(6,*) 'bad dstate/dstate not tested ',dissocstate(i+1,j-1),'for ',i+1,j-1
                     stop
                  endif
               else
c                  write(6,*) 'do not change ',i+1,j-1,', is part of template'
               endif
               
c               write(6,*) 'now look across seam to see if lower neighbor needs to be changed'
               if (state(13,j+1).eq.0) then
c                  write(6,*) 'lower seam neighbor empty'
                  if (dissocstate(13,j+1).eq.2) then
                     if (addstate(13,j+1).eq.1) then
c                        write(6,*) 'dstate=2, addstate=1, remove event for ',13,j+1
                        addstate(13,j+1)=addstate(13,j+1)-1
                        dissocstate(13,j+1)=0
                        call RemoveAdditionEvent(13,j+1,nrecyc,recyc,revmap,ev,nev,
     @                       addstate,event,times,totev)
                     elseif (addstate(13,j+1).eq.2) then
c                        write(6,*) 'dstate=2, addstate=2, remove addition at ',13,j+1
                        addstate(13,j+1)=addstate(13,j+1)-1
                     else
                        write(6,*) 'bad dstate/addstate for ',13,j+1
                        stop
                     endif
                  elseif (dissocstate(13,j+1).eq.5) then
                     addstate(13,j+1)=addstate(13,j+1)-1
                     dissocstate(13,j+1)=3
c                     write(6,*) 'dstate 5 -> 3 for ',13,j+1
                  !added May 31 for nucleotide exchange experiments.
                  elseif (dissocstate(13,j+1).eq.6) then
                     addstate(13,j+1)=addstate(13,j+1)-1
                     dissocstate(13,j+1)=6
c                     write(6,*) 'dstate 6 -> 4 for ',13,j+1
                  elseif (dissocstate(13,j+1).eq.12) then
                     addstate(13,j+1)=addstate(13,j+1)-1
                     dissocstate(13,j+1)=5
c                     write(6,*) 'dstate 12 -> 5 for ',13,j+1
                  !added May 31 for nucleotide exchange experiments.
                  elseif (dissocstate(13,j+1).eq.13) then
                     addstate(13,j+1)=addstate(13,j+1)-1
                     dissocstate(13,j+1)=13
c                     write(6,*) 'dstate 13 -> 6 for ',13,j+1
                  else
                     write(6,*) 'bad dstate for ',13,j+1,': ',dissocstate(13,j+1)
                     stop
                  endif
               else
                  if (dissocstate(13,j+1).eq.2) then
                     if (addstate(13,j+1).eq.1) then
                        write(6,*) 'dstate=2, addstate=1, need to wipe ',13,j+1,'?'
                        stop
                     elseif (addstate(13,j+1).eq.2) then
c                        write(6,*) 'dstate=2, addstate=2, remove addition at ',13,j+1
                        addstate(13,j+1)=addstate(13,j+1)-1
                     else
                        write(6,*) 'bad dstate/addstate for ',13,j+1
                        stop
                     endif
                  elseif (dissocstate(13,j+1).eq.5) then
                     addstate(13,j+1)=addstate(13,j+1)-1
                     dissocstate(13,j+1)=3
cccccccccccccccccccccccccccccc                        
c                     write(6,*) 'losing full lateral contact, seammult ne 1'
                     seammult(13,j+1)=17.2
c                     seammult(13,j+1)=1.0		!to turn off
c                     write(6,*) 'dstate 5 -> 3 for ',13,j+1
                     times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccc     
                     call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                  elseif (dissocstate(13,j+1).eq.6) then
                     addstate(13,j+1)=addstate(13,j+1)-1
                     dissocstate(13,j+1)=4
cccccccccccccccccccccccccccccc                        
c                     write(6,*) 'losing full lateral contact, seammult ne 1'
                     seammult(13,j+1)=17.2
c                     seammult(13,j+1)=1.0		!to turn off
c                     write(6,*) 'dstate 6 -> 4 for ',13,j+1
                     times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccc     
                     call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                  elseif (dissocstate(13,j+1).eq.12) then
                     addstate(13,j+1)=addstate(13,j+1)-1
                     dissocstate(13,j+1)=5
cccccccccccccccccccccccccccccc                        
c                     write(6,*) 'losing full lateral contact, seammult ne 1'
                     seammult(13,j+1)=17.2
c                     seammult(13,j+1)=1.0		!to turn off
c                     write(6,*) 'dstate 12 -> 5 for ',13,j+1
                     times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccc     
                     call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                  elseif (dissocstate(13,j+1).eq.13) then
                     addstate(13,j+1)=addstate(13,j+1)-1
                     dissocstate(13,j+1)=6
cccccccccccccccccccccccccccccc                        
c                     write(6,*) 'losing full lateral contact, seammult ne 1'
                     seammult(13,j+1)=17.2
c                     seammult(13,j+1)=1.0		!to turn off
c                     write(6,*) 'dstate 13 -> 6 for ',13,j+1
                     times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+1))
cccccccccccccccccccccccccccccc     
                     call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                  else
                     write(6,*) 'bad dstate for ',13,j+1,'?'
                     stop
                  endif
               endif
               
c               write(6,*) 'upper seam neighbor may need to be changed'
               if (state(13,j+2).eq.0) then
                  if (dissocstate(13,j+2).eq.2) then
                     if (addstate(13,j+2).eq.1) then
c                        write(6,*) 'dstate=2, addstate=1, remove event at ',13,j+2
                        addstate(13,j+2)=addstate(13,j+2)-1
                        dissocstate(13,j+2)=0
                        call RemoveAdditionEvent(13,j+2,nrecyc,recyc,revmap,ev,nev,
     @                          addstate,event,times,totev)
                     elseif (addstate(13,j+2).eq.2) then
c                        write(6,*) 'dstate=2, addstate=2, remove addition at ',13,j+2
                        addstate(13,j+2)=addstate(13,j+2)-1
                     else
                        write(6,*) 'bad dstate/addstate at ',13,j+2
                        stop
                     endif
                  elseif (dissocstate(13,j+2).eq.5) then
                     addstate(13,j+2)=addstate(13,j+2)-1
                     dissocstate(13,j+2)=3
c                     write(6,*) 'dstate 5 -> 3 for ',13,j+2
                  elseif (dissocstate(13,j+2).eq.12) then
                     addstate(13,j+2)=addstate(13,j+2)-1
                     dissocstate(13,j+2)=5
c                     write(6,*) 'dstate 12 -> 5 for ',13,j+2
                  else
                     write(6,*) 'bad dstate for ',13,j+2,'?'
                     stop
                  endif
               else
                  if (state(13,j+1).eq.0) then
                     write(6,*) 'state of ',13,j+2,'is ',state(13,j+2)
                     write(6,*) 'state of ',13,j+1,'is 0'
                     write(6,*) 'strange case, may need to implement more code?'
                     stop
                  else
                     write(6,*) 'bad dstate/addstate somewhere?'
                     stop
                  endif
               endif
            
            elseif ((state(13,j).ne.0).and.(state(13,j+1).ne.0).and.
     @             (state(13,j+2).ne.0).and.(state(13,j+3).ne.0)) then
c               write(6,*) 'dstate 10/11 was made across seam'
               
c               write(6,*) 'dep will have to change for ',i,j+1
c               write(6,*) 'dep before: ',dep(i,j+1)
               dep(i,j+1)=3
c               write(6,*) 'dep after: ',dep(i,j+1)
               
c               write(6,*) 'should only need to update ',13,j+1,'and ',13,j+2
               if (dissocstate(13,j+1).eq.8) then
                  addstate(13,j+1)=addstate(13,j+1)-1
cccccccccccccccccccccccccccccc                        
c                  write(6,*) 'losing full lateral contact, seammult ne 1'
                  seammult(13,j+1)=17.2
c                  seammult(13,j+1)=1.0		!to turn off
cccccccccccccccccccccccccccccc                  
                  if (state(12,j+2).ne.0) then
                     if ((state(13,j+2).eq.1).and.(state(13,j).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',13,j+1
                        dissocstate(13,j+1)=10
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+1))
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                     elseif ((state(13,j+2).eq.-1).or.(state(13,j).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',13,j+1
                        dissocstate(13,j+1)=11
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+1))
c Need to add test for double GDP if dstate=11.
                        if ((state(13,j+1).eq.-1).and.(state(13,j).eq.-1)) then
c                           write(6,*) 'double GDP, recalculate times'
                           times(ev(13,j+1,2))=times(ev(13,j+1,2))*GDP
                        else
c                           write(6,*) 'single GDP, do nothing'
                        endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'bad state for ',13,j+2,'or ',13,j
                        stop
                     endif
                  else
                     if (state(13,j).eq.1) then
c                        write(6,*) '8 -> 5 for ',13,j+1
                        dissocstate(13,j+1)=5
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+1))
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
c                        write(6,*) 'slow dstate 5, need to recalculate'
                     elseif (state(13,j).eq.-1) then
c                        write(6,*) '8 -> 6 for ',13,j+1
                        dissocstate(13,j+1)=6
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+1))
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
c                        write(6,*) 'slow dstate 6, need to recalculate'
                     else
                        write(6,*) 'bad state for ',13,j
                        stop
                     endif
                  endif
               elseif (dissocstate(13,j+1).eq.11) then
                  addstate(13,j+1)=addstate(13,j+1)-1
cccccccccccccccccccccccccccccc                        
c                  write(6,*) 'losing full lateral contact, seammult ne 1'
                  seammult(13,j+1)=17.2
c                  seammult(13,j+1)=1.0		!to turn off
cccccccccccccccccccccccccccccc                  
                  if (state(13,j).eq.1) then
c                     write(6,*) 'dstate 11 -> 3 for ',13,j+1
                     dissocstate(13,j+1)=3
                     times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+1))
                     call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
c                     write(6,*) 'slow dstate 3, need to recalculate'
                  elseif (state(13,j).eq.-1) then
c                     write(6,*) 'dstate 11 -> 4 for ',13,j+1
                     dissocstate(13,j+1)=4
                     times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+1))
                     call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
c                     write(6,*) 'slow dstate 4, need to recalculate'
                  else
                     write(6,*) 'bad state for ',13,j
                     stop
                  endif
               elseif (dissocstate(13,j+1).eq.10) then
                  addstate(13,j+1)=addstate(13,j+1)-1
c                  write(6,*) 'dstate 10 -> 3 for ',13,j+1
                  dissocstate(13,j+1)=3
cccccccccccccccccccccccccccccc                        
c                  write(6,*) 'losing full lateral contact, seammult ne 1'
                  seammult(13,j+1)=17.2
c                  seammult(13,j+1)=1.0		!to turn off
cccccccccccccccccccccccccccccc                  
                  times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+1))
                  call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
c                  write(6,*) 'slow dstate 3, need to recalculate'
               else
                  write(6,*) 'bad dstate for ',13,j+1
                  stop
               endif
               
               if (dissocstate(13,j+2).eq.8) then
                  addstate(13,j+2)=addstate(13,j+2)-1
cccccccccccccccccccccccccccccc                        
c                  write(6,*) 'losing full lateral contact, seammult ne 1'
                  seammult(13,j+2)=17.2
c                  seammult(13,j+2)=1.0		!to turn off
cccccccccccccccccccccccccccccc                   
                  if (state(12,j+3).ne.0) then
                     if ((state(13,j+3).eq.1).and.(state(13,j+1).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',13,j+2
                        dissocstate(13,j+2)=10
                        times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+2))
                        call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                     elseif ((state(13,j+3).eq.-1).or.(state(13,j+1).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',13,j+2
                        dissocstate(13,j+2)=11
                        times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+2))
c Need to add test for double GDP if dstate=11.
                        if ((state(13,j+2).eq.-1).and.(state(13,j+1).eq.-1)) then
c                           write(6,*) 'double GDP, recalculate times'
                           times(ev(13,j+2,2))=times(ev(13,j+2,2))*GDP
                        else
c                           write(6,*) 'single GDP, do nothing'
                        endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'bad state for ',13,j+3,'or ',13,j+1
                        stop
                     endif
                  else
                     if (state(13,j+1).eq.1) then
                        write(6,*) '8 -> 5 for ',13,j+2
                        dissocstate(13,j+2)=5
                        times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+2))
                        call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                        write(6,*) 'slow dstate 5, need to recalculate'
                     elseif (state(13,j+1).eq.-1) then
                        write(6,*) '8 -> 6 for ',13,j+2
                        dissocstate(13,j+2)=6
                        times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+2))
                        call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                        write(6,*) 'slow dstate 6, need to recalculate'
                     else
                        write(6,*) 'bad state for ',13,j+1
                        stop
                     endif
                  endif
               elseif (dissocstate(13,j+2).eq.13) then			!added June 13
                  addstate(13,j+2)=addstate(13,j+2)-1
c                  write(6,*) 'dstate 13 -> 6 for ',13,j+2
                  dissocstate(13,j+2)=6
                  times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+2))
                  call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
               elseif (dissocstate(13,j+2).eq.12) then			!added June 13
                  addstate(13,j+2)=addstate(13,j+2)-1
c                  write(6,*) 'dstate 12 -> 5 for ',13,j+2
                  dissocstate(13,j+2)=5
                  times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+2))
                  call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
               elseif (dissocstate(13,j+2).eq.11) then
                  addstate(13,j+2)=addstate(13,j+2)-1
                  if (state(13,j+1).eq.1) then
c                     write(6,*) 'dstate 11 -> 3 for ',13,j+2
                     dissocstate(13,j+2)=3
                     times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+2))
                     call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                  elseif (state(13,j+1).eq.-1) then
c                     write(6,*) 'dstate 11 -> 4 for ',13,j+2
                     dissocstate(13,j+2)=4
                     times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+2))
                     call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                  else
                     write(6,*) 'bad state for ',13,j+1
                     stop
                  endif
               elseif (dissocstate(13,j+2).eq.10) then
                  addstate(13,j+2)=addstate(13,j+2)-1
c                  write(6,*) 'dstate 10 -> 3 for ',13,j+2
                  dissocstate(13,j+2)=3
                  times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+2))
                  call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
               elseif (dissocstate(13,j+2).eq.6) then
                  addstate(13,j+2)=addstate(13,j+2)-1
c                  write(6,*) 'dstate 6 -> 4 for ',13,j+2
                  dissocstate(13,j+2)=4
                  times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+2))
                  call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
               elseif (dissocstate(13,j+2).eq.5) then
                  addstate(13,j+2)=addstate(13,j+2)-1
c                  write(6,*) 'dstate 5 -> 3 for ',13,j+2
                  dissocstate(13,j+2)=3
                  times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(13,j+2))
                  call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
               else
                  write(6,*) 'bad dstate for ',13,j+2
                  stop
               endif
                 
c               write(6,*) 'now looking away from the seam'
c               write(6,*) 'should only need to update ',i+1,j
               if (state(i+1,j).eq.0) then
                  if (dissocstate(i+1,j).eq.2) then
                     if (addstate(i+1,j).eq.1) then
c                        write(6,*) 'dstate=2, addstate=1, remove event for ',i+1,j
                        addstate(i+1,j)=addstate(i+1,j)-1
                        dissocstate(i+1,j)=0
                        call RemoveAdditionEvent(i+1,j,nrecyc,recyc,revmap,ev,nev,
     @                          addstate,event,times,totev)
                     elseif (addstate(i+1,j).eq.2) then
c                        write(6,*) 'dstate=2, addstate=2, remove addition for ',i+1,j
                        addstate(i+1,j)=addstate(i+1,j)-1
                     else
                        write(6,*) 'bad dstate/addstate for ',i+1,j
                        stop
                     endif
                  elseif (dissocstate(i+1,j).eq.5) then
                     addstate(i+1,j)=addstate(i+1,j)-1
                     dissocstate(i+1,j)=3
c                     write(6,*) 'dstate 5 -> 3 for ',i+1,j
                  elseif (dissocstate(i+1,j).eq.12) then
                     addstate(i+1,j)=addstate(i+1,j)-1
                     dissocstate(i+1,j)=5
c                     write(6,*) 'dstate 12 -> 5 for ',i+1,j
                  else
                     write(6,*) 'bad dstate for ',i+1,j,': ',dissocstate(i+1,j)
                     stop
                  endif
               else
                  if (dissocstate(i+1,j).eq.2) then
                     write(6,*) 'lateral interaction, may need to wipe?'
                     stop
                  else
                     write(6,*) 'bad dstate for ',i+1,j,': ',dissocstate(i+1,j)
                     stop
                  endif
               endif
               
            else
               write(6,*) 'bad dstate/addstate somewhere?'
               stop
            endif

c Start nucleotide exchange fun here...            
c      	    write(6,*) 'remove hydrolysis event if not hydrolyzed'
      	    if (state(i,j-1).eq.1) then
c              write(6,*) 'not hydrolyzed, remove event'
               if (ev(i,j-1,3).ne.0) then
                  call RemoveHydroEvent(i,j-1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)        		
               endif
            else
c               write(6,*) 'hydrolyzed, do nothing'
            endif
c End nucleotide exchange fun here...      	    
      	    
         elseif ((dissocstate(i,j).eq.12).or.(dissocstate(i,j).eq.13)) then
c            write(6,*) 'dissociating from dstate=12/13'
c            write(6,*) 'check above'
            if (state(i,j+1).eq.0) then
               if (addstate(i,j+1).ge.2) then
c                  write(6,*) 'empty above, more than 1 neighbor'
                  addstate(i,j+1)=addstate(i,j+1)-1
c Start nucleation exchange fun here...                  
                  if ((dissocstate(i,j+1).eq.5).or.(dissocstate(i,j+1).eq.6)) then
                     dissocstate(i,j+1)=2
c                 Adding in code to handle looking up and changing dissocstate(i,j+1)=12            !Is there a possibility that     
                  elseif ((dissocstate(i,j+1).eq.12).or.(dissocstate(i,j+1).eq.13)) then			!dissocstate(i,j+1)=8?
                     dissocstate(i,j+1)=2                     										!
c                     write(6,*) 'have not yet handled this check'									!
c                     stop																			!
                  else																				!
                     write(6,*) 'if found, have not yet handled this check'							!
                     stop																			!
                  endif																				!
c End nucleation exchange fun here...                  
               elseif (addstate(i,j+1).eq.1) then
c                  write(6,*) 'empty above, 1 neighbor, remove event'
                  addstate(i,j+1) = addstate(i,j+1)-1
                  dissocstate(i,j+1)=0
                  if (ev(i,j+1,1).ne.0) then
c               if (qdebug) write(6,*) 'Lose Addition at : ',i,k
                     nrecyc = nrecyc+1
      		         recyc(nrecyc) = ev(i,j+1,1)
      		         index=revmap(ev(i,j+1,1))
      		         nev(i,j+1)=nev(i,j+1)-1
      		         ev(i,j+1,1)=0
      			  			
      		         temp=event(index)
	  		         event(index)=event(totev)
	  		         event(totev)=temp
	  		         revmap(event(totev))=totev
	  		         revmap(event(index))=index
	  		         times(event(totev))=1d15
                     totev=totev-1
	  		         call min_heapify(event,revmap,times,1,totev)
      		         call hpsort(nrecyc,recyc)
      		      endif
               else
                  write(6,*) 'pf#1 dissocstate=12/13, bad addstate'
                  stop
               endif
            else
c               write(6,*) 'something above, change addstate and remove gtp hydro'
c               write(6,*) 'wiping problem'
               addstate(i,j+1) = addstate(i,j+1)-1
               addstate(i,j)=addstate(i,j)-1 !correct for losing the above guy
               if (ev(i,j,3).ne.0) then
c            if (qdebug) write(6,*) 'Lose Hydrolysis at : ',i,j,ev(i,j,3)
                  nrecyc = nrecyc+1
      	          recyc(nrecyc) = ev(i,j,3)
      	          index=revmap(ev(i,j,3))
      	          nev(i,j)=nev(i,j)-1
      	          ev(i,j,3)=0
      	          call hpsort(nrecyc,recyc)
      	          temp=event(index)
	  	          event(index)=event(totev)
	  	          event(totev)=temp
	  	          revmap(event(totev))=totev
	  	          revmap(event(index))=index
	  	          times(event(totev))=1d15
c	  				       				do kk=1,totev+5
c         			write(6,*) 'times ',kk,times(event(kk)),event(kk),revmap(kk)
c      				end do            

                  totev=totev-1
	  	          call min_heapify(event,revmap,times,1,totev)      			  			
      	       endif
               nremove=1
               call WipeFromSeam(i,j+1,nremove,ntub,dep,state,addstate,nrecyc,recyc,
     @                        ev,nev,dissocstate,event,revmap,totev,times,seammult)
     
      	    endif

c               write(6,*) 'take care of right diag, call SubUppLef'
               temph = dissocstate(i+1,j)
               tempv = dissocstate(i,j-1)
               tempd = dissocstate(i+1,j-1)
               call SubUppLef(dep,dissocstate,state,i+1,j,i,j-1,temph,tempv,tempd)
               addstate(i+1,j)=addstate(i+1,j)-1
               if (j.gt.103) addstate(i,j-1)=addstate(i,j-1)-1
               ! added above Aug 2
               if (temph.ne.dissocstate(i+1,j)) then
c                  write(6,*) 'new dissocstate for H-neighb'
                  dissocstate(i+1,j)=temph
c      		      write(6,*) 'resetting dissocstate of H-neighb to ',dissocstate(i+1,j),temph
                  times(ev(i+1,j,2))=get_evtime(dissocstate(i+1,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(i+1,j))
c Need to add test for double GDP if dstate=11.
                  if (temph.eq.11) then
                     if ((state(i+1,j).eq.-1).and.(state(i+1,j-1).eq.-1)) then
c                        write(6,*) 'double GDP, recalculate times'
                        times(ev(i+1,j,2))=times(ev(i+1,j,2))*GDP
                     else
c                        write(6,*) 'single GDP, do nothing'
                     endif
                  endif
ccccccccccccccccccccccccccccccccccccccccccccccc
                  call update(event,revmap,ev(i+1,j,2),times(ev(i+1,j,2)),times,totev)
               endif
               if (tempv.ne.dissocstate(i,j-1)) then
                  if (j.gt.103) then
c                     write(6,*) 'new dissocstate for V-neighb'
                     dissocstate(i,j-1)=tempv
c      		         write(6,*) 'resetting dissocstate of V-neighb to ',dissocstate(i,j-1)
                     times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(i,j-1))
c Need to add test for double GDP if dstate=11.
                  if (tempv.eq.11) then
                     if ((state(i,j-1).eq.-1).and.(state(i,j-2).eq.-1)) then
c                        write(6,*) 'double GDP, recalculate times'
                        times(ev(i,j-1,2))=times(ev(i,j-1,2))*GDP
                     else
c                        write(6,*) 'single GDP, do nothing'
                     endif
                  endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
                     call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)
                  else
c                     write(6,*)'on 1st row, leave 102 alone'
                  endif
               endif
               if (tempd.ne.dissocstate(i+1,j-1)) then
                  if (j.gt.103) then
c                     write(6,*) 'new dissocstate for D-neighb'
                     dissocstate(i+1,j-1)=tempd
c      		         write(6,*) 'resetting dissocstate of D-neighb to ',dissocstate(i+1,j-1)
                     times(ev(i+1,j-1,2))=get_evtime(dissocstate(i+1,j-1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(i+1,j-1))
c Need to add test for double GDP if dstate=11.
                  if (tempd.eq.11) then
                     if ((state(i+1,j-1).eq.-1).and.(state(i+1,j-2).eq.-1)) then
c                        write(6,*) 'double GDP, recalculate times'
                        times(ev(i+1,j-1,2))=times(ev(i+1,j-1,2))*GDP
                     else
c                        write(6,*) 'single GDP, do nothing'
                     endif
                  endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
                     call update(event,revmap,ev(i+1,j-1,2),times(ev(i+1,j-1,2)),times,totev)
                  else
c                     write(6,*)'on 1st row, leave 102 alone'
                  endif
               endif
c               write(6,*) 'now do across seam'
                     if (dissocstate(13,j+1).eq.5) then
                        addstate(13,j+1)=addstate(13,j+1)-1
                        dissocstate(13,j+1)=3
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+1)=17.2
c                        seammult(13,j+1)=1.0		!to turn off
cccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
c                        write(6,*) 'special case, check 2 below across seam unless in template'
                        if (j.gt.102) then
                           if (dissocstate(13,j).eq.10) then
c                              write(6,*) 'dstate 2 below: 10->5'
         	                  dissocstate(13,j)=5
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                        K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                        K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                           elseif (dissocstate(13,j).eq.11) then
                              if (state(13,j-1).eq.1) then
c                                 write(6,*) 'dstate 2 below: 11->5'
      	                         dissocstate(13,j)=5
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              elseif (state(13,j-1).eq.-1) then
c                                 write(6,*) 'dstate below: 11->6'
      	                         dissocstate(13,j)=6
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              else
                                 write(6,*) 'bad destate 2 below cross seam??'
                                 stop
                              endif
                           elseif (dissocstate(13,j).eq.8) then
                              if (state(13,j-1).eq.1) then
c                                 write(6,*) 'dstate 2 below: 8->12'
      	                         dissocstate(13,j)=12
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              elseif (state(13,j-1).eq.-1) then
c                                 write(6,*) 'dstate below: 8->13'
      	                         dissocstate(13,j)=13
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              else
                                 write(6,*) 'bad destate 2 below cross seam??'
                                 stop
                              endif
                           else
                              write(6,*) 'dstate below is not 10,11,8'
                              stop
                           endif
                        else
c                           write(6,*) '2 below in template, dont touch'
                        endif
                     elseif (dissocstate(13,j+1).eq.6) then
                        addstate(13,j+1)=addstate(13,j+1)-1
                        dissocstate(13,j+1)=4
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+1)=17.2
c                        seammult(13,j+1)=1.0		!to turn off
cccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
c                        write(6,*) 'special case, check 2 below across seam unless in template'
                        if (j.gt.102) then
                           if (dissocstate(13,j).eq.10) then
c                              write(6,*) 'dstate 2 below: 10->5'
                              dissocstate(13,j)=5
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                           elseif (dissocstate(13,j).eq.11) then
                              if (state(13,j-1).eq.1) then
c                                 write(6,*) 'dstate 2 below: 11->5'
      	                         dissocstate(13,j)=5
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              elseif (state(13,j-1).eq.-1) then
c                                 write(6,*) 'dstate below: 11->6'
      	                         dissocstate(13,j)=6
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              else
                                 write(6,*) 'bad destate 2 below cross seam??'
                                 stop
                              endif
                           elseif (dissocstate(13,j).eq.8) then
                              if (state(13,j-1).eq.1) then
c                                 write(6,*) 'dstate 2 below: 8->12'
      	                         dissocstate(13,j)=12
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              elseif (state(13,j-1).eq.-1) then
c                                 write(6,*) 'dstate below: 8->13'
      	                         dissocstate(13,j)=13
                                 times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(13,j))
                                 call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)  
                              else
                                 write(6,*) 'bad destate 2 below cross seam??'
                                 stop
                              endif
                           else
                              write(6,*) 'dstate below is not 10,11,8'
                              stop
                           endif
                        else
c                           write(6,*) '2 below in template, dont touch'
                        endif
c Dstate 10/11 can occur...
                     elseif (dissocstate(13,j+1).eq.10) then
                        addstate(13,j+1)=addstate(13,j+1)-1
                        dissocstate(13,j+1)=3
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+1)=17.2
c                        seammult(13,j+1)=1.0		!to turn off
cccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                        !added May 31: checking 2 below...
c                        write(6,*) 'removing next to dstate 10, need to look 2 below'
                        if (dissocstate(13,j).eq.8) then
                           if (state(13,j-1).eq.1) then
                              dissocstate(13,j)=12
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           elseif (state(13,j-1).eq.-1) then
                              dissocstate(13,j)=13
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           else
                              write(6,*) 'bad state for: ',13,j-1
                              stop
                           endif
                        elseif (dissocstate(13,j).eq.10) then
                           dissocstate(13,j)=5
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                        elseif (dissocstate(13,j).eq.11) then
                           if (state(13,j-1).eq.1) then		!May 31: changed dissocstate to state
                              dissocstate(13,j)=5
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           elseif (state(13,j-1).eq.-1) then
                              dissocstate(13,j)=6
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           else
                              write(6,*) 'bad state for: ',13,j-1
                              stop
                           endif
                        else
c                           write(6,*) 'not dstate 8/10/11 at 2 below'
                        endif
                     elseif (dissocstate(13,j+1).eq.11) then
                        addstate(13,j+1)=addstate(13,j+1)-1
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+1)=17.2
c                        seammult(13,j+1)=1.0		!to turn off
cccccccccccccccccccccccccccccc                        
                        if (state(13,j).eq.1) then
                           dissocstate(13,j+1)=3
c                           write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                           times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                           call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                        elseif (state(13,j).eq.-1) then
                           dissocstate(13,j+1)=4
c                           write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                           times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                           call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                        else
                           write(6,*) 'bad state for ',13,j
                           stop
                        endif
                        !added May 31: checking 2 below...
c                        write(6,*) 'removing next to dstate 10, need to look 2 below'
                        if (dissocstate(13,j).eq.8) then
                           if (state(13,j-1).eq.1) then
                              dissocstate(13,j)=12
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           elseif (state(13,j-1).eq.-1) then
                              dissocstate(13,j)=13
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           else
                              write(6,*) 'bad state for: ',13,j-1
                              stop
                           endif
                        elseif (dissocstate(13,j).eq.10) then
                           dissocstate(13,j)=5
                           times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                           call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                        elseif (dissocstate(13,j).eq.11) then
                           if (state(13,j-1).eq.1) then		!May 31: changed dissocstate to state
                              dissocstate(13,j)=5
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           elseif (state(13,j-1).eq.-1) then
                              dissocstate(13,j)=6
                              times(ev(13,j,2))=get_evtime(dissocstate(13,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j))
                              call update(event,revmap,ev(13,j,2),times(ev(13,j,2)),times,totev)
                           else
                              write(6,*) 'bad state for: ',13,j-1
                              stop
                           endif
                        else
c                           write(6,*) 'not dstate 8/10/11 at 2 below'
                        endif
                     elseif (dissocstate(13,j+1).eq.12) then
                        addstate(13,j+1)=addstate(13,j+1)-1
                        dissocstate(13,j+1)=5
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+1)=17.2
c                        seammult(13,j+1)=1.0		!to turn off
cccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                     elseif (dissocstate(13,j+1).eq.13) then
                        addstate(13,j+1)=addstate(13,j+1)-1
                        dissocstate(13,j+1)=6
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+1)=17.2
c                        seammult(13,j+1)=1.0		!to turn off
cccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                        times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                        call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                     elseif (dissocstate(13,j+1).eq.8) then
                        addstate(13,j+1)=addstate(13,j+1)-1
cccccccccccccccccccccccccccccc                        
c                        write(6,*) 'losing full lateral contact, seammult ne 1'
                        seammult(13,j+1)=17.2
c                        seammult(13,j+1)=1.0		!to turn off
cccccccccccccccccccccccccccccc                        
                        
c Needs to be a special case that determines if subunit goes to dstate 5/6.
                        if (state(12,j+2).eq.0) then												!State of this coordinate
c                           write(6,*) 'space is empty: ',12,j+2										!determines if dstate goes
c                           write(6,*) 'special dstate 8 change for ',13,j+1							!to 5/6 or 10/11
                           if (state(13,j).eq.1) then
c                              write(6,*) 'dstate 8 -> 5, should be slow, need to recalculate'
                              dissocstate(13,j+1)=5
                              times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                              call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                           elseif (state(13,j).eq.-1) then
c                              write(6,*) 'dstate 8 -> 6, should be slow, need to recalculate'
                              dissocstate(13,j+1)=6
                              times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                              call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)
                           else
                              write(6,*) 'bad state for vertical subunit: ',13,j
                              stop
                           endif
                        else
                        
                           if ((state(13,j+1).eq.1).and.(state(13,j).eq.1)) then
                              dissocstate(13,j+1)=10
c      	   	                  write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                              times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                              call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                           elseif ((state(13,j+1).eq.1).and.(state(13,j).eq.-1)) then
                              dissocstate(13,j+1)=11
c      		                  write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                              times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                              call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                           elseif ((state(13,j+1).eq.-1).and.(state(13,j).eq.1)) then
                              dissocstate(13,j+1)=11
c      		                  write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                              times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
                              call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                           elseif ((state(13,j+1).eq.-1).and.(state(13,j).eq.-1)) then
                              dissocstate(13,j+1)=11
c      		                  write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(13,j+1)
                              times(ev(13,j+1,2))=get_evtime(dissocstate(13,j+1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+1))
c                              write(6,*) 'double GDP'
                              times(ev(13,j+1,2))=GDP*times(ev(13,j+1,2))
                              call update(event,revmap,ev(13,j+1,2),times(ev(13,j+1,2)),times,totev)                     
                           else
                              write(6,*) 'bad nt states across seam'
                              stop
                           endif
                        endif
                        
                        ! adding seammult check for upper seam neighbor...
                        if (state(13,j+2).ne.0) then
                           seammult(13,j+2)=1.0
                           times(ev(13,j+2,2))=get_evtime(dissocstate(13,j+2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(13,j+2))
                           call update(event,revmap,ev(13,j+2,2),times(ev(13,j+2,2)),times,totev)
                        else
c                           write(6,*) 'leave alone'
                        endif
                        
                     else
                        write(6,*) 'have not handled this dtstate yet',dissocstate(13,j+1)
                        stop
                     endif




               if (ev(i,j-1,3).ne.0) then
c            write(6,*) 'Lose Hydrolysis at : ',i,j,ev(i,j-1,3)
                  nrecyc = nrecyc+1
      	          recyc(nrecyc) = ev(i,j-1,3)
      	          index=revmap(ev(i,j-1,3))
      	          nev(i,j-1)=nev(i,j-1)-1
      	          ev(i,j-1,3)=0
      	          call hpsort(nrecyc,recyc)
      	          temp=event(index)
	  	          event(index)=event(totev)
	  	          event(totev)=temp
	  	          revmap(event(totev))=totev
	  	          revmap(event(index))=index
	  	          times(event(totev))=1d15
c	  				       				do kk=1,totev+5
c         			write(6,*) 'times ',kk,times(event(kk)),event(kk),revmap(kk)
c      				end do            

                  totev=totev-1
	  	          call min_heapify(event,revmap,times,1,totev)      			  			
      	       endif

c               stop




            





            
         else
            write(6,*) 'need to do the remaining conditions for pf#1'
            stop
         endif

      return
      end
C
C
C +++++
C
C
      subroutine SubFrom13(ntub,i,j,state,addstate,dissocstate,dep,ev,nev,
     @                    nrecyc,recyc,event,revmap,totev,times,k_on,
     @                    conc,GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,seammult,k_ne)         

      implicit none
      
      integer ntub,i,j,nrecyc,totev,recyc(*)
      integer revmap(*),event(*)     
      integer dissocstate(13,*),addstate(13,*),state(13,*)
      integer nev(13,*),dep(13,*),ev(13,2000,*)
      double precision k_on,conc,GDP,K_lat,K_long,K_both,k_hyd,times(*)
      double precision K_thr_long,K_thr_lat,K_all,k_ne
      integer temph,tempv,tempd,nremove,temp,index,kk
      logical qdebug,qwipe
      double precision get_evtime
      double precision seammult(13,*)
            
      integer lmax,ll
         
         qwipe=.false.
c         write(6,*) 'dissociating from pf#13'
c         write(6,*) 'make i,j seammult = 1'
         seammult(i,j)=1.0
         
         if (dissocstate(i,j).eq.2) then
c            write(6,*) 'dstate 2 from pf#13'
c            write(6,*) 'check above'
            if (state(i,j+1).eq.0) then
               if (addstate(i,j+1).ge.2) then
                  addstate(i,j+1)=addstate(i,j+1)-1
c                  write(6,*) 'empty above, more than 1 neighbor'
                  if (dissocstate(i,j+1).eq.5) then
                     dissocstate(i,j+1)=2
                  else
                     write(6,*) 'have not yet handled this check'
                     stop
                  endif
               elseif (addstate(i,j+1).eq.1) then
c                  write(6,*) 'empty above, 1 neighbor, remove event'
                  addstate(i,j+1) = addstate(i,j+1)-1
                  dissocstate(i,j+1)=0
                  if (ev(i,j+1,1).ne.0) then
                     call RemoveAdditionEvent(i,j+1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
      		      endif
               else
                  write(6,*) 'pf#1 dissocstate=2, bad addstate'
                  stop
               endif
            else
               write(6,*) 'something above, change addstate and remove gtp hydro'
               write(6,*) 'wiping'
               stop
               addstate(i,j+1) = addstate(i,j+1)-1
               if (ev(i,j,3).ne.0) then
c            if (qdebug) write(6,*) 'Lose Hydrolysis at : ',i,j,ev(i,j,3)
                  call RemoveHydroEvent(i,j,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
      	       endif
      	    endif
c      	    write(6,*) 'check below'
      	    if (j.eq.103) then
c      	       write(6,*) 'j=103, nothing to do below'
      	    else
c      	       write(6,*) 'j > 103, some work to do'
      	       if (state(i,j-1).eq.0) then
c      	          write(6,*) 'empty below, correct dstate'
      	          addstate(i,j-1)=addstate(i,j-1)-1
      	          if ((dissocstate(i,j-1).eq.5).or.(dissocstate(i,j-1).eq.6)) then	!changed June 10
c      	             write(6,*) 'make dissocstate go from 5 to 2'
      	             dissocstate(i,j-1) = 2
      	          elseif (dissocstate(i,j-1).eq.10) then
      	             dissocstate(i,j-1) = 5
      	          elseif (dissocstate(i,j-1).eq.11) then		!added June 10
      	             dissocstate(i,j-1) = 6
      	          elseif (dissocstate(i,j-1).eq.8) then
      	             if ((state(12,j-1).ne.0).and.(state(1,j-2).ne.0).and.(state(1,j-3).ne.0)) then
c      	                write(6,*) 'dstate below stays 8'
      	             else
c      	                write(6,*) 'make dissocstate go from 8 to 5, test for seam neighbs?'
      	                dissocstate(i,j-1)=5
      	             endif
      	          else
      	             write(6,*) 'below not dstate 5/6/8/10/11'
      	             stop
      	          endif
      	       else
      	          write(6,*) 'occupied below, need to handle'
      	          stop
      	       endif
      	    endif
c      	    write(6,*) 'check seam neighbor'
c      	    write(6,*) 'the below logis is specific for dstate=2'
      	    if (state(12,j).ne.0) then
c      	       write(6,*) 'left neighb, check righties now'
      	       if ( (state(1,j-2).ne.0).and.(state(1,j-1).ne.0) ) then
      	          write(6,*) 'inconsistent configuration 2-lat, stuff on both sides'
      	          stop
      	       elseif ( (state(1,j-2).ne.0).and.(state(1,j-1).eq.0) ) then
c      	          write(6,*) 'only lower half neighbor, do nothing'
      	       else
c      	          write(6,*) 'nothing on seam side, nothing to do!'
      	       endif
      	    else
c      	       write(6,*) 'neighbs all on seam side'
ccccccccccccccccccccccccccccccccccc      	    
c      	       write(6,*) 'neighbs all on seam side, just update seam multiplier'
      	       ! because i,j dstate was 2, seam neighbors should go from having a half neighbor
      	       ! to no neighbor if not in template
      	       if (j.gt.104) then
c      	          write(6,*) 'update seammult of lower seam neighbor'
         	      if (state(1,j-2).ne.0) then
c      	             write(6,*) 'lower seam neighbor losing half neigbor, make seammult=1'
      	             seammult(1,j-2)=1.0
      	             times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-2))
                     call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                  else
                     write(6,*) 'bad state for ',1,j-2
                     stop
                  endif
               else
c                  write(6,*) 'lower seam neighbor in template, do nothing'
               endif
               if (j.gt.103) then
c                  write(6,*) 'update seammult of upper seam neighbor'
                  if (state(1,j-1).ne.0) then
c      	             write(6,*) 'upper seam neighbor losing half neigbor, make seammult=1'
      	             seammult(1,j-1)=1.0
      	             times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-1))
                     call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                  else
                     write(6,*) 'bad state for ',1,j-1
                     stop
                  endif
               else
c                  write(6,*) 'upper seam neighbor in template, do nothing'
               endif
cccccccccccccccccccccccccccccccccc
      	    endif
      	    
c      	    write(6,*) 'check left neighbor'
      	    call CheckLatNeighb(i-1,j,state,addstate,ev,nrecyc,recyc,dissocstate,
     @                      event,revmap,times,totev,nev,qdebug,dep)


         elseif ((dissocstate(i,j).eq.3).or.(dissocstate(i,j).eq.4)) then
c            write(6,*) 'dissociating from pf#13, dstate=3/4'
c            write(6,*) 'check above'
            if (state(i,j+1).eq.0) then
               if (addstate(i,j+1).ge.2) then
                  write(6,*) 'empty above, more than 1 neighbor, not possible?'
                  stop
               elseif (addstate(i,j+1).eq.1) then
c                  write(6,*) 'empty above, 1 neighbor, remove event'
c 					do kk=1,totev
c         			write(6,*) 'times ',kk,times(event(kk)),event(kk),revmap(kk)
c      				end do
                  addstate(i,j+1) = addstate(i,j+1)-1
                  dissocstate(i,j+1)=0
                  if (ev(i,j+1,1).ne.0) then
                     call RemoveAdditionEvent(i,j+1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
      		      endif
               else
                  write(6,*) 'pf#13 dissocstate=3, bad addstate'
                  stop
               endif
            else
c               write(6,*) 'something above, change addstate and remove gtp hydro'
c               write(6,*) 'need to figure out the wiping'
               addstate(i,j+1) = addstate(i,j+1)-1
               addstate(i,j)=addstate(i,j)-1 !correct for losing the above guy
               if (ev(i,j,3).ne.0) then
                  call RemoveHydroEvent(i,j,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
      	       endif
               nremove=1
               call WipeFromSeam(i,j+1,nremove,ntub,dep,state,addstate,nrecyc,recyc,
     @                        ev,nev,dissocstate,event,revmap,totev,times,seammult)
     
c Adding commands to check stats of subunit across seam and above (1,j-1). 		              		!Moved to WipeFromSeam line #19937
c               if (state(1,j-1).eq.0) then															!
c                  write(6,*) 'checking subuint across seam and above: ',1,j-1						!
c                  if (dissocstate(1,j-1).eq.2) then												!
c                     if (addstate(1,j-1).eq.1) then												!
c                        write(6,*) 'dissocstate=2, 1 neighbor, remove event'						!
c                        dissocstate(1,j-1)=0														!
c                        if (ev(1,j-1,1).ne.0) then													!
c                           call RemoveAdditionEvent(1,j-1,nrecyc,recyc,revmap,ev,nev,				!
c     @                               addstate,event,times,totev)									!
c      		            endif																		!
c      		         elseif (addstate(1,j-1).eq.2) then												!
c      		            write(6,*) 'dissocstate=2, 2 neighbors, change addstate only'				!
c      		         else																			!
c      		            write(6,*) 'bad addstate for dissocstate 2'									!
c      		            stop																		!
c      		         endif																			!
c                  elseif (dissocstate(1,j-1).eq.5) then											!
c                     dissocstate(1,j-1)=3															!
c                  elseif (dissocstate(1,j-1).eq.12) then											!
c                     dissocstate(1,j-1)=5															!
c                  else																				!
c                     write(6,*) 'bad dissocstate/dissocstate has not been tested at ',1,j-1		!
c                     stop																			!
c                  endif																			!
c                  addstate(1,j-1)=addstate(1,j-1)-1												!
c               else																				!
c                  write(6,*) 'does subunit need to be removed at ',1,j-1,'?'						!
c                  stop																				!
c               endif																				!
               
      	    endif
c      	    write(6,*) 'check below'
      	    if (j.eq.103) then
c      	       write(6,*) 'j=103, nothing to do below'
      	    else
c      	       write(6,*) 'j > 103, some work to do'
      	       if (state(i,j-1).eq.0) then
c      	          write(6,*) 'empty below, correct dstate'
      	          addstate(i,j-1)=addstate(i,j-1)-1
      	          if (dissocstate(i,j-1).eq.5) then
c      	             write(6,*) 'make dissocstate go from 5 to 2'
      	             dissocstate(i,j-1) = 2
      	          elseif (dissocstate(i,j-1).eq.8) then
c      	             write(6,*) 'make dissocstate go from 8 to 5, test for seam neighbs?'
      	             if (state(1,j-1).ne.0) then
      	                write(6,*) 'something at upper seam neighbor'
      	                stop
      	             elseif (state(1,j-2).ne.0) then
      	                write(6,*) 'something at lower seam neighbor'
      	                stop
      	             else
c      	                write(6,*) 'nothing at seam neighbs'
      	                dissocstate(i,j-1) = 5
      	             endif
      	          else
      	             write(6,*) 'below not dstate 5/8'
      	             stop
      	          endif
      	       else
c      	          write(6,*) 'occupied below, need to handle'
      	          addstate(i,j-1)=addstate(i,j-1)-1
c Start nucleotide exchange fun here...      	          
c      	          write(6,*) 'remove hydrolysis event if not hydrolyzed'
         	      if (state(i,j-1).eq.1) then
c      	             write(6,*) 'not hydrolyzed, remove event'
                     if (ev(i,j-1,3).ne.0) then
                        call RemoveHydroEvent(i,j-1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)        		
                     endif
                  else
c                     write(6,*) 'hydrolyzed, do nothing'
                  endif
c End nucleotide exchange fun here...      	          
c      	          write(6,*) 'we are type=3, nothing to fix below'
      	          if ( (state(i-1,j).ne.0).and.(dissocstate(i-1,j).ne.2) ) then
c      	             write(6,*) 'should not have left neighb with dstate#2'
      	          else
c      	             call CheckLatNeighb(i-1,j,state,addstate,ev,nrecyc,recyc,dissocstate,
c     @                      event,revmap,times,totev,nev,qdebug,dep)
                  endif
c                  write(6,*) 'call CheckLatNeighb later'
      	       endif

      	    endif
      	    
c      	    write(6,*) 'check seam neighbor'
c      	    write(6,*) 'the below logis is specific for dstate=3'
      	    if (state(1,j-1).ne.0) then
      	       write(6,*) 'upper half seam neighbor, gotta go'
      	       stop
      	    else
c      	       write(6,*) 'empty upper seam neighb, leave dstate alone but correct RATE later when filled'
      	       if (addstate(1,j-2).eq.0) then
c      	          write(6,*) 'no meaningful neighbors, nothing to do'
      	       else
      	          if (j-2.gt.102) then
c      	             write(6,*) 'j-2 gt 102, FYI'
      	          else
c      	             write(6,*) 'j-2 le 102, do not do anything'
      	          endif
      	       endif
      	    endif
C
C only do the following check if we are looking above the base layer
C
            if (j.gt.104) then
      	       if (state(1,j-2).ne.0) then
c      	          write(6,*) 'lower half seam neighbor, maybe correct dstate'
      	          if (dissocstate(1,j-2).eq.5) then
c                     write(6,*) 'new dissocstate for lower seam neighb'
                     addstate(1,j-2) = addstate(1,j-2)-1
                     dissocstate(1,j-2)=3
ccccccccccccccccccccccccccccccc
c                     write(6,*) 'removing full lateral contact, make seammult ne 1'
                     seammult(1,j-2)=17.2
c                     seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                     
c      		         write(6,*) 'resetting dissocstate of H-neighb to ',dissocstate(1,j-2)
                     times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                     call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)      	       
                      if (j.gt.105) then
c                         write(6,*) 'special case, check 2 below across seam unless in template'
                         if (dissocstate(1,j-3).eq.10) then
c                            write(6,*) 'dstate 2 below: 10->5'
      	                    dissocstate(1,j-3)=5
                            times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                            call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                         elseif (dissocstate(1,j-3).eq.11) then
                            if (state(1,j-4).eq.1) then
c                               write(6,*) 'dstate 2 below: 11->5'
      	                       dissocstate(1,j-3)=5
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            elseif (state(1,j-4).eq.-1) then
c                               write(6,*) 'dstate below: 11->6'
      	                       dissocstate(1,j-3)=6
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            else
                               write(6,*) 'bad destate 2 below cross seam??'
                               stop
                            endif
                         elseif (dissocstate(1,j-3).eq.8) then
                            if (state(1,j-4).eq.1) then
c                               write(6,*) 'dstate 2 below: 8->12'
      	                       dissocstate(1,j-3)=12
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            elseif (state(1,j-4).eq.-1) then
c                               write(6,*) 'dstate below: 8->13'
      	                       dissocstate(1,j-3)=13
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            else
                               write(6,*) 'bad destate 2 below cross seam??'
                               stop
                            endif
                         else
                            write(6,*) 'dstate below is not 10,11,8'
                            stop
                         endif
                      endif
      	          elseif (dissocstate(1,j-2).eq.6) then
c                     write(6,*) 'new dissocstate for lower seam neighb'
                     addstate(1,j-2) = addstate(1,j-2)-1
                     dissocstate(1,j-2)=4
ccccccccccccccccccccccccccccccc
c                     write(6,*) 'removing full lateral contact, make seammult ne 1'
                     seammult(1,j-2)=17.2
c                     seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                     
c      		         write(6,*) 'resetting dissocstate of H-neighb to ',dissocstate(1,j-2)
                     times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                     call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)      	       
                      if (j.gt.105) then
c                         write(6,*) 'special case, check 2 below across seam'
                         if (dissocstate(1,j-3).eq.10) then
c                            write(6,*) 'dstate 2 below: 10->5'
      	                    dissocstate(1,j-3)=5
                            times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                            call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                         elseif (dissocstate(1,j-3).eq.11) then
                            if (state(1,j-4).eq.1) then
c                               write(6,*) 'dstate 2 below: 11->5'
      	                       dissocstate(1,j-3)=5
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            elseif (state(1,j-4).eq.-1) then
c                               write(6,*) 'dstate below: 11->6'
      	                       dissocstate(1,j-3)=6
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            else
                               write(6,*) 'bad destate 2 below cross seam??'
                               stop
                            endif
                         elseif (dissocstate(1,j-3).eq.8) then
                            if (state(1,j-4).eq.1) then
c                               write(6,*) 'dstate 2 below: 8->12'
      	                       dissocstate(1,j-3)=12
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            elseif (state(1,j-4).eq.-1) then
c                               write(6,*) 'dstate below: 8->13'
      	                       dissocstate(1,j-3)=13
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            else
                               write(6,*) 'bad destate 2 below cross seam??'
                               stop
                            endif
                         else
                            write(6,*) 'dstate below is not 10,11,8'
                            stop
                         endif
                      endif
      	          elseif (dissocstate(1,j-2).eq.12) then
c                     write(6,*) 'new dissocstate for lower seam neighb'
                     addstate(1,j-2) = addstate(1,j-2)-1
                     dissocstate(1,j-2)=5
ccccccccccccccccccccccccccccccc
c                     write(6,*) 'removing full lateral contact, make seammult ne 1'
                     seammult(1,j-2)=17.2
c                     seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                     
c      		         write(6,*) 'resetting dissocstate of H-neighb to ',dissocstate(1,j-2)
                     times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                     call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)      	       
      	          elseif (dissocstate(1,j-2).eq.13) then
c                     write(6,*) 'new dissocstate for lower seam neighb'
                     addstate(1,j-2) = addstate(1,j-2)-1
                     dissocstate(1,j-2)=6
ccccccccccccccccccccccccccccccc
c                     write(6,*) 'removing full lateral contact, make seammult ne 1'
                     seammult(1,j-2)=17.2
c                     seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                     
c      		         write(6,*) 'resetting dissocstate of H-neighb to ',dissocstate(1,j-2)
                     times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                     call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)      	       
      	          else
      	             write(6,*) 'lower seam neighb dstate 8,10, or 11, not implemented yet'
      	             stop
      	          endif


      	       else
c      	          write(6,*) 'empty lower seam neighb, maybe correct dissocstate'
c Start nucleotide exchange fun here...      	          
      	          if (dissocstate(1,j-2).eq.6) then
                     addstate(1,j-2) = addstate(1,j-2)-1
      	             dissocstate(1,j-2)=4
      	          elseif (dissocstate(1,j-2).eq.5) then
                     addstate(1,j-2) = addstate(1,j-2)-1
      	             dissocstate(1,j-2)=3
      	          elseif (dissocstate(1,j-2).eq.2) then
      	             if (addstate(1,j-2).eq.1) then
c      	                write(6,*) 'remove addition event from here'
                        addstate(1,j-2) = addstate(1,j-2)-1
                        dissocstate(1,j-2)=0
                        if (ev(1,j-2,1).ne.0) then
                           call RemoveAdditionEvent(1,j-2,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
      		            endif
      		         else
c      		            write(6,*) 'addstate gt 1 across seam, leave dstate 2 alone'
      		            addstate(1,j-2)=addstate(1,j-2)-1
      		         endif
      	          elseif (dissocstate(1,j-2).eq.13) then
      	             dissocstate(1,j-2)=6			!changed June 10: 5->6
      	             addstate(1,j-2)=addstate(1,j-2)-1
      	          elseif (dissocstate(1,j-2).eq.12) then
      	             dissocstate(1,j-2)=5
      	             addstate(1,j-2)=addstate(1,j-2)-1
      	          else
      	             write(6,*) 'need to treat rest of dstates'
      	             stop
      	          endif
c Stop nucleotide exchange fun here...      	          
      	       endif
c      	    endif
      	    
C
C check lat neighb was here

            endif
c      	    write(6,*) 'check left neighbor'
c 					do kk=1,totev
c         			write(6,*) 'times b4 chklatneighb ',kk,times(event(kk)),event(kk),revmap(kk)
c      				end do
      	    call CheckLatNeighb(i-1,j,state,addstate,ev,nrecyc,recyc,dissocstate,
     @                      event,revmap,times,totev,nev,qdebug,dep)
c 					do kk=1,totev
c         			write(6,*) 'times after chklatneighb',kk,times(event(kk)),event(kk),revmap(kk)
c      				end do

c            write(6,*) 'when do we remove the hydrolysis event below?'
         elseif ((dissocstate(i,j).eq.5).or.(dissocstate(i,j).eq.6)) then
c            write(6,*) 'dissociating from type=5/6'

c            write(6,*) 'check above'
            if (state(i,j+1).eq.0) then
               if (addstate(i,j+1).ge.2) then
c                  write(6,*) 'empty above, more than 1 neighbor'
                  addstate(i,j+1)=addstate(i,j+1)-1
c Start nucleotide exchange fun here...                  
                  if ((dissocstate(i,j+1).eq.5).or.(dissocstate(i,j+1).eq.6)) then
                     dissocstate(i,j+1)=2
c End nucleotide exchange fun here...                     
                  else
                     write(6,*) 'have not yet handled this check'
                     stop
                  endif
               elseif (addstate(i,j+1).eq.1) then
c                  write(6,*) 'empty above, 1 neighbor, remove event'
                  addstate(i,j+1) = addstate(i,j+1)-1
                  dissocstate(i,j+1)=0
                  if (ev(i,j+1,1).ne.0) then
                     call RemoveAdditionEvent(i,j+1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
      		      endif
               else
                  write(6,*) 'pf#13 dissocstate=5, bad addstate'
                  stop
               endif
            else
c Need to make sure we really do need to wipe with dstate 5/6.
c               write(6,*) 'first, check if something below'
               if (state(i,j-1).eq.0) then
c                  write(6,*) 'empty below'
c                  write(6,*) 'now check addstate'
                  if (addstate(i,j-1).eq.1) then
                     write(6,*) 'bad addstate for dstate 5/6'
                     stop
                  elseif (addstate(i,j-1).eq.2) then
c                     write(6,*) 'dont need to wipe'
c                     write(6,*) 'need to call SubLowLef later'
                  elseif (addstate(i,j-1).gt.2) then
                     write(6,*) 'need to horizontally wipe?'
                     stop
                  endif
               else
c                  write(6,*) 'something below'
c                  write(6,*) 'something above, change addstate and remove gtp hydro'
c                  write(6,*) 'wiping is more elaborate here'
                  qwipe=.true.
                  addstate(i,j+1) = addstate(i,j+1)-1
                  addstate(i,j)=addstate(i,j)-1 !correct for losing the above guy
                  if (ev(i,j,3).ne.0) then
                     call RemoveHydroEvent(i,j,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
      	          endif
      	       endif
      	    endif
            if ((state(12,j).ne.0).and.(state(12,j-1).ne.0).and.(state(13,j-1).ne.0)) then			!add more conditions so we can also test for sublowrig
c               write(6,*) 'diag is to the left, call SubUppRig'
               addstate(12,j)=addstate(12,j)-1
               if (j.gt.103) addstate(i,j-1)=addstate(i,j-1)-1
               call SubUppRig(dep,dissocstate,state,i-1,j,i,j-1,temph,tempv,tempd)
               if (temph.ne.dissocstate(i-1,j)) then
c                  write(6,*) 'new dissocstate for H-neighb'
                  dissocstate(i-1,j)=temph
c      		      write(6,*) 'resetting dissocstate of H-neighb to ',dissocstate(i-1,j)
                  times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i-1,j))
c Need to add test for double GDP if dstate=11.
                  if (temph.eq.11) then
                     if ((state(i-1,j).eq.-1).and.(state(i-1,j-1).eq.-1)) then
c                        write(6,*) 'double GDP, recalculate times'
                        times(ev(i-1,j,2))=times(ev(i-1,j,2))*GDP
                     else
c                        write(6,*) 'single GDP, do nothing'
                     endif
                  endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
               endif
               if (tempv.ne.dissocstate(i,j-1)) then
                  if (j.gt.103) then
c                     write(6,*) 'new dissocstate for V-neighb'
                     dissocstate(i,j-1)=tempv
c      		         write(6,*) 'resetting dissocstate of V-neighb to ',dissocstate(i,j-1)
                     times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i,j-1))
                     call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)
                  else
c                     write(6,*)'on 1st row, leave 102 alone'
                  endif
               endif
               if (tempd.ne.dissocstate(i-1,j-1)) then
                  if (j.gt.103) then
c                     write(6,*) 'new dissocstate for D-neighb'
                     dissocstate(i-1,j-1)=tempd
c      		         write(6,*) 'resetting dissocstate of D-neighb to ',dissocstate(i-1,j-1)
                     times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i-1,j-1))
c Need to add test for double GDP if dstate=11.
                  if (tempd.eq.11) then
                     if ((state(i-1,j-1).eq.-1).and.(state(i-1,j-2).eq.-1)) then
c                        write(6,*) 'double GDP, recalculate times'
                        times(ev(i-1,j-1,2))=times(ev(i-1,j-1,2))*GDP
                     else
c                        write(6,*) 'single GDP, do nothing'
                     endif
                  endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
                     call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)
                  else
c                     write(6,*)'on 1st row, leave 102 alone'
                  endif
               endif
c               write(6,*) 'check across seam if j>104'
               if (j.gt.104) then
                   if (dissocstate(1,j-2).eq.2) then
                      if (addstate(1,j-2).eq.1) then
c                         write(6,*) 'dstate 2 across seam, 1 neighb => lose addition'
                         addstate(1,j-2)=addstate(1,j-2)-1
                         dissocstate(1,j-2)=0
                         if (ev(1,j-2,1).ne.0) then
                            call RemoveAdditionEvent(1,j-2,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)									!Second value was instead j-1
      		             endif
                      elseif (addstate(1,j-2).gt.1) then
c                         write(6,*) 'dstate 2 across seam, more than one neighb, leave alone'
                         addstate(1,j-2)=addstate(1,j-2)-1
                      else
                         write(6,*) 'dstate 2 across seam, less than 1 neighb?'
                         stop
                      endif
                   elseif (dissocstate(1,j-2).eq.5) then
                      addstate(1,j-2)=addstate(1,j-2)-1
                      dissocstate(1,j-2)=3
ccccccccccccccccccccccccccccccc
c                      write(6,*) 'removing full lateral contact, make seammult ne 1'
                      seammult(1,j-2)=17.2
c                      seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                      
c      		          write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
      		          if (state(1,j-2).ne.0) then
                         times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                         call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev) 
                      if (j.gt.105) then
c                         write(6,*) 'special case, check 2 below across seam'
                         if (dissocstate(1,j-3).eq.10) then
c                            write(6,*) 'dstate 2 below: 10->5'
      	                    dissocstate(1,j-3)=5
                            times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                            call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                         elseif (dissocstate(1,j-3).eq.11) then
                            if (state(1,j-4).eq.1) then
c                               write(6,*) 'dstate 2 below: 11->5'
      	                       dissocstate(1,j-3)=5
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            elseif (state(1,j-4).eq.-1) then
c                               write(6,*) 'dstate below: 11->6'
      	                       dissocstate(1,j-3)=6
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            else
                               write(6,*) 'bad destate 2 below cross seam??'
                               stop
                            endif
                         elseif (dissocstate(1,j-3).eq.8) then
                            if (state(1,j-4).eq.1) then
c                               write(6,*) 'dstate 2 below: 8->12'
      	                       dissocstate(1,j-3)=12
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            elseif (state(1,j-4).eq.-1) then
c                               write(6,*) 'dstate below: 8->13'
      	                       dissocstate(1,j-3)=13
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            else
                               write(6,*) 'bad destate 2 below cross seam??'
                               stop
                            endif
                         else
                            write(6,*) 'dstate below is not 10,11,8'
                            stop
                         endif
                      endif
                      endif
                   elseif (dissocstate(1,j-2).eq.6) then
                      addstate(1,j-2)=addstate(1,j-2)-1
                      dissocstate(1,j-2)=4
ccccccccccccccccccccccccccccccc
c                      write(6,*) 'removing full lateral contact, make seammult ne 1'
                      seammult(1,j-2)=17.2
c                      seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                      
c      		          write(6,*) 'resetting dissocstate of lower seam neighb to ',dissocstate(1,j-2)
      		          if (state(1,j-2).ne.0) then
                         times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                         call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev) 
                      if (j.gt.105) then
c                         write(6,*) 'special case, check 2 below across seam'
                         if (dissocstate(1,j-3).eq.10) then
c                            write(6,*) 'dstate 2 below: 10->5'
      	                    dissocstate(1,j-3)=5
                            times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                            call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                         elseif (dissocstate(1,j-3).eq.11) then
                            if (state(1,j-4).eq.1) then
c                               write(6,*) 'dstate 2 below: 11->5'
      	                       dissocstate(1,j-3)=5
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            elseif (state(1,j-4).eq.-1) then
c                               write(6,*) 'dstate below: 11->6'
      	                       dissocstate(1,j-3)=6
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            else
                               write(6,*) 'bad destate 2 below cross seam??'
                               stop
                            endif
                         elseif (dissocstate(1,j-3).eq.8) then
                            if (state(1,j-4).eq.1) then
c                               write(6,*) 'dstate 2 below: 8->12'
      	                       dissocstate(1,j-3)=12
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            elseif (state(1,j-4).eq.-1) then
c                               write(6,*) 'dstate below: 8->13'
      	                       dissocstate(1,j-3)=13
                               times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-3))
                               call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                            else
                               write(6,*) 'bad destate 2 below cross seam??'
                               stop
                            endif
                         else
                            write(6,*) 'dstate below is not 10,11,8'
                            stop
                         endif
                      endif
                      endif
                   elseif (dissocstate(1,j-2).eq.12) then
                      addstate(1,j-2)=addstate(1,j-2)-1
                      dissocstate(1,j-2)=5
ccccccccccccccccccccccccccccccc
c                      write(6,*) 'removing full lateral contact, make seammult ne 1'
                      seammult(1,j-2)=17.2
c                      seammult(1,j-2)=1.0		!to turn off 
ccccccccccccccccccccccccccccccc                      
c      		          write(6,*) 'resetting dissocstate of lower seam neighb to ',dissocstate(1,j-2)
      		          if (state(1,j-2).ne.0) then
                         times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                         call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev) 
                      endif
                   elseif (dissocstate(1,j-2).eq.13) then
                      addstate(1,j-2)=addstate(1,j-2)-1
                      dissocstate(1,j-2)=6
ccccccccccccccccccccccccccccccc
c                      write(6,*) 'removing full lateral contact, make seammult ne 1'
                      seammult(1,j-2)=17.2
c                      seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                      
c      		          write(6,*) 'resetting dissocstate of lower seam neighb to ',dissocstate(1,j-2)
      		          if (state(1,j-2).ne.0) then
                         times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                         call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev) 
                      endif
                   else
                      write(6,*) 'not handled dstates for across seam check yet'
                      stop
                   endif
                endif
                
c Now SubLowRig inclusion...            
            elseif ((state(12,j+1).ne.0).and.(state(12,j).ne.0).and.(state(13,j+1).ne.0)) then			!now SubLowRig
c               write(6,*) 'diag is to the upper right, call SubLowLef'
               temph = dissocstate(i-1,j)
               tempv = dissocstate(i,j+1)
               tempd = dissocstate(i-1,j+1)
               call SubLowLef(dep,dissocstate,state,i-1,j,i,j+1,temph,tempv,tempd)
               addstate(i-1,j)=addstate(i-1,j)-1
               addstate(i,j+1)=addstate(i,j+1)-1
               if (temph.ne.dissocstate(i-1,j)) then
c                  write(6,*) 'new dissocstate for H-neighb'
                  dissocstate(i-1,j)=temph
c      		      write(6,*) 'resetting dissocstate of H-neighb to ',dissocstate(i-1,j),temph
                  times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(i-1,j))
c Need to add test for double GDP if dstate=11.
                  if (temph.eq.11) then
                     if ((state(i-1,j).eq.-1).and.(state(i-1,j-1).eq.-1)) then
c                        write(6,*) 'double GDP, recalculate times'
                        times(ev(i-1,j,2))=times(ev(i-1,j,2))*GDP
                     else
c                        write(6,*) 'single GDP, do nothing'
                     endif
                  endif
ccccccccccccccccccccccccccccccccccccccccccccccc
                  call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
               endif
               if (tempv.ne.dissocstate(i,j+1)) then
c                  write(6,*) 'new dissocstate for V-neighb'
                  dissocstate(i,j+1)=tempv
c      	          write(6,*) 'resetting dissocstate of V-neighb to ',dissocstate(i,j+1)
                  times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(i,j+1))
                  call update(event,revmap,ev(i,j+1,2),times(ev(i,j+1,2)),times,totev)
               endif
               if (tempd.ne.dissocstate(i-1,j+1)) then
c                  write(6,*) 'new dissocstate for D-neighb'
                  dissocstate(i-1,j+1)=tempd
c      		      write(6,*) 'resetting dissocstate of D-neighb to ',dissocstate(i-1,j+1)
                  times(ev(i-1,j+1,2))=get_evtime(dissocstate(i-1,j+1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(i-1,j+1))
c Need to add test for double GDP if dstate=11.
                  if (tempd.eq.11) then
                     if ((state(i-1,j+1).eq.-1).and.(state(i-1,j).eq.-1)) then
c                        write(6,*) 'double GDP, recalculate times'
                        times(ev(i-1,j+1,2))=times(ev(i-1,j+1,2))*GDP
                     else
c                        write(6,*) 'single GDP, do nothing'
                     endif
                  endif
ccccccccccccccccccccccccccccccccccccccccccccccc
                  call update(event,revmap,ev(i-1,j+1,2),times(ev(i-1,j+1,2)),times,totev)
               endif
      	       if (j.gt.104) then
         	        if (state(1,j-2).ne.0) then
         	         write(6,*) 'should be no change for lower seam neighbor'
         	         write(6,*) 'possible recalculation for faster time (half neighbor less)'
      	          else
c      	             write(6,*) 'empty lower seam neighbor'
c      	             write(6,*) 'should be no change for lower seam neighbor'
                  endif
               else
c                  write(6,*) 'no change to lower seam neighbor, on template'
               endif
               
c               write(6,*) 'may need to check upper seam neighbor'
               if (j.gt.103) then
                  if (state(1,j-1).ne.0) then
c                     write(6,*) 'upper seam neighbor is present'
                     if (dissocstate(1,j-1).eq.2) then
                        if (addstate(1,j-1).eq.1) then
                           write(6,*) 'dstate=2 , addstate=1'
                           write(6,*) 'need to wipe ',1,j-1,'?'
                           stop
                        elseif (addstate(1,j-1).eq.2) then
c                           write(6,*) 'dstate=2 , addstate=2'
c                           write(6,*) 'update addstate for ',1,j-1
                           addstate(1,j-1)=addstate(1,j-1)-1
                        else
                           write(6,*) 'bad addstate/dstate for ',1,j-1
                           stop
                        endif
                     elseif (dissocstate(1,j-1).eq.5) then
c                        write(6,*) 'dstate=5, make sure nothing below ',1,j-1          
                        if (state(1,j-2).eq.0) then
c                           write(6,*) 'dstate 5 -> 3, should be slow 3'
                           addstate(1,j-1)=addstate(1,j-1)-1
                           dissocstate(1,j-1)=3
ccccccccccccccccccccccccccccccc
c                           write(6,*) 'removing full lateral contact, make seammult ne 1'
                           seammult(1,j-1)=17.2
c                           seammult(1,j-1)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                           
                           times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-1))
                           call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                        else
                           write(6,*) 'bad dstate somewhere?'
                           stop
                        endif
                     elseif (dissocstate(1,j-1).eq.6) then
c                        write(6,*) 'dstate=6, make sure nothing below ',1,j-1   
                        if (state(1,j-2).eq.0) then
c                           write(6,*) 'dstate 6 -> 4, should be slow 4'
                           addstate(1,j-1)=addstate(1,j-1)-1
                           dissocstate(1,j-1)=4
ccccccccccccccccccccccccccccccc
c                           write(6,*) 'removing full lateral contact, make seammult ne 1'
                           seammult(1,j-1)=17.2
c                           seammult(1,j-1)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                           
                           times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-1))
                           call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                        else
                           write(6,*) 'bad dstate somewhere?'
                           stop
                        endif
                     elseif (dissocstate(1,j-1).eq.12) then
c                        write(6,*) 'dstate=12, make sure nothing below ',1,j-1
                        if (state(1,j-2).eq.0) then
c                           write(6,*) 'dstate 12 -> 5, should be slow 5'
                           addstate(1,j-1)=addstate(1,j-1)-1
                           dissocstate(1,j-1)=5
ccccccccccccccccccccccccccccccc
c                           write(6,*) 'removing full lateral contact, make seammult ne 1'
                           seammult(1,j-1)=17.2
c                           seammult(1,j-1)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                           
                           times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-1))
                           call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                        else
                           write(6,*) 'bad dstate somewhere?'
                           stop
                        endif
                     elseif (dissocstate(1,j-1).eq.13) then
c                        write(6,*) 'dstate=13, make sure nothing below ',1,j-1
                        if (state(1,j-2).eq.0) then
c                           write(6,*) 'dstate 13 -> 6, should be slow 6'
                           addstate(1,j-1)=addstate(1,j-1)-1
                           dissocstate(1,j-1)=6
ccccccccccccccccccccccccccccccc
c                           write(6,*) 'removing full lateral contact, make seammult ne 1'
                           seammult(1,j-1)=17.2
c                           seammult(1,j-1)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                           
                           times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                                           K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                           K_all,k_ne,seammult(1,j-1))
                           call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                        else
                           write(6,*) 'bad dstate somewhere?'
                           stop
                        endif
                     else
                        write(6,*) 'bad dissocstate for ',1,j-1
                        stop
                     endif
                  else
c                     write(6,*) 'upper seam neighbor is not present'
                     if (dissocstate(1,j-1).eq.2) then
                        if (addstate(1,j-1).eq.1) then
c                           write(6,*) 'dstate=2 , addstate=1'
c                           write(6,*) 'remove event'
                           addstate(1,j-1)=0
                           dissocstate(1,j-1)=0
                           call RemoveAdditionEvent(1,j-1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
                        elseif (addstate(1,j-1).eq.2) then
c                           write(6,*) 'dstate=2 , addstate=2'
c                           write(6,*) 'update addstate for ',1,j-1
                           addstate(1,j-1)=addstate(1,j-1)-1
                        else
                           write(6,*) 'bad addstate/dstate for ',1,j-1
                           stop
                        endif
                     elseif (dissocstate(1,j-1).eq.5) then
c                        write(6,*) 'dstate 5 -> 3'
                        addstate(1,j-1)=addstate(1,j-1)-1
                        dissocstate(1,j-1)=3
                     elseif (dissocstate(1,j-1).eq.12) then
c                        write(6,*) 'dstate 12 -> 5'
                        addstate(1,j-1)=addstate(1,j-1)-1
                        dissocstate(1,j-1)=5
                     else
                        write(6,*) 'bad dissocstate for ',1,j-1
                        stop
                     endif
                  endif
               else
c                  write(6,*) 'dont change upper seam neighbor, is in template'
               endif

            else
c               write(6,*) 'diag is across the seam, need to work out'
c               write(6,*) 'correct dstates of left neighbor'
      	    call CheckLatNeighb(i-1,j,state,addstate,ev,nrecyc,recyc,dissocstate,
     @                      event,revmap,times,totev,nev,qdebug,dep)
               if (j.eq.103) then																	 
c                  write(6,*) 'nothing to do, this is always a type=5 site'							
               else																				
c                  write(6,*) 'j > 103, need to check status of at least one seam neighb'			
                  ! always check j-1, do j-2 *if* j.gt.104
c                  write(6,*) 'fixing dstate for j-1'
                  addstate(i,j-1)=addstate(i,j-1)-1
                  if (dissocstate(i,j-1).eq.10) then
                        dissocstate(i,j-1)=5
c      		            write(6,*) 'resetting dissocstate of lower to ',dissocstate(i,j-1)
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                     
                  elseif (dissocstate(i,j-1).eq.11) then !if we are 5 and below is 11, test
                        if (state(i,j-2).eq.1) then
                           dissocstate(i,j-1)=5
c      		               write(6,*) 'resetting dissocstate of lower to ',dissocstate(i,j-1)
                           times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i,j-1))
                           call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev) 
                        elseif (state(i,j-2).eq.-1) then
                           dissocstate(i,j-1)=6
c      		               write(6,*) 'resetting dissocstate of lower to ',dissocstate(i,j-1)
                           times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i,j-1))
                           call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)
                        else
                           write(6,*) 'empty below?'
                           stop
                        endif
                  elseif (dissocstate(i,j-1).eq.8) then
                     if (state(i,j-2).eq.1) then
                        dissocstate(i,j-1)=12
c      		            write(6,*) 'resetting dissocstate of lower to ',dissocstate(i,j-1)
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                     
                     elseif (state(i,j-2).eq.-1) then
                        dissocstate(i,j-1)=13
c      		            write(6,*) 'resetting dissocstate of lower to ',dissocstate(i,j-1)
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)                     
                     else
                        write(6,*) 'empty below ??'
                        stop
                     endif
                  else
                     write(6,*) 'dstate below not 10,11,8'
                     stop
                  endif
C
C I took this out b/c it seemed redundant
C
c                  if (state(i,j+1).ne.0) then
c                     write(6,*) 'we have a wiping situation, this gets complicated'
c                     stop
c                  endif
                  if (j.gt.104) then
                     !here we might have to change the type
                     if (dissocstate(1,j-2).eq.5) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=3
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev) 
c                        write(6,*) 'do i need to check 2 below?'
c                        stop
c We need to check 2 below if dstate of 2 below is 10,11 or 8 and is not in template.
                        if (j.gt.105) then
c                           write(6,*) 'checking 2 below'
                           if (dissocstate(1,j-3).eq.8) then
                              if (state(2,j-2).eq.0) then
                                 if (state(1,j-4).eq.1) then
c                                    write(6,*) 'dstate 8 -> 12 for ',1,j-3
                                    dissocstate(1,j-3)=12
                                    times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                    call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                                 elseif (state(1,j-4).eq.-1) then
c                                    write(6,*) 'dstate 8 -> 13 for ',1,j-3
                                    dissocstate(1,j-3)=13
                                    times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                    call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                                 else
                                    write(6,*) 'bad state for ',1,j-4
                                    stop
                                 endif
                              else
                                 write(6,*) 'bad dstate for ',1,j-2
                                 stop
                              endif
                           elseif (dissocstate(1,j-3).eq.11) then
                              if (state(1,j-4).eq.1) then
c                                 write(6,*) 'dstate 11 -> 5 for ',1,j-3
                                 dissocstate(1,j-3)=5
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (state(1,j-4).eq.-1) then
c                                 write(6,*) 'dstate 11 -> 6 for ',1,j-3
                                 dissocstate(1,j-3)=6
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              else
                                 write(6,*) 'bad state for ',1,j-4
                                 stop
                              endif
                           elseif (dissocstate(1,j-3).eq.10) then
                              write(6,*) 'dstate 10 -> 5 for ',1,j-3
                              dissocstate(1,j-3)=5
                              times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                              call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                           else
c                              write(6,*) 'no change for ',1,j-3
c                              write(6,*) 'dstate is: ',dissocstate(1,j-3)
                           endif
                        else
c                           write(6,*) 'no change for ',1,j-3
c                           write(6,*) 'subunit is in template'
                        endif
                        !checking upper seam neighbor to see if seam mult needs to be changed...
                        if (state(1,j-1).ne.0) then
                           if ((dissocstate(1,j-1).eq.3).or.(dissocstate(1,j-1).eq.4)) then
c                              write(6,*) 'losing half neighbor at: ',1,j-1,'. Need to make seammult=1.'
                              seammult(1,j-1)=1.0
                              times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-1))
                              call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                           else
                              write(6,*) 'bad dissocstate?'
                              stop
                           endif
                        else
c                           write(6,*) 'do nothing for upper seam neighbor: ',1,j-1
                        endif
                     elseif (dissocstate(1,j-2).eq.6) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=4
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)                     
c                        write(6,*) 'do i need to check 2 below?'
c                        stop
c We need to check 2 below if dstate of 2 below is 10,11 or 8 and is not in template.
                        if (j.gt.105) then
c                           write(6,*) 'checking 2 below'
                           if (dissocstate(1,j-3).eq.8) then
                              if (state(2,j-2).eq.0) then
                                 if (state(1,j-4).eq.1) then
c                                    write(6,*) 'dstate 8 -> 12 for ',1,j-3
                                    dissocstate(1,j-3)=12
                                    times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                    call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                                 elseif (state(1,j-4).eq.-1) then
c                                    write(6,*) 'dstate 8 -> 13 for ',1,j-3
                                    dissocstate(1,j-3)=13
                                    times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                    call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                                 else
                                    write(6,*) 'bad state for ',1,j-4
                                    stop
                                 endif
                              else
                                 write(6,*) 'bad dstate for ',1,j-2
                                 stop
                              endif
                           elseif (dissocstate(1,j-3).eq.11) then
                              if (state(1,j-4).eq.1) then
c                                 write(6,*) 'dstate 11 -> 5 for ',1,j-3
                                 dissocstate(1,j-3)=5
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (state(1,j-4).eq.-1) then
c                                 write(6,*) 'dstate 11 -> 6 for ',1,j-3
                                 dissocstate(1,j-3)=6
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              else
                                 write(6,*) 'bad state for ',1,j-4
                                 stop
                              endif
                           elseif (dissocstate(1,j-3).eq.10) then
c                              write(6,*) 'dstate 10 -> 5 for ',1,j-3
                              dissocstate(1,j-3)=5
                              times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                              call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                           else
c                              write(6,*) 'no change for ',1,j-3
c                              write(6,*) 'dstate is: ',dissocstate(1,j-3)
                           endif
                        else
c                           write(6,*) 'no change for ',1,j-3
c                           write(6,*) 'subunit is in template'
                        endif
                        !checking upper seam neighbor to see if seam mult needs to be changed...
                        if (state(1,j-1).ne.0) then
                           if ((dissocstate(1,j-1).eq.3).or.(dissocstate(1,j-1).eq.4)) then
c                              write(6,*) 'losing half neighbor at: ',1,j-1,'. Need to make seammult=1.'
                              seammult(1,j-1)=1.0
                              times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-1))
                              call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                           else
                              write(6,*) 'bad dissocstate?'
                              stop
                           endif
                        else
c                           write(6,*) 'do nothing for upper seam neighbor: ',1,j-1
                        endif
c Dstate 10/11 can occur...
                     elseif (dissocstate(1,j-2).eq.10) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=3
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                        !added May 31: checking 2 below if not in template...
c                        write(6,*) 'removing next to dstate 10, need to look 2 below'
                        if (j.gt.105) then
                           if (dissocstate(1,j-3).eq.8) then
                              if (state(1,j-4).eq.1) then
                                 dissocstate(1,j-3)=12
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (state(1,j-4).eq.-1) then
                                 dissocstate(1,j-3)=13
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              else
                                 write(6,*) 'bad state for: ',1,j-4
                                 stop
                              endif
                           elseif (dissocstate(1,j-3).eq.10) then
                              dissocstate(1,j-3)=5
                              times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                              call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                           elseif (dissocstate(1,j-3).eq.11) then
                              if (state(1,j-4).eq.1) then		!May 31: changed dissocstate to state
                                 dissocstate(1,j-3)=5
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (state(1,j-4).eq.-1) then
                                 dissocstate(1,j-3)=6
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              else
                                 write(6,*) 'bad state for: ',1,j-4
                                 stop
                              endif
                           else
c                              write(6,*) 'not dstate 8/10/11 at 2 below'
                           endif
                        else
c                           write(6,*) 'in template, do nothing'
                        endif
                     elseif (dissocstate(1,j-2).eq.11) then
                        addstate(1,j-2)=addstate(1,j-2)-1
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
                        if (state(1,j-3).eq.1) then
                           dissocstate(1,j-2)=3
c                           write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                        elseif (state(1,j-3).eq.-1) then
                           dissocstate(1,j-2)=4
c                           write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                        else
                           write(6,*) 'bad state for ',1,j-3
                           stop
                        endif
                        !added May 31: checking 2 below if not in template...
c                        write(6,*) 'removing next to dstate 11, need to look 2 below'
                        if (j.gt.105) then
                           if (dissocstate(1,j-3).eq.8) then
                              if (state(1,j-4).eq.1) then
                                 dissocstate(1,j-3)=12
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (state(1,j-4).eq.-1) then
                                 dissocstate(1,j-3)=13
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              else
                                 write(6,*) 'bad state for: ',1,j-4
                                 stop
                              endif
                           elseif (dissocstate(1,j-3).eq.10) then
                              dissocstate(1,j-3)=5
                              times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                              call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                           elseif (dissocstate(1,j-3).eq.11) then
                              if (state(1,j-4).eq.1) then		!May 31: changed dissocstate to state
                                 dissocstate(1,j-3)=5
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (state(1,j-4).eq.-1) then
                                 dissocstate(1,j-3)=6
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              else
                                 write(6,*) 'bad state for: ',1,j-4
                                 stop
                              endif
                           else
c                              write(6,*) 'not dstate 8/10/11 at 2 below'
                           endif
                        else
c                           write(6,*) 'in template, do nothing'
                        endif
                     elseif (dissocstate(1,j-2).eq.12) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=5
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                        !checking upper seam neighbor to see if seam mult needs to be changed...
                        if (state(1,j-1).ne.0) then
                           if ((dissocstate(1,j-1).eq.3).or.(dissocstate(1,j-1).eq.4)) then
c                              write(6,*) 'losing half neighbor at: ',1,j-1,'. Need to make seammult=1.'
                              seammult(1,j-1)=1.0
                              times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-1))
                              call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                           else
                              write(6,*) 'bad dissocstate?'
                              stop
                           endif
                        else
c                           write(6,*) 'do nothing for upper seam neighbor: ',1,j-1
                        endif
                     elseif (dissocstate(1,j-2).eq.13) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=6
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                        !checking upper seam neighbor to see if seam mult needs to be changed...
                        if (state(1,j-1).ne.0) then
                           if ((dissocstate(1,j-1).eq.3).or.(dissocstate(1,j-1).eq.4)) then
c                              write(6,*) 'losing half neighbor at: ',1,j-1,'. Need to make seammult=1.'
                              seammult(1,j-1)=1.0
                              times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-1))
                              call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                           else
                              write(6,*) 'bad dissocstate?'
                              stop
                           endif
                        else
c                           write(6,*) 'do nothing for upper seam neighbor: ',1,j-1
                        endif
                     elseif (dissocstate(1,j-2).eq.8) then
                        addstate(1,j-2)=addstate(1,j-2)-1
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
                        
c Needs to be a special case that determines if subunit goes to dstate 5/6.
                        if (state(2,j-1).eq.0) then													!State of this coordinate
c                           write(6,*) 'space is empty: ',2,j-1										!determines if dstate goes
c                           write(6,*) 'special dstate 8 change for ',1,j-2							!to 5/6 or 10/11
                           if (state(1,j-3).eq.1) then
c                              write(6,*) 'dstate 8 -> 5, should be slow, need to recalculate'
                              dissocstate(1,j-2)=5
                              times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                              call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                           elseif (state(1,j-3).eq.-1) then
c                              write(6,*) 'dstate 8 -> 6, should be slow, need to recalculate'
                              dissocstate(1,j-2)=6
                              times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                              call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                           else
                              write(6,*) 'bad state for vertical subunit: ',1,j-3
                              stop
                           endif
                        
                        else
                           if ((state(1,j-2).eq.1).and.(state(1,j-3).eq.1)) then
c                              write(6,*) 'dstate 8 -> 10'
                              dissocstate(1,j-2)=10
c      		                  write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
                              times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                              call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)                                          
                           elseif ((state(1,j-2).eq.1).and.(state(1,j-3).eq.-1)) then
c                              write(6,*) 'dstate 8 -> 11,bot'
                              dissocstate(1,j-2)=11
c      		                  write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
                              times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                              call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)                                          
                           elseif ((state(1,j-2).eq.-1).and.(state(1,j-3).eq.1)) then
c                              write(6,*) 'dstate 8 -> 11,top'
                              dissocstate(1,j-2)=11
c      		                  write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
                              times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                              call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)                                          
                           elseif ((state(1,j-2).eq.-1).and.(state(1,j-3).eq.-1)) then
c                              write(6,*) 'double GDP at 8 across seam, need to treat'
                              dissocstate(1,j-2)=11
c      		                  write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
                              times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                              times(ev(1,j-2,2))=GDP*times(ev(1,j-2,2))
                              call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)                                          
                           else
                              write(6,*) 'bad nt states across seam'
                              stop
                           endif
                        endif
                        !checking upper seam neighbor to see if seam mult needs to be changed...
c                        write(6,*) 'check upper seam neighber to see if seammult needs to be updated'
                        if (state(1,j-1).ne.0) then
                           if ((dissocstate(1,j-1).eq.5).or.(dissocstate(1,j-1).eq.6).or.
     @                        (dissocstate(1,j-1).eq.10).or.(dissocstate(1,j-1).eq.11)) then
c                              write(6,*) 'losing half neighbor at: ',1,j-1,'. Need to make seammult=1.'
                              seammult(1,j-1)=1.0
                              times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-1))
                              call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                           elseif ((dissocstate(1,j-1).eq.3).or.(dissocstate(1,j-1).eq.4).or.
     @                            (dissocstate(1,j-1).eq.12).or.(dissocstate(1,j-1).eq.13)) then
c                              write(6,*) 'if seammult not 1 already, make 1'
                              seammult(1,j-1)=1.0
                              times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-1))
                              call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                           else
                              write(6,*) 'bad dissocstate: ',dissocstate(1,j-1)
                              write(6,*) 'Printing configuration'
      			write(6,'(13A)') '  1 ',' 2 ',' 3 ',' 4 ',' 5 ',' 6 ',' 7 ',
     @                     ' 8 ',' 9 ',' 10',' 11',' 12',' 13'
            lmax = int(ntub/13)+112
         	do ll=lmax,102,-1
            	write(6,'(13I3)') state(1,ll),state(2,ll),state(3,ll),
     @ 	state(4,ll),state(5,ll),state(6,ll),state(7,ll),state(8,ll),
     @ 	state(9,ll),state(10,ll),state(11,ll),state(12,ll),state(13,ll)
       	 end do
       	 write(6,*) ''
       	  do ll=lmax,102,-1
     		write(6,'(13I3)') dissocstate(1,ll),dissocstate(2,ll),
     @		dissocstate(3,ll),
     @ 		dissocstate(4,ll),dissocstate(5,ll),dissocstate(6,ll),
     @		dissocstate(7,ll),
     @ 		dissocstate(8,ll),dissocstate(9,ll),dissocstate(10,ll),
     @		dissocstate(11,ll),
     @ 		dissocstate(12,ll),dissocstate(13,ll)
          end do
                              stop
                           endif
                        else
                           write(6,*) 'bad state for: ',1,j-1
                           stop
                        endif
                     else
                        write(6,*) 'have not handled this dtstate yet',dissocstate(1,j-2)
                        stop
                     endif

                  endif
               endif
            endif
            if (qwipe) then
c               write(6,*) 'wiping from 13, dstate=5'
               nremove=1
               call WipeFromSeam(i,j+1,nremove,ntub,dep,state,addstate,nrecyc,recyc,
     @                        ev,nev,dissocstate,event,revmap,totev,times,seammult)
     
c Adding commands to check stats of subunit across seam and above (1,j-1).               			!Moved to WipeFromSeam line #19937
c               if (state(1,j-1).eq.0) then															!
c                  write(6,*) 'checking subuint across seam and above: ',1,j-1						!
c                  if (dissocstate(1,j-1).eq.2) then												!
c                     if (addstate(1,j-1).eq.1) then												!
c                        write(6,*) 'dissocstate=2, 1 neighbor, remove event'						!
c                        dissocstate(1,j-1)=0														!
c                        if (ev(1,j-1,1).ne.0) then													!
c                           call RemoveAdditionEvent(1,j-1,nrecyc,recyc,revmap,ev,nev,				!
c     @                               addstate,event,times,totev)									!
c      		            endif																		!
c      		         elseif (addstate(1,j-1).eq.2) then												!
c      		            write(6,*) 'dissocstate=2, 2 neighbors, change addstate only'				!
c      		         else																			!
c      		            write(6,*) 'bad addstate for dissocstate 2'									!
c      		            stop																		!
c      		         endif																			!
c                  elseif (dissocstate(1,j-1).eq.5) then											!
c                     dissocstate(1,j-1)=3															!
c                  elseif (dissocstate(1,j-1).eq.12) then											!
c                     dissocstate(1,j-1)=5															!
c                  else																				!
c                     write(6,*) 'bad dissocstate/dissocstate has not been tested at ',1,j-1		!
c                     stop																			!
c                  endif																			!
c                  addstate(1,j-1)=addstate(1,j-1)-1												!
c               else																				!
c                  write(6,*) 'does subunit need to be removed at ',1,j-1,'?'						!
c                  stop																				!
c               endif																				!
               
            endif
c Start nucleotide exchange fun here...            
c      	       write(6,*) 'remove hydrolysis event if not hydrolyzed'
      	       if (state(i,j-1).eq.1) then
c      	          write(6,*) 'not hydrolyzed, remove event'
                  if (ev(i,j-1,3).ne.0) then
                     call RemoveHydroEvent(i,j-1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)        		
                  endif
               else
c                  write(6,*) 'hydrolyzed, do nothing'
               endif
c End nucleotide exchange fun here...      	          

c New code for dissociating from dstate 10/11            
         elseif ((dissocstate(i,j).eq.10).or.(dissocstate(i,j).eq.11)) then
c            write(6,*) 'dissociating from dstate 10/11'
c            stop
            
c            write(6,*) 'check above, something should be there'
            if (state(i,j+1).ne.0) then
c               write(6,*) 'something above: ',i,j+1
               
               addstate(i,j+1)=addstate(i,j+1)-1
               if ((dissocstate(i,j+1).eq.5).or.(dissocstate(i,j+1).eq.6)) then
c                  write(6,*) 'dstate 5/6 -> 2 for ',i,j+1
                  dissocstate(i,j+1)=2
                  times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j+1))
                  call update(event,revmap,ev(i,j+1,2),times(ev(i,j+1,2)),times,totev)  
               elseif (dissocstate(i,j+1).eq.10) then
c                  write(6,*) 'dstate 10 -> 5 for ',i,j+1
                  dissocstate(i,j+1)=5
                  times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j+1))
                  call update(event,revmap,ev(i,j+1,2),times(ev(i,j+1,2)),times,totev)  
               elseif (dissocstate(i,j+1).eq.11) then
                  if (state(i,j+1).eq.1) then
c                     write(6,*) 'dstate 11 -> 5 for ',i,j+1
                     dissocstate(i,j+1)=5
                     times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j+1))
                     call update(event,revmap,ev(i,j+1,2),times(ev(i,j+1,2)),times,totev)  
                  elseif (state(i,j+1).eq.-1) then
c                     write(6,*) 'dstate 11 -> 6 for ',i,j+1
                     dissocstate(i,j+1)=6
                     times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j+1))
                     call update(event,revmap,ev(i,j+1,2),times(ev(i,j+1,2)),times,totev)  
                  else
                     write(6,*) 'bad state for ',i,j+1
                     stop
                  endif
               elseif (dissocstate(i,j+1).eq.8) then
                  if (state(i,j+1).eq.1) then
c                     write(6,*) 'dstate 8 -> 12 for ',i,j+1
                     dissocstate(i,j+1)=12
                     times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j+1))
                     call update(event,revmap,ev(i,j+1,2),times(ev(i,j+1,2)),times,totev)  
                  elseif (state(i,j+1).eq.-1) then
c                     write(6,*) 'dstate 8 -> 13 for ',i,j+1
                     dissocstate(i,j+1)=13
                     times(ev(i,j+1,2))=get_evtime(dissocstate(i,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j+1))
                     call update(event,revmap,ev(i,j+1,2),times(ev(i,j+1,2)),times,totev)  
                  else
                     write(6,*) 'bad state for ',i,j+1
                     stop
                  endif
               else
                  write(6,*) 'bad dstate/dstate not tested for ',i,j+1,': ',dissocstate(i,j+1)
                  stop
               endif
            else
               write(6,*) 'bad state for ',i,j+1
               stop
            endif
            
c            write(6,*) 'check below if not part of template'
            if (j.gt.103) then
c               write(6,*) 'not part of template'
               addstate(i,j-1)=addstate(i,j-1)-1
               if (state(i,j-1).ne.0) then
                  if (dissocstate(i,j-1).eq.10) then
c                     write(6,*) 'dstate 10 -> 5 for  ',i,j-1
                     dissocstate(i,j-1)=5
                     times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j-1))
                     call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)  
                  elseif (dissocstate(i,j-1).eq.11) then
                     if (state(i,j-2).eq.1) then
c                        write(6,*) 'dstate 11 -> 5'
                        dissocstate(i,j-1)=5
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)  
                     elseif (state(i,j-2).eq.-1) then
c                        write(6,*) 'dstate 11 -> 6'
                        dissocstate(i,j-2)=6
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)  
                     else
                        write(6,*) 'bad state for ',i,j-2
                        stop
                     endif
                  elseif (dissocstate(i,j-1).eq.8) then
                     if (state(i,j-2).eq.1) then
c                        write(6,*) 'dstate 8 -> 12'
                        dissocstate(i,j-1)=12
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)  
                     elseif (state(i,j-2).eq.-1) then
c                        write(6,*) 'dstate 8 -> 13'
                        dissocstate(i,j-1)=13														!changed (i,j-2) to (i,j-1)
                        times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i,j-1))
                        call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)  
                     else
                        write(6,*) 'bad state for ',i,j-2
                        stop
                     endif
                  else
                     write(6,*) 'bad dstate/dstate not tested for ',i,j-1,': ',dissocstate(i,j-1)
                     stop
                  endif
               else
                  write(6,*) 'bad state for ',i,j-1
                  stop
               endif
            else
c               write(6,*) 'dont mess with template, dont change ',i,j-1
            endif
            
c            write(6,*) 'look at how the 10/11 interactions are being made'
            if ((state(i-1,j+1).ne.0).and.(state(i-1,j).ne.0).and.(state(i-1,j-1).ne.0)) then
c               write(6,*) 'dstate 10/11 was not made across seam'
               
c               write(6,*) 'dep will have to change for ',i,j+1
c               write(6,*) 'dep before: ',dep(i,j+1)
               dep(i,j+1)=3
c               write(6,*) 'dep after: ',dep(i,j+1)
               
c               write(6,*) 'change dstates of ',i-1,j+1,', ',i-1,j,'and ',i-1,j-1
               
               if (dissocstate(i-1,j+1).eq.8) then
                  if ((state(i,j+2).ne.0).and.(state(i-1,j+2).ne.0).and.
     @               (state(i-2,j+2).ne.0).and.(state(i-2,j+1).ne.0).and.
     @               (state(i-2,j).ne.0)) then
c                     write(6,*) 'dissocstate stays 8 for ',i-1,j+1
                  elseif (state(i,j+2).eq.0) then
                     if ((state(i-1,j+1).eq.1).and.(state(i-1,j).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',i-1,j+1
                        dissocstate(i-1,j+1)=10
                        times(ev(i-1,j+1,2))=get_evtime(dissocstate(i-1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j+1))
                        call update(event,revmap,ev(i-1,j+1,2),times(ev(i-1,j+1,2)),times,totev)  
                     elseif ((state(i-1,j+1).eq.-1).or.(state(i-1,j).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',i-1,j+1
                        dissocstate(i-1,j+1)=11
                        times(ev(i-1,j+1,2))=get_evtime(dissocstate(i-1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j+1))
c Need to add test for double GDP if dstate=11.
                        if ((state(i-1,j+1).eq.-1).and.(state(i-1,j).eq.-1)) then
c                           write(6,*) 'double GDP, recalculate times'
                           times(ev(i-1,j+1,2))=times(ev(i-1,j+1,2))*GDP
                        else
c                           write(6,*) 'single GDP, do nothing'
                        endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(i-1,j+1,2),times(ev(i-1,j+1,2)),times,totev)  
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',i-1,j+1,'or ',i-1,j,'?'
                        stop
                     endif
                  elseif (state(i-2,j+2).eq.0) then
                     if (state(i-1,j).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',i-1,j+1
                        dissocstate(i-1,j+1)=5
                        times(ev(i-1,j+1,2))=get_evtime(dissocstate(i-1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j+1))
                        call update(event,revmap,ev(i-1,j+1,2),times(ev(i-1,j+1,2)),times,totev)  
                     elseif (state(i-1,j).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',i-1,j+1
                        dissocstate(i-1,j+1)=6
                        times(ev(i-1,j+1,2))=get_evtime(dissocstate(i-1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j+1))
                        call update(event,revmap,ev(i-1,j+1,2),times(ev(i-1,j+1,2)),times,totev)  
                     else
                        write(6,*) 'empty subunit: ',i-1,j,'?'
                        stop
                     endif
                  elseif (state(i-2,j).eq.0) then
                     if (state(i-1,j).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',i-1,j+1
                        dissocstate(i-1,j+1)=3
                        times(ev(i-1,j+1,2))=get_evtime(dissocstate(i-1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j+1))
                        call update(event,revmap,ev(i-1,j+1,2),times(ev(i-1,j+1,2)),times,totev)  
                     elseif (state(i-1,j).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',i-1,j+1
                        dissocstate(i-1,j+1)=4
                        times(ev(i-1,j+1,2))=get_evtime(dissocstate(i-1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j+1))
                        call update(event,revmap,ev(i-1,j+1,2),times(ev(i-1,j+1,2)),times,totev)  
                     else
                        write(6,*) 'empty subunit: ',i-1,j,'?'
                        stop
                     endif
                  endif
               elseif (dissocstate(i-1,j+1).eq.13) then
c                  write(6,*) 'dstate 13 -> 6 for ',i-1,j+1
                  dissocstate(i-1,j+1)=6
                  times(ev(i-1,j+1,2))=get_evtime(dissocstate(i-1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j+1))
                  call update(event,revmap,ev(i-1,j+1,2),times(ev(i-1,j+1,2)),times,totev)  
               elseif (dissocstate(i-1,j+1).eq.12) then
c                  write(6,*) 'dstate 12 -> 5 for ',i-1,j+1
                  dissocstate(i-1,j+1)=5
                  times(ev(i-1,j+1,2))=get_evtime(dissocstate(i-1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j+1))
                  call update(event,revmap,ev(i-1,j+1,2),times(ev(i-1,j+1,2)),times,totev)  
               elseif (dissocstate(i-1,j+1).eq.11) then
                  if (state(i-1,j).eq.1) then
c                     write(6,*) 'dstate 11 -> 3 for ',i-1,j+1
                     dissocstate(i-1,j+1)=3
                     times(ev(i-1,j+1,2))=get_evtime(dissocstate(i-1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j+1))
                     call update(event,revmap,ev(i-1,j+1,2),times(ev(i-1,j+1,2)),times,totev)  
                  elseif (state(i-1,j).eq.-1) then
c                     write(6,*) 'dstate 11 -> 4 for ',i-1,j+1
                     dissocstate(i-1,j+1)=4
                     times(ev(i-1,j+1,2))=get_evtime(dissocstate(i-1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j+1))
                     call update(event,revmap,ev(i-1,j+1,2),times(ev(i-1,j+1,2)),times,totev)  
                  else
                     write(6,*) 'empty subunit: ',i-1,j
                     stop
                  endif
               elseif (dissocstate(i-1,j+1).eq.6) then
c                  write(6,*) 'dstate 6 -> 4 for ',i-1,j+1
                  dissocstate(i-1,j+1)=4
                  times(ev(i-1,j+1,2))=get_evtime(dissocstate(i-1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j+1))
                  call update(event,revmap,ev(i-1,j+1,2),times(ev(i-1,j+1,2)),times,totev)  
               elseif ((dissocstate(i-1,j+1).eq.5).or.(dissocstate(i-1,j+1).eq.10)) then
c                  write(6,*) 'dstate 5/10 -> 3 for ',i-1,j+1
                  dissocstate(i-1,j+1)=3
                  times(ev(i-1,j+1,2))=get_evtime(dissocstate(i-1,j+1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j+1))
                  call update(event,revmap,ev(i-1,j+1,2),times(ev(i-1,j+1,2)),times,totev)  
               else
                  write(6,*) 'bad dissocstate',dissocstate(i-1,j+1),'for',i-1,j+1
                  stop
               endif
               
               if (dissocstate(i-1,j).eq.8) then								
                  addstate(i-1,j)=addstate(i-1,j)-1
                  if ((state(i-2,j+1).ne.0).and.(state(i-2,j).ne.0).and.
     @               (state(i-2,j-1).ne.0)) then
                     if ((state(i-1,j).eq.1).and.(state(i-1,j-1).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',i-1,j
                        dissocstate(i-1,j)=10
                        times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j))
                        call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                     elseif ((state(i-1,j).eq.-1).or.(state(i-1,j-1).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',i-1,j
                        dissocstate(i-1,j)=11
                        times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j))
c Need to add test for double GDP if dstate=11.
                        if ((state(i-1,j).eq.-1).and.(state(i-1,j-1).eq.-1)) then
c                           write(6,*) 'double GDP, recalculate times'
                           times(ev(i-1,j,2))=times(ev(i-1,j,2))*GDP
                        else
c                           write(6,*) 'single GDP, do nothing'
                        endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
                        call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',i-1,j,'or ',i-1,j-1,'?'
                        stop
                     endif
                  elseif (state(i-2,j+1).eq.0) then
                     if (state(i-1,j-1).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',i-1,j
                        dissocstate(i-1,j)=5
                        times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j))
                        call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                     elseif (state(i-1,j-1).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',i-1,j
                        dissocstate(i-1,j)=6
                        times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j))
                        call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                     else
                        write(6,*) 'empty subunit: ',i-1,j-1,'?'
                        stop
                     endif
                  elseif (state(i-2,j-1).eq.0) then
                     if (state(i-1,j-1).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',i-1,j
                        dissocstate(i-1,j)=3
                        times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j))
                        call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                     elseif (state(i-1,j-1).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',i-1,j
                        dissocstate(i-1,j)=4
                        times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j))
                        call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                     else
                        write(6,*) 'empty subunit: ',i-1,j-1,'?'
                        stop
                     endif
                  endif
               elseif (dissocstate(i-1,j).eq.11) then
                  addstate(i-1,j)=addstate(i-1,j)-1
                  if (state(i-1,j-1).eq.1) then
c                     write(6,*) 'dstate 11 -> 3 for ',i-1,j
                     dissocstate(i-1,j)=3
                     times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j))
                     call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                  elseif (state(i-1,j-1).eq.-1) then
c                     write(6,*) 'dstate 11 -> 4 for ',i-1,j
                     dissocstate(i-1,j)=4
                     times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j))
                     call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
                  else
                     write(6,*) 'empty subunit: ',i-1,j-1,'?'
                     stop
                  endif
               elseif (dissocstate(i-1,j).eq.10) then
                  addstate(i-1,j)=addstate(i-1,j)-1
c                  write(6,*) 'dstate 10 -> 3 for ',i-1,j
                  dissocstate(i-1,j)=3
                  times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j))
                  call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
               else
                  write(6,*) 'bad dissocstate',dissocstate(i-1,j),'for',i-1,j
                  stop
               endif
               
               if (j.gt.103) then
c                  write(6,*) 'can change dstate of ',i-1,j-1,', not part of template'
                  if (dissocstate(i-1,j-1).eq.8) then
                     if (state(i-2,j).ne.0) then
c                        write(6,*) 'dstate should stay 8 for ',i-1,j-1
                     else
                        if (state(i-1,j-2).eq.1) then
c                           write(6,*) 'dstate 8 -> 12 for ',i-1,j-1
                           dissocstate(i-1,j-1)=12
                           times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j-1))
                           call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)
                        elseif (state(i-1,j-2).eq.-1) then
c                           write(6,*) 'dstate 8 -> 13 for ',i-1,j-1
                           dissocstate(i-1,j-1)=13
                           times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j-1))
                           call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)
                        else
                           write(6,*) 'bad state for ',i-1,j-2,'?'
                           stop
                        endif
                     endif
                  elseif (dissocstate(i-1,j-1).eq.11) then
                     if (state(i-1,j-2).eq.1) then
c                        write(6,*) 'dstate 11 -> 5 for ',i-1,j-1
                        dissocstate(i-1,j-1)=5
                        times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j-1))
                        call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)
                     elseif (state(i-1,j-2).eq.-1) then
c                        write(6,*) 'dstate 11 -> 6 for ',i-1,j-1
                        dissocstate(i-1,j-1)=6
                        times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j-1))
                        call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)
                     else
                        write(6,*) 'empty subunit: ',i-1,j-2,'?'
                        stop
                     endif
                  elseif (dissocstate(i-1,j-1).eq.10) then
c                     write(6,*) 'dstate 10 -> 5 for ',i-1,j-1
                     dissocstate(i-1,j-1)=5
                     times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(i-1,j-1))
                     call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)
                  else
                     write(6,*) 'bad dstate/dstate not tested ',dissocstate(i-1,j-1),'for ',i-1,j-1
                     stop
                  endif
               else
c                  write(6,*) 'do not change ',i-1,j-1,', is part of template'
               endif
               
c               write(6,*) 'now look across seam to see if lower neighbor needs to be changed'
               if (j.gt.104) then
c                  write(6,*) 'lower seam neighbor not in template' 
                  if (state(1,j-2).eq.0) then
c                     write(6,*) 'lower seam neighbor empty'
                     if (dissocstate(1,j-2).eq.2) then
                        if (addstate(1,j-2).eq.1) then
c                           write(6,*) 'dstate=2, addstate=1, remove event for ',1,j-2
                           addstate(1,j-2)=addstate(1,j-2)-1
                           dissocstate(1,j-2)=0
                           call RemoveAdditionEvent(1,j-2,nrecyc,recyc,revmap,ev,nev,
     @                          addstate,event,times,totev)
                        elseif (addstate(1,j-2).eq.2) then
c                           write(6,*) 'dstate=2, addstate=2, remove addition at ',1,j-2
                           addstate(1,j-2)=addstate(1,j-2)-1
                        else
                           write(6,*) 'bad dstate/addstate for ',1,j-2
                           stop
                        endif
                     elseif (dissocstate(1,j-2).eq.5) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=3
c                        write(6,*) 'dstate 5 -> 3 for ',1,j-2
                     !added May 31 for nucleotide exchange experiments.
                     elseif (dissocstate(1,j-2).eq.6) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=4
c                        write(6,*) 'dstate 6 -> 4 for ',1,j-2
                     elseif (dissocstate(1,j-2).eq.12) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=5
c                        write(6,*) 'dstate 12 -> 5 for ',1,j-2
                     !added May 31 for nucleotide exchange experiments.
                     elseif (dissocstate(1,j-2).eq.13) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=6
c                        write(6,*) 'dstate 13 -> 6 for ',1,j-2
                     else
                        write(6,*) 'bad dstate for ',1,j-2,': ',dissocstate(1,j-2)
                        stop
                     endif
                  else
                     if (dissocstate(1,j-2).eq.2) then
                        if (addstate(1,j-2).eq.1) then
                           write(6,*) 'dstate=2, addstate=1, need to wipe ',1,j-2,'?'
                           stop
                        elseif (addstate(1,j-2).eq.2) then
c                           write(6,*) 'dstate=2, addstate=2, remove addition at ',1,j-2
                           addstate(1,j-2)=addstate(1,j-2)-1
                        else
                           write(6,*) 'bad dstate/addstate for ',1,j-2
                           stop
                        endif
                     elseif (dissocstate(1,j-2).eq.5) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=3
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
c                        write(6,*) 'dstate 5 -> 3 for ',1,j-2
c                        write(6,*) 'should be slow dstate 3, need to recalculate'
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                     elseif (dissocstate(1,j-2).eq.6) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=4
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
c                        write(6,*) 'dstate 6 -> 4 for ',1,j-2
c                        write(6,*) 'should be slow dstate 4, need to recalculate'
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                     elseif (dissocstate(1,j-2).eq.12) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=5
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
c                        write(6,*) 'dstate 12 -> 5 for ',1,j-2
c                        write(6,*) 'should be slow dstate 5, need to recalculate'
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                     elseif (dissocstate(1,j-2).eq.13) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=6
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
c                        write(6,*) 'dstate 13 -> 6 for ',1,j-2
c                        write(6,*) 'should be slow dstate 6, need to recalculate'
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                     else
                        write(6,*) 'bad dstate for ',1,j-2,'?'
                        stop
                     endif
                  endif
               else
c                  write(6,*) 'lower seam neighbor at template'
c                  write(6,*) 'dont change'
               endif
               
c               write(6,*) 'upper seam neighbor may need to be changed'
               if (j.gt.103) then
c                  write(6,*) 'upper seam neighbor not in template'
                  if (state(1,j-1).eq.0) then
                     if (dissocstate(1,j-1).eq.2) then
                        if (addstate(1,j-1).eq.1) then
c                           write(6,*) 'dstate=2, addstate=1, remove event at ',1,j-1
                           addstate(1,j-1)=addstate(1,j-1)-1
                           dissocstate(1,j-1)=0
                           call RemoveAdditionEvent(1,j-1,nrecyc,recyc,revmap,ev,nev,
     @                          addstate,event,times,totev)
                        elseif (addstate(1,j-1).eq.2) then
c                           write(6,*) 'dstate=2, addstate=2, remove addition at ',1,j-1
                           addstate(1,j-1)=addstate(1,j-1)-1
                        else
                           write(6,*) 'bad dstate/addstate at ',1,j-1
                           stop
                        endif
                     elseif (dissocstate(1,j-1).eq.5) then
                        addstate(1,j-1)=addstate(1,j-1)-1
                        dissocstate(1,j-1)=3
c                        write(6,*) 'dstate 5 -> 3 for ',1,j-1
                     elseif (dissocstate(1,j-1).eq.12) then
                        addstate(1,j-1)=addstate(1,j-1)-1
                        dissocstate(1,j-1)=5
c                        write(6,*) 'dstate 12 -> 5 for ',1,j-1
                     else
                        write(6,*) 'bad dstate for ',1,j-1,'?'
                        stop
                     endif
                  else
                     if (state(1,j-1).eq.0) then
                        write(6,*) 'state of ',1,j-2,'is ',state(1,j-2)
                        write(6,*) 'state of ',1,j-1,'is 0'
                        write(6,*) 'strange case, may need to implement more code?'
                        stop
                     else
                        write(6,*) 'bad dstate/addstate somewhere?'
                        stop
                     endif
                  endif
               else
c                  write(6,*) 'upper seam neighbor in template'
c                  write(6,*) 'dont change'
               endif
            
            elseif ((state(1,j-3).ne.0).and.(state(1,j-2).ne.0).and.
     @             (state(1,j-1).ne.0).and.(state(1,j).ne.0)) then
c               write(6,*) 'dstate 10/11 was made across seam'
               
c               write(6,*) 'dep will have to change for ',i,j+1
c               write(6,*) 'dep before: ',dep(i,j+1)
               dep(i,j+1)=4
c               write(6,*) 'dep after: ',dep(i,j+1)
               
c               write(6,*) 'should only need to update ',1,j-2,'and ',1,j-1
               if (j.gt.104) then
c                  write(6,*) 'lower seam neighbor not in template: ',1,j-2
                  if (dissocstate(1,j-2).eq.8) then
                     addstate(1,j-2)=addstate(1,j-2)-1
ccccccccccccccccccccccccccccccc
c                     write(6,*) 'removing full lateral contact, make seammult ne 1'
                     seammult(1,j-2)=17.2
c                     seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                     
                     if (state(2,j-1).ne.0) then
                        if ((state(1,j-1).eq.1).and.(state(1,j-3).eq.1)) then
c                           write(6,*) 'dstate 8 -> 10 for ',1,j-2
                           dissocstate(1,j-2)=10
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-2))
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                        elseif ((state(1,j-1).eq.-1).or.(state(1,j-3).eq.-1)) then
c                           write(6,*) 'dstate 8 -> 11 for ',1,j-2
                           dissocstate(1,j-2)=11
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-2))
c Need to add test for double GDP if dstate=11.
                           if ((state(1,j-2).eq.-1).and.(state(1,j-3).eq.-1)) then
c                              write(6,*) 'double GDP, recalculate times'
                              times(ev(1,j-2,2))=times(ev(1,j-2,2))*GDP
                           else
c                              write(6,*) 'single GDP, do nothing'
                           endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
c                           write(6,*) 'need to check for double GDP'
                        else
                           write(6,*) 'bad state for ',1,j-1,'or ',1,j-3
                           stop
                        endif
                     else
                        if (state(1,j-3).eq.1) then
c                           write(6,*) '8 -> 5 for ',1,j-2
                           dissocstate(1,j-2)=5
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-2))
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                           write(6,*) 'slow dstate 5, need to recalculate'
                        elseif (state(1,j-3).eq.-1) then
                           write(6,*) '8 -> 6 for ',1,j-2
                           dissocstate(1,j-2)=6
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-2))
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                           write(6,*) 'slow dstate 6, need to recalculate'
                        else
                           write(6,*) 'bad state for ',1,j-3
                           stop
                        endif
                     endif
                  elseif (dissocstate(1,j-2).eq.11) then
                     addstate(1,j-2)=addstate(1,j-2)-1
ccccccccccccccccccccccccccccccc
c                     write(6,*) 'removing full lateral contact, make seammult ne 1'
                     seammult(1,j-2)=17.2
c                     seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                     
                     if (state(1,j-3).eq.1) then
c                        write(6,*) 'dstate 11 -> 3 for ',1,j-2
                        dissocstate(1,j-2)=3
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
c                        write(6,*) 'slow dstate 3, need to recalculate'
                     elseif (state(1,j-3).eq.-1) then
c                        write(6,*) 'dstate 11 -> 4 for ',1,j-2
                        dissocstate(1,j-2)=4
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
c                        write(6,*) 'slow dstate 4, need to recalculate'
                     else
                        write(6,*) 'bad state for ',1,j-3
                        stop
                     endif
                  elseif (dissocstate(1,j-2).eq.10) then
                     addstate(1,j-2)=addstate(1,j-2)-1
c                     write(6,*) 'dstate 10 -> 3 for ',1,j-2
                     dissocstate(1,j-2)=3
ccccccccccccccccccccccccccccccc
c                     write(6,*) 'removing full lateral contact, make seammult ne 1'
                     seammult(1,j-2)=17.2
c                     seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                     
                     times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-2))
                     call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
c                     write(6,*) 'slow dstate 3, need to recalculate'
                  else
                     write(6,*) 'bad dstate for ',1,j-2
                     stop
                  endif
               else
c                  write(6,*) 'lower seam neighbor in template: ',1,j-2
c                  write(6,*) 'dont change'
               endif
               
               if (j.gt.103) then
c                  write(6,*) 'upper seam neighbor is not in template: ',1,j-1
                  if (dissocstate(1,j-1).eq.8) then
                     addstate(1,j-1)=addstate(1,j-1)-1
ccccccccccccccccccccccccccccccc
c                     write(6,*) 'removing full lateral contact, make seammult ne 1'
                     seammult(1,j-1)=17.2
c                     seammult(1,j-1)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                     
                     if (state(2,j).ne.0) then
                        if ((state(1,j).eq.1).and.(state(1,j-2).eq.1)) then
c                           write(6,*) 'dstate 8 -> 10 for ',1,j-1
                           dissocstate(1,j-1)=10
                           times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-1))
                           call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                        elseif ((state(1,j).eq.-1).or.(state(1,j-2).eq.-1)) then
c                           write(6,*) 'dstate 8 -> 11 for ',1,j-1
                           dissocstate(1,j-1)=11
                           times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-1))
c Need to add test for double GDP if dstate=11.
                           if ((state(1,j-1).eq.-1).and.(state(1,j-2).eq.-1)) then
c                              write(6,*) 'double GDP, recalculate times'
                              times(ev(1,j-1,2))=times(ev(1,j-1,2))*GDP
                           else
c                              write(6,*) 'single GDP, do nothing'
                           endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
                           call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
c                           write(6,*) 'need to check for double GDP'
                        else
                           write(6,*) 'bad state for ',1,j,'or ',1,j-2
                           stop
                        endif
                     else
                        if (state(1,j-2).eq.1) then
c                           write(6,*) '8 -> 5 for ',1,j-1
                           dissocstate(1,j-1)=5
                           times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-1))
                           call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                        elseif (state(1,j-2).eq.-1) then
c                           write(6,*) '8 -> 6 for ',1,j-1
                           dissocstate(1,j-1)=6
                           times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-1))
                           call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                        else
                           write(6,*) 'bad state for ',1,j-2
                           stop
                        endif
                     endif
                  elseif (dissocstate(1,j-1).eq.13) then			!added June 13
                     addstate(1,j-1)=addstate(1,j-1)-1
c                     write(6,*) 'dstate 13 -> 6 for ',1,j-1
                     dissocstate(1,j-1)=6
                     times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-1))
                     call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                  elseif (dissocstate(1,j-1).eq.12) then			!added June 13
                     addstate(1,j-1)=addstate(1,j-1)-1
c                     write(6,*) 'dstate 12 -> 5 for ',1,j-1
                     dissocstate(1,j-1)=5
                     times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-1))
                     call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev) 
                  elseif (dissocstate(1,j-1).eq.11) then
                     addstate(1,j-1)=addstate(1,j-1)-1
                     if (state(1,j-2).eq.1) then
c                        write(6,*) 'dstate 11 -> 3 for ',1,j-1
                        dissocstate(1,j-1)=3
                        times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-1))
                        call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                     elseif (state(1,j-2).eq.-1) then
c                        write(6,*) 'dstate 11 -> 4 for ',1,j-1
                        dissocstate(1,j-1)=4
                        times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-1))
                        call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                     else
                        write(6,*) 'bad state for ',1,j-2
                        stop
                     endif
                  elseif (dissocstate(1,j-1).eq.10) then
                     addstate(1,j-1)=addstate(1,j-1)-1
c                     write(6,*) 'dstate 10 -> 3 for ',1,j-1
                     dissocstate(1,j-1)=3
                     times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-1))
                     call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                  elseif (dissocstate(1,j-1).eq.6) then
                     addstate(1,j-1)=addstate(1,j-1)-1
c                     write(6,*) 'dstate 6 -> 4 for ',1,j-1
                     dissocstate(1,j-1)=4
                     times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-1))
                    call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                  elseif (dissocstate(1,j-1).eq.5) then
                     addstate(1,j-1)=addstate(1,j-1)-1
c                     write(6,*) 'dstate 5 -> 3 for ',1,j-1
                     dissocstate(1,j-1)=3
                     times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                              K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                              K_all,k_ne,seammult(1,j-1))
                     call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                  else
                     write(6,*) 'bad dstate for ',1,j-1
                     stop
                  endif
               else
c                  write(6,*) 'upper seam neighbor in template: ',1,j-1
c                  write(6,*) 'dont change'
               endif
                 
c               write(6,*) 'now looking away from the seam'
c               write(6,*) 'should only need to update ',i-1,j
               if (state(i-1,j).eq.0) then
                  if (dissocstate(i-1,j).eq.2) then
                     if (addstate(i-1,j).eq.1) then
c                        write(6,*) 'dstate=2, addstate=1, remove event for ',i-1,j
                        addstate(i-1,j)=addstate(i-1,j)-1
                        dissocstate(i-1,j)=0
                        call RemoveAdditionEvent(i-1,j,nrecyc,recyc,revmap,ev,nev,
     @                          addstate,event,times,totev)
                     elseif (addstate(i-1,j).eq.2) then
c                        write(6,*) 'dstate=2, addstate=2, remove addition for ',i-1,j
                        addstate(i-1,j)=addstate(i-1,j)-1
                     else
                        write(6,*) 'bad dstate/addstate for ',i-1,j
                        stop
                     endif
                  elseif (dissocstate(i-1,j).eq.5) then
                     addstate(i-1,j)=addstate(i-1,j)-1
                     dissocstate(i-1,j)=3
c                     write(6,*) 'dstate 5 -> 3 for ',i-1,j
                  elseif (dissocstate(i-1,j).eq.12) then
                     addstate(i-1,j)=addstate(i-1,j)-1
                     dissocstate(i-1,j)=5
c                     write(6,*) 'dstate 12 -> 5 for ',i-1,j
                  else
                     write(6,*) 'bad dstate for ',i-1,j,': ',dissocstate(i-1,j)
                     stop
                  endif
               else
                  if (dissocstate(i-1,j).eq.2) then
                     write(6,*) 'lateral interaction, may need to wipe?'
                     stop
                  else
                     write(6,*) 'bad dstate for ',i-1,j,': ',dissocstate(i-1,j)
                     stop
                  endif
               endif
               
            else
               write(6,*) 'bad dstate/addstate somewhere?'
               stop
            endif

c Start nucleotide exchange fun here...            
c      	       write(6,*) 'remove hydrolysis event if not hydrolyzed'
      	       if (state(i,j-1).eq.1) then
c      	          write(6,*) 'not hydrolyzed, remove event'
                  if (ev(i,j-1,3).ne.0) then
                     call RemoveHydroEvent(i,j-1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)        		
                  endif
               else
c                  write(6,*) 'hydrolyzed, do nothing'
               endif
c End nucleotide exchange fun here...      	    

         elseif ( (dissocstate(i,j).eq.12).or.(dissocstate(i,j).eq.13) ) then
c            write(6,*) 'dissociating from dstate=12/13'
c            write(6,*) 'check above'
            if (state(i,j+1).eq.0) then
               if (addstate(i,j+1).ge.2) then
c                  write(6,*) 'empty above, more than 1 neighbor'
                  addstate(i,j+1)=addstate(i,j+1)-1
c Start nucleotide exchange fun here...                  
                  if ((dissocstate(i,j+1).eq.5).or.(dissocstate(i,j+1).eq.6)) then
                     dissocstate(i,j+1)=2
c                 Adding in code to handle looking up and changing dissocstate(i,j+1)=12            !Is there a possibility that     
                  elseif ((dissocstate(i,j+1).eq.12).or.(dissocstate(i,j+1).eq.13)) then			!dissocstate(i,j+1)=8?
                     dissocstate(i,j+1)=2                     										!
c                     write(6,*) 'have not yet handled this check'									!
c                     stop																			!
                  else																				!
                     write(6,*) 'if found, have not yet handled this check'							!
                     stop																			!
                  endif																				!
c End nucleotide exchange fun here...                  
               elseif (addstate(i,j+1).eq.1) then
c                  write(6,*) 'empty above, 1 neighbor, remove event'
                  addstate(i,j+1) = addstate(i,j+1)-1
                  dissocstate(i,j+1)=0
                  if (ev(i,j+1,1).ne.0) then
                     call RemoveAdditionEvent(i,j+1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
      		      endif
               else
                  write(6,*) 'pf#13 dissocstate=5, bad addstate'
                  stop
               endif
            else
c               write(6,*) 'something above, change addstate and remove gtp hydro'
c               write(6,*) 'wiping problem'
               qwipe=.true.
               addstate(i,j+1) = addstate(i,j+1)-1
               addstate(i,j)=addstate(i,j)-1 !correct for losing the above guy
               if (ev(i,j,3).ne.0) then
                  call RemoveHydroEvent(i,j,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
      	       endif
      	    endif
c               write(6,*) 'take care of left diag, call SubUppRig'
               addstate(12,j)=addstate(12,j)-1
               if (j.gt.103) addstate(i,j-1)=addstate(i,j-1)-1
               call SubUppRig(dep,dissocstate,state,i-1,j,i,j-1,temph,tempv,tempd)
               if (temph.ne.dissocstate(i-1,j)) then
c                  write(6,*) 'new dissocstate for H-neighb'
                  dissocstate(i-1,j)=temph
c      		      write(6,*) 'resetting dissocstate of H-neighb to ',dissocstate(i-1,j)
                  times(ev(i-1,j,2))=get_evtime(dissocstate(i-1,j),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i-1,j))
c Need to add test for double GDP if dstate=11.
                  if (temph.eq.11) then
                     if ((state(i-1,j).eq.-1).and.(state(i-1,j-1).eq.-1)) then
c                        write(6,*) 'double GDP, recalculate times'
                        times(ev(i-1,j,2))=times(ev(i-1,j,2))*GDP
                     else
c                        write(6,*) 'single GDP, do nothing'
                     endif
                  endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
                  call update(event,revmap,ev(i-1,j,2),times(ev(i-1,j,2)),times,totev)
               endif
               if (tempv.ne.dissocstate(i,j-1)) then
                  if (j.gt.103) then
c                     write(6,*) 'new dissocstate for V-neighb'
                     dissocstate(i,j-1)=tempv
c      		         write(6,*) 'resetting dissocstate of V-neighb to ',dissocstate(i,j-1)
                     times(ev(i,j-1,2))=get_evtime(dissocstate(i,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i,j-1))
c Need to add test for double GDP if dstate=11.
                     if (tempv.eq.11) then
                        if ((state(i,j-1).eq.-1).and.(state(i,j-2).eq.-1)) then
c                           write(6,*) 'double GDP, recalculate times'
                           times(ev(i,j-1,2))=times(ev(i,j-1,2))*GDP
                        else
c                           write(6,*) 'single GDP, do nothing'
                        endif
                     endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
                     call update(event,revmap,ev(i,j-1,2),times(ev(i,j-1,2)),times,totev)
                  else
c                     write(6,*)'on 1st row, leave 102 alone'
                  endif
               endif
               if (tempd.ne.dissocstate(i-1,j-1)) then
                  if (j.gt.103) then
c                     write(6,*) 'new dissocstate for D-neighb'
                     dissocstate(i-1,j-1)=tempd
c      		         write(6,*) 'resetting dissocstate of D-neighb to ',dissocstate(i-1,j-1)
                     times(ev(i-1,j-1,2))=get_evtime(dissocstate(i-1,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(i-1,j-1))
c Need to add test for double GDP if dstate=11.
                     if (tempd.eq.11) then
                        if ((state(i-1,j-1).eq.-1).and.(state(i-1,j-2).eq.-1)) then
c                           write(6,*) 'double GDP, recalculate times'
                           times(ev(i-1,j-1,2))=times(ev(i-1,j-1,2))*GDP
                        else
c                           write(6,*) 'single GDP, do nothing'
                        endif
                     endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
                     call update(event,revmap,ev(i-1,j-1,2),times(ev(i-1,j-1,2)),times,totev)
                  else
c                     write(6,*)'on 1st row, leave 102 alone'
                  endif
               endif
c               write(6,*) 'now do across seam'
                  if (j.gt.104) then
                     !here we might have to change the type
                     if (dissocstate(1,j-2).eq.5) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=3
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neighb to ',dissocstate(1,j-2)
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)                     
                     elseif (dissocstate(1,j-2).eq.6) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=4
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neighb to ',dissocstate(1,j-2)
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)                     
c Dstate 10/11 can occur...
                     elseif (dissocstate(1,j-2).eq.10) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=3
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                        !added May 31: checking 2 below if not in template...
c                        write(6,*) 'removing next to dstate 11, need to look 2 below'
                        if (j.gt.105) then
                           if (dissocstate(1,j-3).eq.8) then
                              if (state(1,j-4).eq.1) then
                                 dissocstate(1,j-3)=12
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (state(1,j-4).eq.-1) then
                                 dissocstate(1,j-3)=13
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              else
                                 write(6,*) 'bad state for: ',1,j-4
                                 stop
                              endif
                           elseif (dissocstate(1,j-3).eq.10) then
                              dissocstate(1,j-3)=5
                              times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                              call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                           elseif (dissocstate(1,j-3).eq.11) then
                              if (state(1,j-4).eq.1) then		!May 31: changed dissocstate to state
                                 dissocstate(1,j-3)=5
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (state(1,j-4).eq.-1) then
                                 dissocstate(1,j-3)=6
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              else
                                 write(6,*) 'bad state for: ',1,j-4
                                 stop
                              endif
                           else
                              write(6,*) 'not dstate 8/10/11 at 2 below'
                           endif
                        else
c                           write(6,*) 'in template, do nothing'
                        endif
                     elseif (dissocstate(1,j-2).eq.11) then
                        addstate(1,j-2)=addstate(1,j-2)-1
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
                        if (state(1,j-3).eq.1) then
                           dissocstate(1,j-2)=3
c                           write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                        elseif (state(1,j-3).eq.-1) then
                           dissocstate(1,j-2)=4
c                           write(6,*) 'resetting dissocstate of lower seam neaghb to ',dissocstate(1,j-2)
                           times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                           call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                        else
                           write(6,*) 'bad state for ',1,j-3
                           stop
                        endif
                        !added May 31: checking 2 below if not in template...
c                        write(6,*) 'removing next to dstate 11, need to look 2 below'
                        if (j.gt.105) then
                           if (dissocstate(1,j-3).eq.8) then
                              if (state(1,j-4).eq.1) then
                                 dissocstate(1,j-3)=12
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (state(1,j-4).eq.-1) then
                                 dissocstate(1,j-3)=13
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              else
                                 write(6,*) 'bad state for: ',1,j-4
                                 stop
                              endif
                           elseif (dissocstate(1,j-3).eq.10) then
                              dissocstate(1,j-3)=5
                              times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                              call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                           elseif (dissocstate(1,j-3).eq.11) then
                              if (state(1,j-4).eq.1) then		!May 31: changed dissocstate to state
                                 dissocstate(1,j-3)=5
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              elseif (state(1,j-4).eq.-1) then
                                 dissocstate(1,j-3)=6
                                 times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                                 call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                              else
                                 write(6,*) 'bad state for: ',1,j-4
                                 stop
                              endif
                           else
c                              write(6,*) 'not dstate 8/10/11 at 2 below'
                           endif
                        else
c                           write(6,*) 'in template, do nothing'
                        endif
                     elseif (dissocstate(1,j-2).eq.12) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=5
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neighb to ',dissocstate(1,j-2)
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)                     
                     elseif (dissocstate(1,j-2).eq.13) then
                        addstate(1,j-2)=addstate(1,j-2)-1
                        dissocstate(1,j-2)=6
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
c      		            write(6,*) 'resetting dissocstate of lower seam neighb to ',dissocstate(1,j-2)
                        times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                        call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)                                          
                     elseif (dissocstate(1,j-2).eq.8) then
                        addstate(1,j-2)=addstate(1,j-2)-1
ccccccccccccccccccccccccccccccc
c                        write(6,*) 'removing full lateral contact, make seammult ne 1'
                        seammult(1,j-2)=17.2
c                        seammult(1,j-2)=1.0		!to turn off
ccccccccccccccccccccccccccccccc                        
                        
c Needs to be a special case that determines if subunit goes to dstate 5/6.
                        if (state(2,j-1).eq.0) then													!State of this coordinate
c                           write(6,*) 'space is empty: ',2,j-1										!determines if dstate goes
c                           write(6,*) 'special dstate 8 change for ',1,j-2							!to 5/6 or 10/11
                           if (state(1,j-3).eq.1) then
                              write(6,*) 'dstate 8 -> 5, should be slow, need to recalculate'
                              dissocstate(1,j-2)=5
                              times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                              call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                           elseif (state(1,j-3).eq.-1) then
                              write(6,*) 'dstate 8 -> 6, should be slow, need to recalculate'
                              dissocstate(1,j-2)=6
                              times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                              call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)
                           else
                              write(6,*) 'bad state for vertical subunit: ',1,j-3
                              stop
                           endif
                        else
                           if ((state(1,j-2).eq.1).and.(state(1,j-3).eq.1)) then
c                              write(6,*) 'dstate 8 -> 10'
                              dissocstate(1,j-2)=10
c      	   	                  write(6,*) 'resetting dissocstate of lower seam neighb to ',dissocstate(1,j-2)
                              times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                              call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)                                          
                           elseif ((state(1,j-2).eq.1).and.(state(1,j-3).eq.-1)) then
c                              write(6,*) 'dstate 8 -> 11,bot'
                              dissocstate(1,j-2)=11
c      	  	                  write(6,*) 'resetting dissocstate of lower seam neighb to ',dissocstate(1,j-2)
                              times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                              call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)                                          
                           elseif ((state(1,j-2).eq.-1).and.(state(1,j-3).eq.1)) then
c                              write(6,*) 'dstate 8 -> 11,top'
                              dissocstate(1,j-2)=11
c       		                  write(6,*) 'resetting dissocstate of lower seam neighb to ',dissocstate(1,j-2)
                              times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                              call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)                                          
                           elseif ((state(1,j-2).eq.-1).and.(state(1,j-3).eq.-1)) then
c                              write(6,*) 'double GDP at 8 across seam, need to treat'
                              dissocstate(1,j-2)=11
                              times(ev(1,j-2,2))=get_evtime(dissocstate(1,j-2),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-2))
                              times(ev(1,j-2,2))=GDP*times(ev(1,j-2,2))
                              call update(event,revmap,ev(1,j-2,2),times(ev(1,j-2,2)),times,totev)                           
                           else
                              write(6,*) 'bad nt states across seam'
                              stop
                           endif
                        endif
                     else
                        write(6,*) 'have not handled this dtstate yet',dissocstate(1,j-2)
                        stop
                     endif

                  endif
                  
c Need a special case to check 2 below across the seam to see if dstate 8/10/11 needs to be changed.
                  if (j.gt.105) then
c                     write(6,*) 'special 2 below check at ',1,j-3		!changed June 13: need to accomodate for 10/11
                     if (dissocstate(1,j-3).eq.8) then
c                        write(6,*) 'dstate is 8 at ',1,j-3
                        if (state(2,j-2).eq.0) then													!Only needs to change if 2,j-2 is empty
c                           write(6,*) 'empty at ',2,j-2
                           if (state(1,j-4).eq.1) then
c                              write(6,*) 'dstate 8 -> 12'
                              dissocstate(1,j-3)=12
                              times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                              call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)  
                           elseif (state(1,j-4).eq.-1) then
c                              write(6,*) 'dstate 8 -> 13'
                              dissocstate(1,j-3)=13
                              times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                              call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                           else
                              write(6,*) 'bad state for ',1,j-4
                              stop
                           endif
                        else
c                           write(6,*) 'dstate stays 8 for ',1,j-3
                        endif
                     elseif (dissocstate(1,j-3).eq.10) then			!added June 13
c                        write(6,*) 'dstate 10 -> 5'
                        dissocstate(1,j-3)=5
                        times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                        call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                     elseif (dissocstate(1,j-3).eq.11) then
                        if (state(1,j-4).eq.1) then 
c                           write(6,*) 'dstate 11 -> 5'
                           dissocstate(1,j-3)=5
                           times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                           call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                        elseif (state(1,j-4).eq.-1) then
c                           write(6,*) 'dstate 11 -> 6'
                           dissocstate(1,j-3)=6
                           times(ev(1,j-3,2))=get_evtime(dissocstate(1,j-3),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-3))
                           call update(event,revmap,ev(1,j-3,2),times(ev(1,j-3,2)),times,totev)
                        else
                           write(6,*) 'bad state for ',1,j-4
                           stop
                        endif
                     else
c                        write(6,*) 'dstate not 8/10/11 at ',1,j-3
                     endif
                  else
c                     write(6,*) 'do not check 2 below, is in template'
                  endif
c                  write(6,*) 'special 2 below check done'
                  
                  !checking upper seam neighbor for seammult if not in template...
                  if (j.gt.103) then
                     if (state(1,j-1).ne.0) then
c                        write(6,*) 'remove half lateral contact, seammult=1'
                        seammult(1,j-1)=1.0
                        times(ev(1,j-1,2))=get_evtime(dissocstate(1,j-1),k_on,conc,GDP,K_lat,
     @                                   K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                                   K_all,k_ne,seammult(1,j-1))
                        call update(event,revmap,ev(1,j-1,2),times(ev(1,j-1,2)),times,totev)
                     else
c                        write(6,*) 'upper neighbor empty, do nothing for seammult'
                     endif
                  else
c                     write(6,*) 'upper seam neighbor in template, do nothing'
                  endif

c Moved into here      	    
      	    if (qwipe) then
c               write(6,*) 'wiping from 13, dstate=12/13'
               nremove=1
               call WipeFromSeam(i,j+1,nremove,ntub,dep,state,addstate,nrecyc,recyc,
     @                        ev,nev,dissocstate,event,revmap,totev,times,seammult)
     
c Adding commands to check stats of subunit across seam and above (1,j-1).               			!Moved to WipeFromSeam line #19937
c               if (state(1,j-1).ne.0) then															!
c                  write(6,*) 'does subunit need to be removed at ',1,j-1,'?'						!
c                  stop																				!
c               else																				!
c                  write(6,*) 'bad dissocstate somewhere?'											!
c                  stop																				!
c               endif																				!
               
            endif
            
c Start nucleotide exchange fun here...            
c      	       write(6,*) 'remove hydrolysis event if not hydrolyzed'
      	       if (state(i,j-1).eq.1) then
c      	          write(6,*) 'not hydrolyzed, remove event'
                  if (ev(i,j-1,3).ne.0) then
                     call RemoveHydroEvent(i,j-1,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)        		
                  endif
               else
c                  write(6,*) 'hydrolyzed, do nothing'
               endif
c End nucleotide exchange fun here...      	    
      	 
      	 else
            write(6,*) 'need to do the remaining conditions for pf#13'
            stop
         endif
                  
c Where dstate 12/13 qwipe stuff originally was
c         if (qwipe) then
c            write(6,*) 'wiping from 13, dstate=12/13'
c            nremove=1
c            call WipeFromSeam(i,j+1,nremove,ntub,dep,state,addstate,nrecyc,recyc,
c     @                        ev,nev,dissocstate,event,revmap,totev,times)
c         endif
c        if (ev(i,j-1,3).ne.0) then
c            call RemoveHydroEvent(i,j-1,nrecyc,recyc,revmap,ev,nev,
c     @                        addstate,event,times,totev)
c      	 endif   
      
      return
      end
C
C
C +++++
C
C
       subroutine QCornDiagSurround (i,j,ih,jh,iv,jv,temph,tempv,tempd,dep,dissocstate,state)
       
c   I/O variables       
       integer i,j,ih,jh,iv,jv
       integer temph,tempv,tempd
       integer dep(13,*),dissocstate(13,*),state(13,*)
       
c   Begin...
C
C ONLY FIXED UPPER ONES
C
          if ((ih.gt.i).and.(jv.gt.j)) then															!Adding to lower left
c             write(6,*) 'qcorndiagsurround, lower adds not implemented yet'
             stop
             if ((dep(ih,jh).eq.0).or.(dep(ih,jh).eq.2).or.(dep(ih,jh).eq.4).or.(dep(ih,jh).eq.7)) then	!Horizontal is special/founder
                dep(i,j)=4                                                            				!Assign new deps
                if (dep(iv,jv).eq.4) then
                   dep(iv,jv)=7
                else
                   write(6,*) 'Wrong dep for ',iv,jv
                   stop
                endif
                if (dep(ih,jh).eq.0) then															!Horizontal is founder
                   if (dissocstate(ih,jh).lt.5) then
                      if (state(ih,jh).eq.1) then
                         temph=5
                      elseif (state(ih,jh).eq.-1) then
                         temph=6
                      else
                         write(6,*) 'Horizontal subunit non-existant?!'
                         stop
                      endif
                   endif
                else																				!Horizontal is not founder
                   if ((dissocstate(ih,jh).eq.3).or.(dissocstate(ih,jh).eq.4)) then
c                      write(6,*) 'Dissocstate stays the same, 3/4, for special subunit ',ih,jh
                   elseif (dissocstate(ih,jh).eq.2) then
                      write(6,*) 'Bad dissocstate',dissocstate(ih,jh),'for',ih,jh
                      stop
                   endif
                endif   																		
                if (dissocstate(ih,jh).eq.5) then													!
c                   write(6,*) 'marker711'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker712'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!								
c                   write(6,*) 'marker713'															!
                   temph=8																			!
                elseif ((dissocstate(ih,jh).eq.8).or.(dissocstate(ih,jh).ge.12)) then				!
c                   write(6,*) 'marker714'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (dissocstate(iv,jv).eq.2) then													!dependency changes from across to below
                   tempv=5
                elseif (dissocstate(iv,jv).eq.5) then												!
c                   write(6,*) 'marker715'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then
c                   write(6,*) 'marker2474'
                   tempv=11
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker717'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker718'															!
                   write(6,*) 'Bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).gt.8) then													!
c                   write(6,*) 'marker719'															!
                   tempd=8																			!
                endif																				!
             elseif ((dep(iv,jv).eq.0).or.(dep(iv,jv).eq.1).or.(dep(iv,jv).eq.3).or.(dep(iv,jv).eq.5)) then	!Vertical is special/founder
                dep(i,j)=1																			!Assign new deps
                if (dep(ih,jh).eq.1) then
                   dep(ih,jh)=5
                else
                   write(6,*) 'Wrong dep for ',ih,jh
                   stop
                endif
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                elseif (dissocstate(ih,jh).eq.5) then												!
c                   write(6,*) 'marker720'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker721'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker722'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker723'															!
                   write(6,*) 'Bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (dep(iv,jv).eq.0) then															!Vertical is founder
                   if (dissocstate(iv,jv).lt.5) then
                      tempv=5
                   endif
                else																				!Vertical is not founder
                   if (dissocstate(iv,jv).eq.2) then
c                      write(6,*) 'Dissocstate stays the same, 2, for special subunit ',iv,jv
                   elseif ((dissocstate(iv,jv).eq.3).or.(dissocstate(iv,jv).eq.4)) then
                      write(6,*) 'Bad dissocstate',dissocstate(iv,jv),'for',iv,jv
                      stop
                   endif
                endif
                if (dissocstate(iv,jv).eq.5) then													!
c                   write(6,*) 'marker724'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then												!
c                   write(6,*) 'marker725'															!
                   tempv=11																			!
                elseif ((dissocstate(iv,jv).eq.8).or.(dissocstate(iv,jv).eq.10).or.					!
     @                 (dissocstate(iv,jv).eq.11)) then												!
c                   write(6,*) 'marker726'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker727'															!
                   tempv=8																			!
                endif
                if (dissocstate(ih,jv).gt.8) then													!
c                   write(6,*) 'marker728'															!
                   tempd=8																			!
                endif																				!
             elseif ((dep(ih,jv).eq.0).or.(dep(ih,jv).eq.1).or.(dep(ih,jv).eq.4).or.(dep(ih,jv).eq.6)) then	!Diagonal is special/founder
                dep(i,j)=6																			!Assign new deps
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                elseif (dissocstate(ih,jh).eq.5) then												!
c                   write(6,*) 'marker729'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker730'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker731'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker732'															!
                   write(6,*) 'Bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                elseif (dissocstate(iv,jv).eq.5) then												!
c                   write(6,*) 'marker733'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then												!
c                   write(6,*) 'marker734'															!
                   tempv=11																			!
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker735'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker736'															!
                   write(6,*) 'Bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).gt.8) then													!
c                   write(6,*) 'marker737'															!
                   tempd=8																			!
                endif																				!
             else
                write(6,*) 'No special subunit?!'
                stop
             endif
          elseif ((ih.gt.i).and.(jv.lt.j)) then														!Adding to upper left
             ! ASSUME DIAG IS 'SPECIAL'
                dep(i,j)=7																			!Assign new deps
                if (dep(ih,j).eq.2) then
                   write(6,*) 'resetting h-dep to 8'
                   dep(ih,j)=8
                endif
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                elseif (dissocstate(ih,jh).eq.5) then												!
c                   write(6,*) 'marker756'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker757'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker758'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker759'															!
                   write(6,*) 'Bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (j.eq.103) then
                   write(6,*) 'Qcorndiagsurround, looking below 1st row'
                   stop
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                elseif (dissocstate(iv,jv).eq.5) then												!
c                   write(6,*) 'marker760'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then
c                   write(6,*) 'marker2477'
                   tempv=11
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker2478'
                   tempv=8																			!
                else
c                   write(6,*) 'marker762'															!
                   write(6,*) 'Bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).gt.8) then													!
c                   write(6,*) 'marker763'															!
                   tempd=8																			!
                endif																				!
          elseif ((ih.lt.i).and.(jv.gt.j)) then														!Adding to lower right
             write(6,*) 'qcorndiagsurround, lower adds not implemented yet'
             stop
             if ((dep(ih,jh).eq.0).or.(dep(ih,jh).eq.2).or.(dep(ih,jh).eq.3).or.(dep(ih,jh).eq.8)) then	!Horizontal is special/founder
                dep(i,j)=3																			!Assign new deps
                if (dep(iv,jv).eq.3) then
                   dep(iv,jv)=8
                else
                   write(6,*) 'Wrong dep for ',iv,jv
                   stop
                endif
                if (dep(ih,jh).eq.0) then															!Horizontal is founder
                   if (dissocstate(ih,jh).lt.5) then
                      if (state(ih,jh).eq.1) then
                         temph=5
                      elseif (state(ih,jh).eq.-1) then
                         temph=6
                      else
                         write(6,*) 'Horizontal subunit non-existant?!'
                         stop
                      endif
                   endif
                else																				!Horizontal is not founder
                   if ((dissocstate(ih,jh).eq.3).or.(dissocstate(ih,jh).eq.4)) then
c                      write(6,*) 'Dissocstate stays the same, 3/4, for special subunit ',ih,jh
                   elseif (dissocstate(ih,jh).eq.2) then
                      write(6,*) 'Bad dissocstate',dissocstate(ih,jh),'for',ih,jh
                      stop
                   endif
                endif   
                if (dissocstate(ih,jh).eq.5) then													!
c                   write(6,*) 'marker764'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker765'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker766'															!
                   temph=8																			!
                elseif ((dissocstate(ih,jh).eq.8).or.(dissocstate(ih,jh).ge.12)) then				!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (dissocstate(iv,jv).eq.2) then													!dependency has changed from across to below
                   tempv=5
                elseif (dissocstate(iv,jv).eq.5) then												!
c                   write(6,*) 'marker767'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then
c                   write(6,*) 'marker2479'
                   tempv=11
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker2480'
                   tempv=8																			!
                else
c                   write(6,*) 'marker769'															!
                   write(6,*) 'Bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).gt.8) then													!
c                   write(6,*) 'marker770'															!
                   tempd=8																			!
                endif																				!
             elseif ((dep(iv,jv).eq.0).or.(dep(iv,jv).eq.1).or.(dep(iv,jv).eq.4).or.(dep(iv,jv).eq.6)) then	!Vertical is special/founder
                dep(i,j)=1																			!Assign new deps
                if (dep(ih,jh).eq.1) then
                   dep(ih,jh)=6
                else
                   write(6,*) 'Wrong dep for ',ih,jh
                   stop
                endif
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                elseif (dissocstate(ih,jh).eq.5) then												!
c                   write(6,*) 'marker771'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker772'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker773'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker774'															!
                   write(6,*) 'Bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (dep(iv,jv).eq.0) then															!Vertical is founder
                   if (dissocstate(iv,jv).lt.5) then
                      tempv=5
                   endif
                else																				!Vertical is not founder
                   if (dissocstate(iv,jv).eq.2) then
c                      write(6,*) 'Dissocstate stays the same, 2, for special subunit ',iv,jv
                   elseif ((dissocstate(iv,jv).eq.3).or.(dissocstate(iv,jv).eq.4)) then
                      write(6,*) 'Bad dissocstate',dissocstate(iv,jv),'for',iv,jv
                      stop
                   endif
                endif
                if (dissocstate(iv,jv).eq.5) then													!
c                   write(6,*) 'marker775'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then												!
c                   write(6,*) 'marker776'															!
                   tempv=11																			!
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker2481'
                   tempv=8																			!
                elseif ((dissocstate(iv,jv).eq.8).or.(dissocstate(iv,jv).eq.10).or.					!
     @                 (dissocstate(iv,jv).eq.11)) then												!
c                   write(6,*) 'marker777'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).gt.8) then													!
c                   write(6,*) 'marker778'															!
                   tempd=8																			!
                endif																				!
             elseif ((dep(ih,jv).eq.0).or.(dep(ih,jv).eq.1).or.(dep(ih,jv).eq.3).or.(dep(ih,jv).eq.5)) then	!Diagonal is special/founder
                dep(i,j)=5																			!Assign new deps
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                elseif (dissocstate(ih,jh).eq.5) then												!
c                   write(6,*) 'marker779'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker780'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker781'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker782'															!
                   write(6,*) 'Bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                elseif (dissocstate(iv,jv).eq.5) then												!
c                   write(6,*) 'marker783'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then												!
c                   write(6,*) 'marker784'															!
                   tempv=11																			!
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker2482'
                   tempv=8																			!
                else
                   write(6,*) 'Bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).gt.8) then													!
c                   write(6,*) 'marker785'															!
                   tempd=8																			!
                endif																				!
             else
                write(6,*) 'No special subunit?!'
                stop
             endif
          else																						!Adding to upper right
             ! Assume diagonal is special
                dep(i,j)=8																			!Assign new deps
                if (dep(ih,j).eq.2) then
                   write(6,*) 'resetting h-dep to 7'
                   dep(ih,j)=7
                endif
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                elseif (dissocstate(ih,jh).eq.5) then												!
c                   write(6,*) 'marker803'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker804'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker805'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker806'															!
                   write(6,*) 'Bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                elseif (dissocstate(iv,jv).eq.5) then												!
c                   write(6,*) 'marker807'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then
c                   write(6,*) 'marker2484'
                   tempv=11
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker809'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker810'															!
                   write(6,*) 'Bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).gt.8) then													!
c                   write(6,*) 'marker811'															!
                   tempd=8																			!
                endif																				!
          endif
       
       return           
       end
C
C
C +++++
C
C
       subroutine QCornDiagFiveSix (i,j,ih,jh,iv,jv,temph,tempv,tempd,dep,dissocstate,state)
       
c   I/O variables       
       integer i,j,ih,jh,iv,jv
       integer temph,tempv,tempd
       integer dep(13,*),dissocstate(13,*),state(13,*)
       
c Begin...       
          if ((ih.gt.i).and.(jv.gt.j)) then															!Adding to lower left
c             write(6,*) 'Adding to lower left'
             if (dep(ih,jh).eq.2) then																!Only way for horiz to be special and stay lt 5, cannot be founder
c                write(6,*) 'Special one is horizontal'
                dep(i,j)=4																			!(Re)Assign deps
                if (dep(iv,jv).eq.4) then
                   dep(iv,jv)=7
                else
                   write(6,*) 'bad dep for vertical'
                   stop
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                elseif ((dissocstate(iv,jv).eq.3).or.(dissocstate(iv,jv).eq.4)) then
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv
                   stop
                endif
                if (dissocstate(ih,jv).eq.5) then													!
c                   write(6,*) 'marker812'															!
                   tempd=12																			!
                elseif (dissocstate(ih,jv).eq.6) then												!
c                   write(6,*) 'marker813'															!
                   tempd=13																			!
                endif																				!
             elseif (dep(iv,jv).eq.3) then															!Only way for vert to be special and stay lt 5, cannot be founder
c                write(6,*) 'Special one is vertical'
                dep(i,j)=1																			!(Re)Assign deps
                if (dep(ih,jh).eq.1) then
                   dep(ih,jh)=5
                else
                   write(6,*) 'bad dep for horizontal'
                   stop
                endif
                if (dissocstate(ih,jh).eq.2) then
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh
                   stop
                elseif (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                endif
                if ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then					!
c                   write(6,*) 'marker814'															!
                   if ((state(ih,jv).eq.1).and.(state(ih,jh).eq.1)) then
                      tempd=10																		!
                   elseif ((state(ih,jv).eq.-1).or.(state(ih,jh).eq.-1)) then
                      tempd=11																		!
                   else
                      write(6,*) 'empty diagonal or horizontal subunit??'
                      stop
                   endif
                endif																				!
			 elseif ((dep(ih,jv).eq.0).or.(dep(ih,jv).eq.1).or.(dep(ih,jv).eq.4).or.(dep(ih,jv).eq.6)) then	!Special one is diagonal
c			    write(6,*) 'Special one is diagonal'
			    dep(i,j)=6
			    if (dissocstate(ih,jh).eq.3) then
			       temph=5
			    elseif (dissocstate(ih,jh).eq.4) then
			       temph=6
			    else
			       write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh
			       stop
			    endif
			    if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                else
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv
                   stop
                endif
             else
                write(6,*) 'Bad dep somewhere'
                stop
             endif
          elseif ((ih.gt.i).and.(jv.lt.j)) then														!Adding to upper left
c             write(6,*) 'Adding to upper left'
             if (dep(ih,jh).eq.1) then																!Only way for horiz to be special and stay lt 5, cannot be founder
c                write(6,*) 'Special one is horizontal'
                dep(i,j)=4																			!(Re)Assign deps
                if (dep(iv,jv).eq.4) then
                   dep(iv,jv)=6
                else
                   write(6,*) 'bad dep for vertical'
                   stop
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5																			!Cannot be anything underneath
                elseif ((dissocstate(iv,jv).eq.3).or.(dissocstate(iv,jv).eq.4)) then
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv
                   stop
                endif
                if (dissocstate(ih,jv).eq.5) then													!
c                   write(6,*) 'marker816'															!
                   tempd=12																			!
                elseif (dissocstate(ih,jv).eq.6) then												!
c                   write(6,*) 'marker817'															!
                   tempd=13																			!
                endif																				!
             elseif (dep(iv,jv).eq.3) then															!Only way for vert to be special and stay lt 5, cannot be founder
c                write(6,*) 'Special one is vertical'
                dep(i,j)=2																			!(Re)Assign deps
                if (dep(ih,jh).eq.2) then
                   dep(ih,jh)=8
                else
                   write(6,*) 'bad dep for horizontal'
                   stop
                endif
                if (dissocstate(ih,jh).eq.2) then
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh
                   stop
                elseif (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                endif
                if ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then					!
c                   write(6,*) 'marker818'															!
                   if ((state(ih,jv).eq.1).and.(state(ih,jv-1).eq.1)) then
                      tempd=10																		!
                   elseif ((state(ih,jv).eq.-1).or.(state(ih,jv-1).eq.-1)) then
                      tempd=11																		!
                   else
                      write(6,*) 'empty diagonal subunit or subunit below??'
                      stop
                   endif
                endif																				!
			 elseif ((dep(ih,jv).eq.0).or.(dep(ih,jv).eq.2).or.(dep(ih,jv).eq.4).or.(dep(ih,jv).eq.7)) then	!Special one is diagonal
c			    write(6,*) 'Special one is diagonal'
			    dep(i,j)=7
			    if (dissocstate(ih,jh).eq.3) then
			       temph=5
			    elseif (dissocstate(ih,jh).eq.4) then
			       temph=6
			    else
			       write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh
			       stop
			    endif
			    if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                else
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv
                   stop
                endif
             else
                write(6,*) 'Bad dep somewhere'
                stop
             endif
          elseif ((ih.lt.i).and.(jv.gt.j)) then														!Adding to lower right
c             write(6,*) 'Adding to lower right'
             if (dep(ih,jh).eq.2) then																!Only way for horiz to be special and lt 5, cannot be founder
c                write(6,*) 'Special one is horizontal'
                dep(i,j)=3																			!(Re)Assign deps
                if (dep(iv,jv).eq.3) then
                   dep(iv,jv)=8
                else
                   write(6,*) 'bad dep for vertical'
                   stop
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                elseif ((dissocstate(iv,jv).eq.3).or.(dissocstate(iv,jv).eq.4)) then
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv
                   stop
                endif
                if (dissocstate(ih,jv).eq.5) then													!
c                   write(6,*) 'marker820'															!
                   tempd=12																			!
                elseif (dissocstate(ih,jv).eq.6) then												!
c                   write(6,*) 'marker821'															!
                   tempd=13																			!
                endif																				!
             elseif (dep(iv,jv).eq.4) then															!Only way for vert to be special and lt 5, cannot be founder
c                write(6,*) 'Special one is vertical'
                dep(i,j)=1																			!(Re)Assign deps
                if (dep(ih,jh).eq.1) then
                   dep(ih,jh)=6
                else
                   write(6,*) 'bad dep for horizontal'
                   stop
                endif
                if (dissocstate(ih,jh).eq.2) then
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh
                   stop
                elseif (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                endif
                if ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then					!
c                   write(6,*) 'marker822'															!
                   if ((state(ih,jv).eq.1).and.(state(ih,jh).eq.1)) then
                      tempd=10																		!
                   elseif ((state(ih,jv).eq.-1).or.(state(ih,jh).eq.-1)) then
                      tempd=11																		!
                   else
                      write(6,*) 'empty horizontal or diagonal subunit??'
                      stop
                   endif
                endif																				!
			 elseif ((dep(ih,jv).eq.0).or.(dep(ih,jv).eq.1).or.(dep(ih,jv).eq.3).or.(dep(ih,jv).eq.5)) then	!Special one is diagonal
c			    write(6,*) 'Special one is diagonal'
			    dep(i,j)=5
			    if (dissocstate(ih,jh).eq.3) then
			       temph=5
			    elseif (dissocstate(ih,jh).eq.4) then
			       temph=6
		        else
			       write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh
			       stop
			    endif
			    if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                else
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv
                   stop
                endif
             else
                write(6,*) 'Bad dep somewhere'
                stop
             endif
	      else																						!Adding to upper right
c			 write(6,*) 'Adding to upper right'
			 if (dep(ih,jh).eq.1) then																!Only way for horiz to be special and lt 5, cannot be founder
c			    write(6,*) 'Special one is horizontal'
                dep(i,j)=3																			!(Re)Assign deps
                if (dep(iv,jv).eq.3) then
                   dep(iv,jv)=5
                else
                   write(6,*) 'bad dep for vertical'
                   stop
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5																			!Cannot be anything underneath
                elseif ((dissocstate(iv,jv).eq.3).or.(dissocstate(iv,jv).eq.4)) then
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv
                   stop
                endif
                if (dissocstate(ih,jv).eq.5) then													!
c                   write(6,*) 'marker824'															!
                   tempd=12																			!
                elseif (dissocstate(ih,jv).eq.6) then												!
c                   write(6,*) 'marker825'															!
                   tempd=13																			!
                endif																				!
			 elseif (dep(iv,jv).eq.4) then															!Only way for vert to be special and lt 5, cannot be founder
c			    write(6,*) 'Special one is vertical'
			    dep(i,j)=2																			!(Re)Assign deps
			    if (dep(ih,jh).eq.2) then
			       dep(ih,jh)=7
			    else
			       write(6,*) 'bad dep for horizontal'
			       stop
			    endif
			    if (dissocstate(ih,jh).eq.2) then
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh
                   stop
                elseif (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                endif
                if ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then					!
c                   write(6,*) 'marker826'															!
                   if ((state(ih,jv).eq.1).and.(state(ih,jv-1).eq.1)) then
                      tempd=10																		!
                   elseif ((state(ih,jv).eq.-1).or.(state(ih,jv-1).eq.-1)) then
                      tempd=11																		!
                   else
                      write(6,*) 'empty diagonal subunit or subunit below??'
                      stop
                   endif
                endif																				!
			 elseif ((dep(ih,jv).eq.0).or.(dep(ih,jv).eq.2).or.(dep(ih,jv).eq.3).or.(dep(ih,jv).eq.8)) then	!Special one is diagonal
c			    write(6,*) 'Special one is diagonal'
			    dep(i,j)=8
			    if (dissocstate(ih,jh).eq.3) then
			       temph=5
		        elseif (dissocstate(ih,jh).eq.4) then
			       temph=6
			    else
			       write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh
			       stop
			    endif
			    if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                else
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv
                   stop
                endif
             else
                write(6,*) 'Bad dep somewhere'
                stop
             endif
		  endif
       
       return
       end
C
C
C +++++
C
C
       subroutine QCornAllLTFive (i,j,ih,jh,iv,jv,temph,tempv,tempd,dep,dissocstate,state)
       
c   I/O variables       
       integer i,j,ih,jh,iv,jv
       integer temph,tempv,tempd
       integer dep(13,*),dissocstate(13,*),state(13,*)
       
c   Begin...
          if ((ih.gt.i).and.(jv.gt.j)) then															!Adding to lower left corner
             if ((dep(ih,jh).eq.0).or.(dep(ih,jh).eq.2).or.(dep(ih,jh).eq.4)) then					!Horizontal is special/founder
                dep(i,j)=4																			!Change/assign deps
                if (dep(iv,jv).eq.4) then
                   dep(iv,jv)=7
                else
                   write(6,*) 'bad dep for vertical'
                   stop
                endif
                if (dep(ih,jh).eq.0) then															!Horizontal is founder
                   if (state(ih,jh).eq.1) then
                      temph=5
                   elseif (state(ih,jh).eq.-1) then
                      temph=6
                   else
                      write(6,*) 'horizontal subunit not there?'
                      stop
                   endif
                else																				!Horizontal is not founder
                   if (dissocstate(ih,jh).lt.5) then
c                      write(6,*) 'horizontal subunit stays less than 5'
                   endif
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                else
                   write(6,*) 'bad dissocstate 3/4 for vertical'
                   stop
                endif
                if (dissocstate(ih,jv).eq.3) then
                   tempd=5
                elseif (dissocstate(ih,jv).eq.4) then
                   tempd=6
                else
                   write(6,*) 'bad dissocstate 2 for diagonal'
                   stop
                endif
             elseif ((dep(iv,jv).eq.0).or.(dep(iv,jv).eq.1).or.(dep(iv,jv).eq.3)) then				!Vertical is special/founder
                dep(i,j)=1																			!Change/assign deps
                if (dep(ih,jh).eq.1) then
                   dep(ih,jh)=5
                else
                   write(6,*) 'bad dep for horizontal'
                   stop
                endif																	
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                else
                   write(6,*) 'bad dissocstate 2 for horizontal'
                   stop
                endif
                if (dep(iv,jv).eq.0) then															!Vertical is founder
c                   write(6,*) 'marker716'
                   tempv=5
                else																				!Vertical is not founder
                   if (dissocstate(iv,jv).lt.5) then
c                      write(6,*) 'vertical subunit stays less than 5'
                   endif
                endif
                if (dissocstate(ih,jv).eq.2) then
                   if (state(ih,jh).eq.1) then
                      tempd=5
                   elseif (state(ih,jh).eq.-1) then
                      tempd=6
                   else
                      write(6,*) 'diagonal subunit not there?'
                      stop
                   endif
                else
                   write(6,*) 'bad dissocstate 3/4 for diagonal'
                   stop
                endif
             elseif ((dep(ih,jv).eq.0).or.(dep(ih,jv).eq.1).or.(dep(ih,jv).eq.4)) then				!Diagonal is special/founder
                dep(i,j)=6																			!Change/assign deps																	
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                else
                   write(6,*) 'bad dissocstate 2 for horizontal'
                   stop
                endif																
                if (dissocstate(iv,jv).eq.2) then
c                   write(6,*) 'marker768'
                   tempv=5
                else
                   write(6,*) 'bad dissocstate 3/4 for vertical'
                   stop
                endif
                if (dep(ih,jv).eq.0) then															!Diagonal is founder
                   if (state(ih,jh).eq.1) then
                      tempd=5
                   elseif (state(ih,jh).eq.-1) then
                      tempd=6
                   else
                      write(6,*) 'horizontal subunit not there'
                      stop
                   endif
                else   																				!Diagonal is not founder
                   if (dissocstate(ih,jv).lt.5) then
c                      write(6,*) 'diagonal subunit stays less than 5'
                   endif
                endif
             endif
          elseif ((ih.lt.i).and.(jv.gt.j)) then														!Adding to lower right corner
             if ((dep(ih,jh).eq.0).or.(dep(ih,jh).eq.2).or.(dep(ih,jh).eq.3)) then					!Horizontal is special/founder
                dep(i,j)=3																			!Change/assign deps
                if (dep(iv,jv).eq.3) then
                   dep(iv,jv)=8
                else
                   write(6,*) 'bad dep for vertical'
                   stop
                endif
                if (dep(ih,jh).eq.0) then															!Horizontal is founder
                   if (state(ih,jh).eq.1) then
                      temph=5
                   elseif (state(ih,jh).eq.-1) then
                      temph=6
                   else
                      write(6,*) 'horizontal subunit not there?'
                      stop
                   endif
                else																				!Horizontal is not founder
                   if (dissocstate(ih,jh).lt.5) then
c                      write(6,*) 'horizontal subunit stays less than 5'
                   endif
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                else
                   write(6,*) 'bad dissocstate 3/4 for vertical'
                   stop
                endif
                if (dissocstate(ih,jv).eq.3) then
                   tempd=5
                elseif (dissocstate(ih,jv).eq.4) then
                   tempd=6
                else
                   write(6,*) 'bad dissocstate 2 for diagonal'
                   stop
                endif
             elseif ((dep(iv,jv).eq.0).or.(dep(iv,jv).eq.1).or.(dep(iv,jv).eq.4)) then				!Vertical is special/founder
                dep(i,j)=1																			!Change/assign deps
                if (dep(ih,jh).eq.1) then
                   dep(ih,jh)=6
                else
                   write(6,*) 'bad dep for horizontal'
                   stop
                endif																	
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                else
                   write(6,*) 'bad dissocstate 2 for horizontal'
                   stop
                endif
                if (dep(iv,jv).eq.0) then															!Vertical is founder
c                   write(6,*) 'marker1872'
                   tempv=5
                else																				!Vertical is not founder
                   if (dissocstate(iv,jv).lt.5) then
c                      write(6,*) 'vertical subunit stays less than 5'
                   endif
                endif
                if (dissocstate(ih,jv).eq.2) then
                   if (state(ih,jh).eq.1) then
                      tempd=5
                   elseif (state(ih,jh).eq.-1) then
                      tempd=6
                   else
                      write(6,*) 'diagonal subunit not there?'
                      stop
                   endif
                else
                   write(6,*) 'bad dissocstate 3/4 for diagonal'
                   stop
                endif
             elseif ((dep(ih,jv).eq.0).or.(dep(ih,jv).eq.1).or.(dep(ih,jv).eq.3)) then				!Diagonal is special/founder
                dep(i,j)=5																			!Change/assign deps																	
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                else
                   write(6,*) 'bad dissocstate 2 for horizontal'
                   stop
                endif																
                if (dissocstate(iv,jv).eq.2) then
c                   write(6,*) 'marker1873'
                   tempv=5
                else
                   write(6,*) 'bad dissocstate 3/4 for vertical'
                   stop
                endif
                if (dep(ih,jv).eq.0) then															!Diagonal is founder
                   if (state(ih,jh).eq.1) then
                      tempd=5
                   elseif (state(ih,jh).eq.-1) then
                      tempd=6
                   else
                      write(6,*) 'horizontal subunit not there'
                      stop
                   endif
                else   																				!Diagonal is not founder
                   if (dissocstate(ih,jv).lt.5) then
c                      write(6,*) 'diagonal subunit stays less than 5'
                   endif
                endif
             endif
          elseif ((ih.gt.i).and.(jv.lt.j)) then														!Adding to upper left corner
             if ((dep(ih,jh).eq.0).or.(dep(ih,jh).eq.1).or.(dep(ih,jh).eq.4)) then					!Horizontal is special/founder
                dep(i,j)=4																			!Change/assign deps
                if (dep(iv,jv).eq.4) then
                   dep(iv,jv)=6
                else
                   write(6,*) 'bad dep for vertical'
                   stop
                endif
                if (dep(ih,jh).eq.0) then															!Horizontal is founder
                   if (state(ih,jv).eq.1) then
                      temph=5
                   elseif (state(ih,jv).eq.-1) then
                      temph=6
                   else
                      write(6,*) 'diagonal subunit not there?'
                      stop
                   endif
                else																				!Horizontal is not founder
                   if (dissocstate(ih,jh).lt.5) then
c                      write(6,*) 'horizontal subunit stays less than 5'
                   endif
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5	!Could not have gone through hydrolysis yet
                else
                   write(6,*) 'bad dissocstate 3/4 for vertical'
                   stop
                endif
                if (dissocstate(ih,jv).eq.3) then
                   tempd=5
                elseif (dissocstate(ih,jv).eq.4) then
                   tempd=6
                else
                   write(6,*) 'bad dissocstate 2 for diagonal'
                   stop
                endif
             elseif ((dep(iv,jv).eq.0).or.(dep(iv,jv).eq.2).or.(dep(iv,jv).eq.3)) then				!Vertical is special/founder
                dep(i,j)=2																			!Change/assign deps
                if (dep(ih,jh).eq.2) then
                   dep(ih,jh)=8
                else
                   write(6,*) 'bad dep for horizontal'
                   stop
                endif																	
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                else
                   write(6,*) 'bad dissocstate 2 for horizontal'
                   stop
                endif
                if (dep(iv,jv).eq.0) then															!Vertical is founder
                   if (dissocstate(iv,jv).lt.5) then
                      tempv=5																		!no hydrolysis
                   endif
                else																				!Vertical is not founder
                   if (dissocstate(iv,jv).lt.5) then
c                      write(6,*) 'vertical subunit stays less than 5'
                   endif
                endif
                if (dissocstate(ih,jv).eq.2) then
                   if (state(ih,jv).eq.1) then
                      tempd=5
                   elseif (state(ih,jv).eq.-1) then
                      tempd=6
                   else
                      write(6,*) 'diagonal subunit not there?'
                      stop
                   endif
                else
                   write(6,*) 'bad dissocstate 3/4 for diagonal'
                   stop
                endif
             elseif ((dep(ih,jv).eq.0).or.(dep(ih,jv).eq.2).or.(dep(ih,jv).eq.4)) then				!Diagonal is special/founder
                dep(i,j)=7																			!Change/assign deps																	
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                else
                   write(6,*) 'bad dissocstate 2 for horizontal'
                   stop
                endif																
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5	!Could not have gone through hydrolysis yet
                else
                   write(6,*) 'bad dissocstate 3/4 for vertical'
                   stop
                endif
                if (dep(ih,jv).eq.0) then															!Diagonal is founder
                   if (state(ih,jv).eq.1) then
                      tempd=5
                   elseif (state(ih,jv).eq.-1) then
                      tempd=6
                   else
                      write(6,*) 'diagonal subunit not there'
                      stop
                   endif
                else   																				!Diagonal is not founder
                   if (dissocstate(ih,jv).lt.5) then
                      write(6,*) 'diagonal subunit stays less than 5'
                   endif
                endif
             endif
          elseif ((ih.lt.i).and.(jv.lt.j)) then														!Adding to upper right corner
             if ((dep(ih,jh).eq.0).or.(dep(ih,jh).eq.1).or.(dep(ih,jh).eq.3)) then					!Horizontal is special/founder
                dep(i,j)=3																			!Change/assign deps
                if (dep(iv,jv).eq.3) then
                   dep(iv,jv)=5
                else
                   write(6,*) 'bad dep for vertical'
                   stop
                endif
                if (dep(ih,jh).eq.0) then															!Horizontal is founder
                   if (state(ih,jv).eq.1) then
                      temph=5
                   elseif (state(ih,jv).eq.-1) then
                      temph=6
                   else
                      write(6,*) 'horizontal subunit not there?'
                      stop
                   endif
                else																				!Horizontal is not founder
                   if (dissocstate(ih,jh).lt.5) then
c                      write(6,*) 'horizontal subunit stays less than 5'
                   endif
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5	!Could not have gone through hydrolysis yet
                else
                   write(6,*) 'bad dissocstate 3/4 for vertical'
                   stop
                endif
                if (dissocstate(ih,jv).eq.3) then
                   tempd=5
                elseif (dissocstate(ih,jv).eq.4) then
                   tempd=6
                else
                   write(6,*) 'bad dissocstate 2 for diagonal'
                   stop
                endif
             elseif ((dep(iv,jv).eq.0).or.(dep(iv,jv).eq.2).or.(dep(iv,jv).eq.4)) then				!Vertical is special/founder
                dep(i,j)=2																			!Change/assign deps
                if (dep(ih,jh).eq.2) then
                   dep(ih,jh)=7
                else
                   write(6,*) 'bad dep for horizontal'
                   stop
                endif																	
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                else
                   write(6,*) 'bad dissocstate 2 for horizontal'
                   stop
                endif
                if (dep(iv,jv).eq.0) then															!Vertical is founder
                   if (dissocstate(iv,jv).lt.5) then												
                      tempv=5																		!no hydrolysis
                   endif
                else																				!Vertical is not founder
                   if (dissocstate(iv,jv).lt.5) then
c                      write(6,*) 'vertical subunit stays less than 5'
                   endif
                endif
                if (dissocstate(ih,jv).eq.2) then
                   if (state(ih,jv).eq.1) then
                      tempd=5
                   elseif (state(ih,jv).eq.-1) then
                      tempd=6
                   else
                      write(6,*) 'diagonal subunit not there?'
                      stop
                   endif
                else
                   write(6,*) 'bad dissocstate 3/4 for diagonal'
                   stop
                endif
             elseif ((dep(ih,jv).eq.0).or.(dep(ih,jv).eq.2).or.(dep(ih,jv).eq.3)) then				!Diagonal is special/founder
                dep(i,j)=8																			!Change/assign deps																	
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                else
                   write(6,*) 'bad dissocstate 2 for horizontal'
                   stop
                endif																
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5	!Could not have gone through hydrolysis yet
                else
                   write(6,*) 'bad dissocstate 3/4 for vertical'
                   stop
                endif
                if (dep(ih,jv).eq.0) then															!Diagonal is founder
                   if (state(ih,jv).eq.1) then
                      tempd=5
                   elseif (state(ih,jv).eq.-1) then
                      tempd=6
                   else
                      write(6,*) 'diagonal subunit not there'
                      stop
                   endif
                else   																				!Diagonal is not founder
                   if (dissocstate(ih,jv).lt.5) then
c                      write(6,*) 'diagonal subunit stays less than 5'
                   endif
                endif
             endif
          endif
       
       return
       end
C
C
C +++++
C
C
       subroutine QCornFiveFiveCorner (i,j,ih,jh,iv,jv,temph,tempv,tempd,dep,dissocstate,state)
       
c   I/O variables       
       integer i,j,ih,jh,iv,jv
       integer temph,tempv,tempd
       integer dep(13,*),dissocstate(13,*),state(13,*)
       
c   Begin...
          if ((ih.gt.i).and.(jv.gt.j)) then															!Adding to lower left
c             write(6,*) 'Adding to lower left'
             if ((dep(ih,jh).eq.2).or.(dep(ih,jh).eq.4).or.(dep(ih,jh).eq.7).or.(dep(ih,jh).eq.0)) then		!Special one is horizontal
c                write(6,*) 'Special one is horizontal'
                dep(i,j)=4
                dep(iv,jv)=7
                if (dissocstate(iv,jv).eq.5) then													!
c                   write(6,*) 'marker828'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then
c                   write(6,*) 'marker2485'
                   tempv=11
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker830'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker831'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif																				!
                if ((dissocstate(ih,jh).eq.5).or.(dissocstate(ih,jh).eq.6)) then
                   if ((state(i+2,j+1).ne.0).and.(state(i+2,j).ne.0)) then
                      if (dissocstate(ih,jh).eq.5) then												!
c                         write(6,*) 'marker832'														!
                         temph=12																	!
                      elseif (dissocstate(ih,jh).eq.6) then											!
c                         write(6,*) 'marker833'														!
                         temph=13																	!
                      endif																			!
                   else
c                      write(6,*) 'Dissocstate of horizontal stays 5/6'
                   endif
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker834'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker835'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).eq.2) then
                   write(6,*) 'bad dissocstate 2 for ',ih,jv
                   stop
                elseif ((dissocstate(ih,jv).eq.3).or.(dissocstate(ih,jv).eq.4)) then
                   if ((state(i,j+2).ne.0).and.(state(i+1,j+2).ne.0)) then
                      if ((state(ih,jv).eq.1).and.(state(ih,jh).eq.1)) then							!
c                         write(6,*) 'marker836'														!
                         tempd=10																	!
                      elseif ((state(ih,jv).eq.-1).or.(state(ih,jh).eq.-1)) then					!
c                         write(6,*) 'marker837'														!
                         tempd=11																	!
                      else
                         write(6,*) 'empty diagonal or horizontal subunit??'
                         stop
                      endif																			!
                   else
                      if (dissocstate(ih,jv).eq.3) then
                         tempd=5
                      elseif (dissocstate(ih,jv).eq.4) then
                         tempd=6
                      endif
                   endif
                elseif (dissocstate(ih,jv).ge.5) then
                   tempd=8
                endif
             elseif ((dep(iv,jv).eq.1).or.(dep(iv,jv).eq.3).or.(dep(iv,jv).eq.5).or.(dep(iv,jv).eq.0)) then		!Special one is vertical
c                write(6,*) 'Special one is vertical'
                dep(i,j)=1
                dep(ih,jh)=5
                if (dissocstate(ih,jh).eq.5) then													!
c                   write(6,*) 'marker838'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker839'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker840'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker841'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif																				!
                if ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                   if ((state(i,j+2).ne.0).and.(state(i+1,j+2).ne.0)) then
                      if (dissocstate(iv,jv).eq.5) then												!
c                         write(6,*) 'marker842'														!
                         tempv=10																	!
                      elseif (dissocstate(iv,jv).eq.6) then											!
c                         write(6,*) 'marker843'														!
                         tempv=11																	!
                      endif																			!
                   else
c                      write(6,*) 'Dissocstate of vertical stays 5/6'
                   endif
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker844'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker845'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).eq.2) then
c                   write(6,*) 'marker846'															!
                   if ((state(i+2,j+1).ne.0).and.(state(i+2,j).ne.0)) then
                      if (state(ih,jh).eq.1) then													!
                         tempd=12																	!
                      elseif (state(ih,jh).eq.-1) then												!
                         tempd=13																	!
                      else																			!
                         write(6,*) 'empty horizontal subunit??'									!
                         stop																		!
                      endif																			!
                   else
                      if (state(ih,jh).eq.1) then 
                         tempd=5
                      elseif (state(ih,jh).eq.-1) then
                         tempd=6
                      else
                         write(6,*) 'empty horizontal subunit??'
                         stop
                      endif
                   endif
                elseif (dissocstate(ih,jv).ge.5) then
                   tempd=8
                endif
             elseif ((dep(ih,jv).eq.1).or.(dep(ih,jv).eq.4).or.(dep(ih,jv).eq.6).or.(dep(ih,jv).eq.0)) then		!Special one is diagonal
c                write(6,*) 'Special one is diagonal'
                dep(i,j)=6
                tempd=8
                if (dissocstate(ih,jh).eq.5) then													!
c                   write(6,*) 'marker848'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker849'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker850'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker851'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif																				!
                if (dissocstate(iv,jv).eq.5) then													!
c                   write(6,*) 'marker852'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then												!
c                   write(6,*) 'marker853'															!
                   tempv=11																			!
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker854'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker855'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif																				!
             else
                write(6,*) 'no special subunit?'
                stop
             endif
          elseif ((ih.gt.i).and.(jv.lt.j)) then														!Adding to upper left
c             write(6,*) 'Adding to upper left'
             if ((dep(ih,jh).eq.1).or.(dep(ih,jh).eq.4).or.(dep(ih,jh).eq.6).or.(dep(ih,jh).eq.0)) then		!Special one is horizontal
c                write(6,*) 'Special one is horizontal'
                dep(i,j)=4
                dep(iv,jv)=6
                if (dissocstate(iv,jv).eq.5) then													!
c                   write(6,*) 'marker856'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then
c                   write(6,*) 'marker2486'
                   tempv=11
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker858'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker859'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif																				!
                if ((dissocstate(ih,jh).eq.5).or.(dissocstate(ih,jh).eq.6)) then
                   if ((state(i+2,j).ne.0).and.(state(i+2,j-1).ne.0)) then
                      if (dissocstate(ih,jh).eq.5) then												!
c                         write(6,*) 'marker860'														!
                         temph=12																	!
                      elseif (dissocstate(ih,jh).eq.6) then											!
c                         write(6,*) 'marker861'														!
                         temph=13																	!
                      endif																			!
                   else
c                      write(6,*) 'Dissocstate of horizontal stays 5/6'
                   endif
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker862'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker863'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).eq.2) then
                   write(6,*) 'bad dissocstate 2 for ',ih,jv
                   stop
                elseif ((dissocstate(ih,jv).eq.3).or.(dissocstate(ih,jv).eq.4)) then
                   if ((state(i,j-2).ne.0).and.(state(i+1,j-2).ne.0)) then
                      if ((state(ih,jv).eq.1).and.(state(ih,jv-1).eq.1)) then						!
c                         write(6,*) 'marker864'														!
                         tempd=10																	!
                      elseif ((state(ih,jv).eq.-1).or.(state(ih,jv-1).eq.-1)) then					!
c                         write(6,*) 'marker865'														!
                         tempd=11																	!
                      else
                         write(6,*) 'empty diagonal subunit or subunit below??'
                         stop
                      endif																			!
                   else
                      if (dissocstate(ih,jv).eq.3) then
                         tempd=5
                      elseif (dissocstate(ih,jv).eq.4) then
                         tempd=6
                      endif
                   endif
                elseif (dissocstate(ih,jv).ge.5) then
                   tempd=8
                endif
             elseif((dep(iv,jv).eq.2).or.(dep(iv,jv).eq.3).or.(dep(iv,jv).eq.8).or.(dep(iv,jv).eq.0)) then	!Special one is vertical
c                write(6,*) 'Special one is vertical'
                dep(i,j)=2
                dep(ih,jh)=8
                if (dissocstate(ih,jh).eq.5) then													!
c                   write(6,*) 'marker866'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker867'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker868'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker869'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif																				!
                if ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                   if ((state(i,j-2).ne.0).and.(state(i+1,j-2).ne.0)) then
                      if (dissocstate(iv,jv).eq.5) then												!
c                         write(6,*) 'marker870'														!
                         tempv=10																	!
                      elseif (dissocstate(iv,jv).eq.6) then											!
c                         write(6,*) 'marker871'														!
                         tempv=11																	!
                      endif																			!
                   else
c                      write(6,*) 'Dissocstate of vertical stays 5/6'
                   endif
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker872'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker873'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).eq.2) then
                   if ((state(i+2,j).ne.0).and.(state(i+2,j-1).ne.0)) then
                      if (state(ih,jv).eq.1) then													!
c                         write(6,*) 'marker874'														!
                         tempd=12																	!
                      elseif (state(ih,jv).eq.-1) then												!
c                         write(6,*) 'marker875'														!
                         tempd=13																	!
                      endif																			!
                   else
                      if (state(ih,jv).eq.1) then
                         tempd=5
                      elseif (state(ih,jv).eq.-1) then
                         tempd=6
                      endif
                   endif
                elseif ((dissocstate(ih,jv).eq.3).or.(dissocstate(ih,jv).eq.4)) then
                   write(6,*) 'bad dissocstate ',dissocstate(ih,jv),'for',ih,jv
                   stop
                elseif (dissocstate(ih,jv).ge.5) then
                   tempd=8
                endif
             elseif ((dep(ih,jv).eq.2).or.(dep(ih,jv).eq.4).or.(dep(ih,jv).eq.7).or.(dep(ih,jv).eq.0)) then		!Special one is diagonal
c                write(6,*) 'Special one is diagonal'
                dep(i,j)=7
                tempd=8
                if (dissocstate(ih,jh).eq.5) then													!
c                   write(6,*) 'marker876'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker877'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker878'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker879'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif																				!
                if (dissocstate(iv,jv).eq.5) then													!
c                   write(6,*) 'marker880'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then
c                   write(6,*) 'marker2487'
                   tempv=11
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker882'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker883'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif																				!
             endif
          elseif ((ih.lt.i).and.(jv.gt.j)) then														!Adding to lower right
c             write(6,*) 'Adding to lower right corner'
             if ((dep(ih,jh).eq.2).or.(dep(ih,jh).eq.3).or.(dep(ih,jh).eq.8).or.(dep(ih,jh).eq.0)) then		!Special one is horizontal
c                write(6,*) 'Special one is horizontal'
                dep(i,j)=3
                dep(iv,jv)=8
                if (dissocstate(iv,jv).eq.5) then													!
c                   write(6,*) 'marker884'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then
c                   write(6,*) 'marker2488'
                   tempv=11
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker886'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker887'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif																				!
                if ((dissocstate(ih,jh).eq.5).or.(dissocstate(ih,jh).eq.6)) then
                   if ((state(i-2,j+1).ne.0).and.(state(i-2,j).ne.0)) then
                      if (dissocstate(ih,jh).eq.5) then												!
c                         write(6,*) 'marker888'														!
                         temph=12																	!
                      elseif (dissocstate(ih,jh).eq.6) then											!
c                         write(6,*) 'marker889'														!
                         temph=13																	!
                      endif																			!
                   else
c                      write(6,*) 'Dissocstate of horizontal stays 5/6'
                   endif
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker890'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker891'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).eq.2) then
                   write(6,*) 'bad dissocstate 2 for ',ih,jv
                   stop
                elseif ((dissocstate(ih,jv).eq.3).or.(dissocstate(ih,jv).eq.4)) then
                   if ((state(i-1,j+2).ne.0).and.(state(i,j+2).ne.0)) then
                      if ((state(ih,jv).eq.1).and.(state(ih,jh).eq.1)) then							!
c                         write(6,*) 'marker892'														!
                         tempd=10																	!
                      elseif ((state(ih,jv).eq.-1).or.(state(ih,jh).eq.-1)) then					!
c                         write(6,*) 'marker893'														!
                         tempd=11																	!
                      else
                         write(6,*) 'empty diagonal or horizontal subunit??'
                         stop
                      endif																			!
                   else
                      if (dissocstate(ih,jv).eq.3) then
                         tempd=5
                      elseif (dissocstate(ih,jv).eq.4) then
                         tempd=6
                      endif
                   endif
                elseif (dissocstate(ih,jv).ge.5) then
                   tempd=8
                endif
             elseif ((dep(iv,jv).eq.1).or.(dep(iv,jv).eq.4).or.(dep(iv,jv).eq.6).or.(dep(iv,jv).eq.0)) then		!Special one is vertical
c                write(6,*) 'Special one is vertical'
                dep(i,j)=1
                dep(ih,jh)=6
                if (dissocstate(ih,jh).eq.5) then													!
c                   write(6,*) 'marker894'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker895'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker896'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker897'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif																				!
                if ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                   if ((state(i-1,j+2).ne.0).and.(state(i,j+2).ne.0)) then
                      if (dissocstate(iv,jv).eq.5) then												!
c                         write(6,*) 'marker898'														!
                         tempv=10																	!
                      elseif (dissocstate(iv,jv).eq.6) then											!
c                         write(6,*) 'marker899'														!
                         tempv=11																	!
                      endif																			!
                   else
c                      write(6,*) 'Dissocstate of vertical stays 5/6'
                   endif
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker900'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker901'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).eq.2) then
c                   write(6,*) 'marker902'															!
                   if ((state(i-2,j+1).ne.0).and.(state(i-2,j).ne.0)) then
                      if (state(ih,jh).eq.1) then													!
                         tempd=12																	!
                      elseif (state(ih,jh).eq.-1) then												!
                         tempd=13																	!
                      else																			!
                         write(6,*) 'empty horizontal subunit??'									!
                         stop																		!
                      endif																			!
                   else
                      if (state(ih,jh).eq.1) then
                         tempd=5
                      elseif (state(ih,jh).eq.-1) then
                         tempd=6
                      else
                         write(6,*) 'empty horizontal subunit??'
                         stop
                      endif
                   endif
                elseif ((dissocstate(ih,jv).eq.3).or.(dissocstate(ih,jv).eq.4)) then
                   write(6,*) 'bad dissocstate ',dissocstate(ih,jv),' for ',ih,jv
                   stop
                elseif (dissocstate(ih,jv).ge.5) then
                   tempd=8
                endif
             elseif ((dep(ih,jv).eq.1).or.(dep(ih,jv).eq.3).or.(dep(ih,jv).eq.5).or.(dep(ih,jv).eq.0)) then		!Special one is diagonal
c                write(6,*) 'Special one is diagonal'
                dep(i,j)=5
                tempd=8
                if (dissocstate(ih,jh).eq.5) then													!
c                   write(6,*) 'marker904'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker905'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker906'															!
                   temph=8																			!
                else
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif																				!
                if (dissocstate(iv,jv).eq.5) then													!
c                   write(6,*) 'marker907'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then												!
c                   write(6,*) 'marker908'															!
                   tempv=11																			!
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker909'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker910'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif																				!
             else
                write(6,*) 'no special subunit?'
                stop
             endif
          else																						!Adding to upper right
c             write(6,*) 'Adding to upper right'
             if ((dep(ih,jh).eq.1).or.(dep(ih,jh).eq.3).or.(dep(ih,jh).eq.5).or.(dep(ih,jh).eq.0)) then		!Special one is horizontal
c                write(6,*) 'Special one is horizontal'
                dep(i,j)=3
                dep(iv,jv)=5
                if (dissocstate(iv,jv).eq.5) then													!
c                   write(6,*) 'marker911'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then
c                   write(6,*) 'marker2489'
                   tempv=11
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker913'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker914'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif																				!
                if ((dissocstate(ih,jh).eq.5).or.(dissocstate(ih,jh).eq.6)) then
                   if ((state(i-2,j).ne.0).and.(state(i-2,j-1).ne.0)) then
                      if (dissocstate(ih,jh).eq.5) then												!
c                         write(6,*) 'marker915'														!
                         temph=12																	!
                      elseif (dissocstate(ih,jh).eq.6) then											!
c                         write(6,*) 'marker916'														!
                         temph=13																	!
                      endif																			!
                   else
c                      write(6,*) 'Dissocstate of horizontal stays 5/6'
                   endif
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker917'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker918'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).eq.2) then
                   write(6,*) 'bad dissocstate 2 for',ih,jv
                   stop
                elseif ((dissocstate(ih,jv).eq.3).or.(dissocstate(ih,jv).eq.4)) then
                   if ((state(i-1,j-2).ne.0).and.(state(i,j-2).ne.0)) then
                      if ((state(ih,jv).eq.1).and.(state(ih,jv-1).eq.1)) then						!
c                         write(6,*) 'marker919'														!
                         tempd=10																	!
                      elseif ((state(ih,jv).eq.-1).or.(state(ih,jv-1).eq.-1)) then					!
c                         write(6,*) 'marker920'														!
                         tempd=11																	!
                      else
                         write(6,*) 'empty diagonal subunit or subunit below??'
                         stop
                      endif																			!
                   else
                      if (dissocstate(ih,jv).eq.3) then
                         tempd=5
                      elseif (dissocstate(ih,jv).eq.4) then
                         tempd=6
                      endif
                   endif
                elseif (dissocstate(ih,jv).ge.5) then
                   tempd=8
                endif
             elseif ((dep(iv,jv).eq.2).or.(dep(iv,jv).eq.4).or.(dep(iv,jv).eq.7).or.(dep(iv,jv).eq.0)) then		!Special one is vertical
c                write(6,*) 'Special one is vertical'
                dep(i,j)=2
                dep(ih,jh)=7
                if (dissocstate(ih,jh).eq.5) then													!
c                   write(6,*) 'marker921'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker922'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker923'															!
                   temph=8																			!
                else
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif																				!
                if ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                   if ((state(i-1,j-2).ne.0).and.(state(i,j-2).ne.0)) then
                      if (dissocstate(iv,jv).eq.5) then												!
c                         write(6,*) 'marker924'														!
                         tempv=10																	!
                      elseif (dissocstate(iv,jv).eq.6) then											!
c                         write(6,*) 'marker925'														!
                         tempv=11																	!
                      endif																			!
                   else
c                      write(6,*) 'Dissocstate of vertical stays 5/6'
                   endif
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker926'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker927'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if (dissocstate(ih,jv).eq.2) then
                   if ((state(i-2,j).ne.0).and.(state(i-2,j-1).ne.0)) then
                      if (state(ih,jv).eq.1) then													!
c                         write(6,*) 'marker928'														!
                         tempd=12																	!
                      elseif (state(ih,jv).eq.-1) then												!
c                         write(6,*) 'marker929'														!
                         tempd=13																	!
                      endif																			!
                   else
                      if (state(ih,jv).eq.1) then
                         tempd=5
                      elseif (state(ih,jv).eq.-1) then
                         tempd=6
                      endif
                   endif
                elseif ((dissocstate(ih,jv).eq.3).or.(dissocstate(ih,jv).eq.4)) then
                   write(6,*) 'bad dissocstate ',dissocstate(ih,jv),' for ',ih,jv
                   stop
                elseif (dissocstate(ih,jv).ge.5) then
                   tempd=8
                endif
             elseif ((dep(ih,jv).eq.2).or.(dep(ih,jv).eq.3).or.(dep(ih,jv).eq.8).or.(dep(ih,jv).eq.0)) then		!Special one is diagonal
c                write(6,*) 'Special one is diagonal'
                dep(i,j)=8
                tempd=8
                if (dissocstate(ih,jh).eq.5) then													!
c                   write(6,*) 'marker930'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker931'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker932'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker933'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif																				!
                if (dissocstate(iv,jv).eq.5) then													!
c                   write(6,*) 'marker934'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then
c                   write(6,*) 'marker2490'
                   tempv=11
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker936'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker937'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif																				!
             else
                write(6,*) 'no special subunit?'
                stop
             endif
          endif
       
       return
       end
       
       
       subroutine QCornFiveNotFive (i,j,ih,jh,iv,jv,temph,tempv,tempd,dep,dissocstate,state)
       
c   I/O variables       
       integer i,j,ih,jh,iv,jv
       integer temph,tempv,tempd
       integer dep(13,*),dissocstate(13,*),state(13,*)
       
c   Begin...
C
C Only correct the upper adds so far
C
          if ((ih.lt.i).and.(jv.gt.j)) then															!Adding to lower right
             write(6,*) 'Adding to lower right'
             stop
             if ((dep(ih,jh).eq.0).or.(dep(ih,jh).eq.2).or.(dep(ih,jh).eq.3).or.(dep(ih,jh).eq.8)) then		!Special one is to the left
c                write(6,*) 'horizontal is special/founder'
                dep(i,j)=3
                dep(iv,jv)=8
                if (dep(ih,jh).eq.0) then															!Horizontal is founder
                   if (dissocstate(ih,jh).lt.5) then
                      if (state(ih,jh).eq.1) then
                         temph=5																	
                      elseif (state(ih,jh).eq.-1) then
                         temph=6
                      else
                         write(6,*) 'empty horizontal subunit??'
                         stop
                      endif
                   elseif ((dissocstate(ih,jh).eq.5).or.(dissocstate(ih,jh).eq.6)) then
                      if ((state(ih-1,jh).ne.0).and.(state(ih-1,jh+1).ne.0)) then
                         if (dissocstate(ih,jh).eq.5) then											!
c                            write(6,*) 'marker938'													!
                            temph=12																!
                         elseif (dissocstate(ih,jh).eq.6) then										!
c                            write(6,*) 'marker939'													!
                            temph=13																!
                         endif																		!
                      else
c                         write(6,*) 'founder stays dissocstate 5/6'
                      endif
                   elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then			!
c                      write(6,*) 'marker940'														!
                      temph=8																		!
                   else
c                      write(6,*) 'marker941'														!
                      write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh					!
                      stop																			!
                   endif												
                else																				!Horizontal is not founder
                   if (dissocstate(ih,jh).lt.5) then
c                      write(6,*) 'horizontal stays less than 5'
                   elseif ((dissocstate(ih,jh).eq.5).or.(dissocstate(ih,jh).eq.6)) then
                      if ((state(ih-1,jh).ne.0).and.(state(ih-1,jh+1).ne.0)) then
                         if (dissocstate(ih,jh).eq.5) then											!
c                            write(6,*) 'marker942'													!
                            temph=12																!
                         elseif (dissocstate(ih,jh).eq.6) then										!
c                            write(6,*) 'marker943'													!
                            temph=13																!
                         endif																		!
                      else
c                         write(6,*) 'horizontal stays dissocstate 5/6'
                      endif
                   elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then			!
c                      write(6,*) 'marker944'														!
                      temph=8																		!
                   else
c                      write(6,*) 'marker945'														!
                      write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh					!
                      stop																			!
                   endif
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                elseif (dissocstate(iv,jv).eq.5) then												!
c                   write(6,*) 'marker946'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then
c                   write(6,*) 'marker2491'
                   tempv=11
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker2492'
                   tempv=8																			!
                else
c                   write(6,*) 'marker948'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if ((dissocstate(ih,jv).eq.3).or.(dissocstate(ih,jv).eq.4)) then
                   if ((state(ih-1,jv).ne.0).and.(state(ih-1,jv+1).ne.0).and.
     @                (state(ih,jv+1).ne.0).and.(state(ih+1,jv+1).ne.0)) then
c                      write(6,*) 'marker1856'
                      tempd=8
                   elseif ((state(ih,jv+1).ne.0).and.(state(ih+1,jv+1).ne.0)) then
                      if ((state(ih,jv).eq.1).and.(state(ih,jh).eq.1)) then							!
c                         write(6,*) 'marker949'														!
                         tempd=10																	!
                      elseif ((state(ih,jv).eq.-1).or.(state(ih,jh).eq.-1)) then					!
c                         write(6,*) 'marker950'														!
                         tempd=11																	!
                      else
                         write(6,*) 'empty diagonal or horizontal subunit??'
                         stop
                      endif																			!
                   elseif (dissocstate(ih,jv).eq.3) then
                      tempd=5
                   elseif (dissocstate(ih,jv).eq.4) then
                      tempd=6
                   endif
                elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then				!
                   if ((state(ih-1,jv-1).ne.0).and.(state(ih-1,jv).ne.0).and.
     @                (state(ih,jv+1).ne.0).and.(state(ih+1,jv+1).ne.0)) then
                      tempd=8
                   else
                      if (dissocstate(ih,jv).eq.5) then
c                         write(6,*) 'marker951'														!
                         tempd=12																	!
                      elseif (dissocstate(ih,jv).eq.6) then											!
c                         write(6,*) 'marker952'														!
                         tempd=13																	!
                      endif
                   endif
                else
                   write(6,*) 'bad dissocstate',dissocstate(ih,jv),'for',ih,jv						!
                   stop																				!
                endif
             elseif ((dep(iv,jv).eq.0).or.(dep(iv,jv).eq.1).or.(dep(iv,jv).eq.4).or.(dep(iv,jv).eq.6)) then		!Special one is above
c                write(6,*) 'vertical is special/founder'
                dep(i,j)=1
                dep(ih,jh)=6
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                elseif (dissocstate(ih,jh).eq.5) then												!
c                   write(6,*) 'marker953'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker954'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker955'															!
                   temph=8																			!
                else
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (dep(iv,jv).eq.0) then															!Vertical is founder
                   if (dissocstate(iv,jv).lt.5) then
                      tempv=5																		!no hydrolysis event yet
                   elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                      if ((state(iv-1,jv+1).ne.0).and.(state(iv,jv+1).ne.0)) then
                         if (dissocstate(iv,jv).eq.5) then											!
c                            write(6,*) 'marker956'													!
                            tempv=10																!
                         elseif (dissocstate(iv,jv).eq.6) then										!
c                            write(6,*) 'marker957'													!
                            tempv=11																!
                         endif																		!
                      else
c                         write(6,*) 'founder stays dissocstate 5/6'
                      endif
                   elseif (dissocstate(iv,jv).ge.12) then											!
c                      write(6,*) 'marker958'														!
                      tempv=8																		!
                   else
c                      write(6,*) 'marker959'														!
                      write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv					!
                      stop																			!
                   endif
                else																				!Vertical is not founder
                   if (dissocstate(iv,jv).lt.5) then
c                      write(6,*) 'vertical stays less than 5'
                   elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                      if ((state(iv-1,jv+1).ne.0).and.(state(iv,jv+1).ne.0)) then
                         if (dissocstate(iv,jv).eq.5) then											!
c                            write(6,*) 'marker960'													!
                            tempv=10																!
                         elseif (dissocstate(iv,jv).eq.6) then										!
c                            write(6,*) 'marker961'													!
                            tempv=11																!
                         endif																		!
                      else
c                         write(6,*) 'vertical stays dissocstate 5/6'
                      endif
                   elseif (dissocstate(iv,jv).ge.12) then											!
c                      write(6,*) 'marker962'														!
                      tempv=8																		!
                   else
c                      write(6,*) 'marker963'														!
                      write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv					!
                      stop																			!
                   endif
                endif
                if (dissocstate(ih,jv).eq.2) then
                   if ((state(ih-1,jv-1).ne.0).and.(state(ih-1,jv).ne.0).and.
     @                (state(ih-1,jv+1).ne.0).and.(state(ih,jv+1).ne.0)) then
c                      write(6,*) 'marker1857'
                      tempd=8
                   elseif ((state(ih-1,jv).ne.0).and.(state(ih-1,jv-1).ne.0)) then
                      if (state(ih,jh).eq.1) then													!
c                         write(6,*) 'marker964'														!
                         tempd=12																	!
                      elseif (state(ih,jh).eq.-1) then												!
c                         write(6,*) 'marker965'														!
                         tempd=13																	!
                      endif																			!
                   elseif (state(ih,jh).eq.1) then
                      tempd=5
                   elseif (state(ih,jh).eq.-1) then
                      tempd=6
                   else
                      write(6,*) 'empty horizontal subunit?'
                      stop
                   endif
                elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then				!
c                   write(6,*) 'marker966'															!
                   if ((state(ih-1,jv-1).ne.0).and.(state(ih-1,jv).ne.0).and.
     @                (state(ih,jv+1).ne.0).and.(state(ih+1,jv+1).ne.0)) then
                      tempd=8
                   else
                      if ((state(ih,jv).eq.1).and.(state(ih,jh).eq.1)) then
                         tempd=10																	!
                      elseif ((state(ih,jv).eq.-1).or.(state(ih,jh).eq.-1)) then
                         tempd=11																	!
                      else
                         write(6,*) 'empty diagonal or horizontal subunit??'
                         stop
                      endif
                   endif
                else
c                   write(6,*) 'marker968'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jv),'for',ih,jv						!
                   stop																				!
                endif
             elseif ((dep(ih,jv).eq.0).or.(dep(ih,jv).eq.1).or.(dep(ih,jv).eq.3).or.(dep(ih,jv).eq.5)) then		!Special one is diagonal
c                write(6,*)  'diagonal is special/founder'
                dep(i,j)=5
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                elseif (dissocstate(ih,jh).eq.5) then												!
c                   write(6,*) 'marker969'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker970'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker971'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker972'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for ',ih,jh						!
                   stop																				!
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                elseif (dissocstate(iv,jv).eq.5) then												!
c                   write(6,*) 'marker973'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then												!
c                   write(6,*) 'marker974'															!
                   tempv=11																			!
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker2493'
                   tempv=8																			!
                else
c                   write(6,*) 'marker975'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if (dep(ih,jv).eq.0) then															!Diagonal is founder
                   if (dissocstate(ih,jv).lt.5) then
                      if (state(ih,jh).eq.1) then
                         tempd=5
                      elseif (state(ih,jh).eq.-1) then
                         tempd=6
                      else
                         write(6,*) 'empty horizontal subunit??'
                         stop
                      endif
                   elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
                      if ((state(ih-1,jv-1).ne.0).and.(state(ih-1,jv).ne.0).and.
     @                   (state(ih,jv+1).ne.0).and.(state(ih+1,jv+1).ne.0)) then
                         tempd=8
                      elseif ((state(i-1,j+2).ne.0).and.(state(i,j+2).ne.0)) then					!
                         if ((state(ih,jv).eq.1).and.(state(ih,jh).eq.1)) then						!
c                            write(6,*) 'marker976'													!
                            tempd=10																!
                         elseif ((state(ih,jv).eq.-1).or.(state(ih,jh).eq.-1)) then					!
c                            write(6,*) 'marker977'													!
                            tempd=11																!
                         else
                            write(6,*) 'empty diagonal or horizontal subunit??'
                            stop
                         endif																		!
                      elseif ((state(i-2,j+1).ne.0).and.(state(i-2,j).ne.0)) then					!
                         if (dissocstate(ih,jv).eq.5) then											!
c                            write(6,*) 'marker978'													!
                            tempd=12																!
                         elseif (dissocstate(ih,jv).eq.6) then										!
c                            write(6,*) 'marker979'													!
                            tempd=13																!
                         endif																		!
                      endif																			!
                   else
                      write(6,*) 'bad dissocstate',dissocstate(ih,jv),'for',ih,jv					!
                      stop																			!
                   endif
                else																				!Diagonal is not founder
                   if (dissocstate(ih,jv).lt.5) then
c                      write(6,*) 'diagonal stays less than 5'
                   elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
c                      write(6,*) 'marker980'														!
                      if ((state(ih-1,jv-1).ne.0).and.(state(ih-1,jv).ne.0).and.
     @                   (state(ih,jv+1).ne.0).and.(state(ih+1,jv+1).ne.0)) then
                         tempd=8
                      elseif ((state(i-1,j+2).ne.0).and.(state(i,j+2).ne.0)) then					!
                         if ((state(ih,jv).eq.1).and.(state(ih,jh).eq.1)) then						!
                            tempd=10																!
                         elseif ((state(ih,jv).eq.-1).or.(state(ih,jh).eq.-1)) then					!
                            tempd=11																!
                         else
                            write(6,*) 'empty diagonal or horizontal subunit??'
                            stop
                         endif																		!
                      elseif ((state(i-2,j+1).ne.0).and.(state(i-2,j).ne.0)) then					!
                         if (dissocstate(ih,jv).eq.5) then											!
                            tempd=12																!
                         elseif (dissocstate(ih,jv).eq.6) then										!
                            tempd=13																!
                         endif																		!
                      endif																			!
                   else
                      write(6,*) 'bad dissocstate',dissocstate(ih,jv),'for',ih,jv					!
                      stop																			!
                   endif
                endif
             else
                write(6,*) 'no special subunit?'
                stop
             endif
          elseif ((ih.gt.i).and.(jv.gt.j)) then														!Adding to lower left
             write(6,*) 'Adding to lower left'
             stop
             if ((dep(ih,jh).eq.0).or.(dep(ih,jh).eq.2).or.(dep(ih,jh).eq.4).or.(dep(ih,jh).eq.7)) then		!Special one is to the right
c                write(6,*) 'horizontal is special/founder'
                dep(i,j)=4
                dep(iv,jv)=7
                if (dep(ih,jh).eq.0) then															!Horizontal is founder
                   if (dissocstate(ih,jh).lt.5) then
                      if (state(ih,jh).eq.1) then
                         temph=5
                      elseif (state(ih,jh).eq.-1) then
                         temph=6
                      else
                         write(6,*) 'empty horizontal subunit??'
                         stop
                      endif
                   elseif ((dissocstate(ih,jh).eq.5).or.(dissocstate(ih,jh).eq.6)) then
c                      write(6,*) 'marker981'														!
                      if ((state(ih+1,jh+1).ne.0).and.(state(ih+1,jh).ne.0)) then
                         if (dissocstate(ih,jh).eq.5) then											!
                            temph=12																!
                         elseif (dissocstate(ih,jh).eq.6) then										!
                            temph=13																!
                         endif																		!
                      else
c                         write(6,*) 'founder stays dissocstate 5/6'
                      endif
                   elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then			!
c                      write(6,*) 'marker982'														!
                      temph=8																		!
                   else
                      write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh					!
                      stop																			!
                   endif
                else																				!Horizontal is not founder
                   if (dissocstate(ih,jh).lt.5) then
c                      write(6,*) 'horizontal stays less than 5'
                   elseif ((dissocstate(ih,jh).eq.5).or.(dissocstate(ih,jh).eq.6)) then
                      if ((state(ih+1,jh+1).ne.0).and.(state(ih+1,jh).ne.0)) then
                         if (dissocstate(ih,jh).eq.5) then											!
c                            write(6,*) 'marker983'													!
                            temph=12																!
                         elseif (dissocstate(ih,jh).eq.6) then										!
c                            write(6,*) 'marker984'													!
                            temph=13																!
                         endif																		!
                      else
c                         write(6,*) 'horizontal stays dissocstate 5/6'
                      endif
                   elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then			!
c                      write(6,*) 'marker985'														!
                      temph=8																		!
                   else
c                      write(6,*) 'marker986'														!
                      write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh					!
                      stop																			!
                   endif
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                elseif (dissocstate(iv,jv).eq.5) then												!
c                   write(6,*) 'marker987'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then
c                   write(6,*) 'marker2494'
                   tempv=11
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker989'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker990'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for ',iv,jv						!
                   stop																				!
                endif
                if ((dissocstate(ih,jv).eq.3).or.(dissocstate(ih,jv).eq.4)) then
                   if ((state(ih-1,jv+1).ne.0).and.(state(ih,jv+1).ne.0).and.
     @                (state(ih+1,jv+1).ne.0).and.(state(ih+1,jv).ne.0)) then
c                      write(6,*) 'marker1858'
                      tempd=8
                   elseif ((state(ih-1,jv+1).ne.0).and.(state(ih,jv+1).ne.0)) then
                      if ((state(ih,jv).eq.1).and.(state(ih,jh).eq.1)) then							!
c                         write(6,*) 'marker991'														!
                         tempd=10																	!
                      elseif ((state(ih,jv).eq.-1).or.(state(ih,jh).eq.-1)) then					!
c                         write(6,*) 'marker992'														!
                         tempd=11																	!
                      else
                         write(6,*) 'empty diagonal or horizontal subunit??'
                         stop
                      endif																			!
                   elseif (dissocstate(ih,jv).eq.3) then
                      tempd=5
                   elseif (dissocstate(ih,jv).eq.4) then
                      tempd=6
                   endif
                elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then				!
                   if ((state(ih-1,jv+1).ne.0).and.(state(ih,jv+1).ne.0).and.
     @                (state(ih+1,jv).ne.0).and.(state(ih+1,jv-1).ne.0)) then
                      tempd=8
                   else
                      if (dissocstate(ih,jv).eq.5) then
c                         write(6,*) 'marker993'														!
                         tempd=12																	!
                      elseif (dissocstate(ih,jv).eq.6) then											!
c                         write(6,*) 'marker994'														!
                         tempd=13																	!
                      endif
                   endif
                else
c                   write(6,*) 'marker995'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jv),'for',ih,jv						!
                   stop																				!
                endif
             elseif ((dep(iv,jv).eq.0).or.(dep(iv,jv).eq.1).or.(dep(iv,jv).eq.3).or.(dep(iv,jv).eq.5)) then		!Special one is above
c                write(6,*) 'vertical is special/founder'
                dep(i,j)=1
                dep(ih,jh)=5
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                elseif (dissocstate(ih,jh).eq.5) then												!
c                   write(6,*) 'marker996'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker997'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker998'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker999'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (dep(iv,jv).eq.0) then															!Vertical is founder
                   if (dissocstate(iv,jv).lt.5) then
                      tempv=5																		!no hydrolysis event yet
                   elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                      if ((state(iv,jv+1).ne.0).and.(state(iv+1,jv+1).ne.0)) then
                         if (dissocstate(iv,jv).eq.5) then											!
c                            write(6,*) 'marker20000'													!
                            tempv=10																!
                         elseif (dissocstate(iv,jv).eq.6) then										!
c                            write(6,*) 'marker1001'													!
                            tempv=11																!
                         endif																		!
                      else
c                         write(6,*) 'founder stays dissocstate 5/6'
                      endif
                   elseif (dissocstate(iv,jv).ge.12) then											!
c                      write(6,*) 'marker1002'														!
                      tempv=8																		!
                   else
c                      write(6,*) 'marker1003'														!
                      write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv					!
                      stop																			!
                   endif
                else																				!Vertical is not founder
                   if (dissocstate(iv,jv).lt.5) then
c                      write(6,*) 'vertical stays less than 5'
                   elseif ((dissocstate(iv,jv).eq.5).or.(dissocstate(iv,jv).eq.6)) then
                      if ((state(iv,jv+1).ne.0).and.(state(iv+1,jv+1).ne.0)) then
                         if (dissocstate(iv,jv).eq.5) then											!
c                            write(6,*) 'marker1004'													!
                            tempv=10																!
                         elseif (dissocstate(iv,jv).eq.6) then										!
c                            write(6,*) 'marker1005'													!
                            tempv=11																!
                         endif																		!
                      else
c                         write(6,*) 'vertical stays dissocstate 5/6'
                      endif
                   elseif (dissocstate(iv,jv).ge.12) then											!
c                      write(6,*) 'marker1006'														!
                      tempv=8																		!
                   else
c                      write(6,*) 'marker1007'														!
                      write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv					!
                      stop																			!
                   endif
                endif
                if (dissocstate(ih,jv).eq.2) then
                   if ((state(ih,jv+1).ne.0).and.(state(ih+1,jv+1).ne.0).and.
     @                (state(ih+1,jv).ne.0).and.(state(ih+1,jv-1).ne.0)) then
c                      write(6,*) 'marker1859'
                      tempd=8
                   elseif ((state(ih+1,jv).ne.0).and.(state(ih+1,jv-1).ne.0)) then
                      if (state(ih,jh).eq.1) then													!
c                         write(6,*) 'marker1008'													!
                         tempd=12																	!
                      elseif (state(ih,jh).eq.-1) then												!
c                         write(6,*) 'marker1009'													!
                         tempd=13																	!
                      endif																			!
                   elseif (state(ih,jh).eq.1) then
                      tempd=5
                   elseif (state(ih,jh).eq.-1) then
                      tempd=6
                   else
                      write(6,*) 'empty horizontal subunit?'
                      stop
                   endif
                elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then				!
c                   write(6,*) 'marker1010'															!
                   if ((state(ih-1,jv+1).ne.0).and.(state(ih,jv+1).ne.0).and.
     @                (state(ih+1,jv).ne.0).and.(state(ih+1,jv-1).ne.0)) then
                      tempd=8
                   else
                      if ((state(ih,jv).eq.1).and.(state(ih,jh).eq.1)) then
                         tempd=10																	!
                      elseif ((state(ih,jv).eq.-1).or.(state(ih,jh).eq.-1)) then
                         tempd=11																	!
                      else
                         write(6,*) 'empty diagonal or horizontal subunit??'
                         stop
                      endif
                   endif
                else
                   write(6,*) 'bad dissocstate',dissocstate(ih,jv),'for',ih,jv						!
                   stop																				!
                endif
             elseif ((dep(ih,jv).eq.0).or.(dep(ih,jv).eq.1).or.(dep(ih,jv).eq.4).or.(dep(ih,jv).eq.6)) then		!Special one is diagonal
c                write(6,*) 'diagonal is special/founder'
                dep(i,j)=6
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                elseif (dissocstate(ih,jh).eq.5) then												!
c                   write(6,*) 'marker1012'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker1013'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker1014'															!
                   temph=8																			!
                else
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5
                elseif (dissocstate(iv,jv).eq.5) then												!
c                   write(6,*) 'marker1015'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then												!
c                   write(6,*) 'marker1016'															!
                   tempv=11																			!
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker1017'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker1018'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if (dep(ih,jv).eq.0) then															!Diagonal is founder
                   if (dissocstate(ih,jv).lt.5) then
                      if (state(ih,jh).eq.1) then
                         tempd=5
                      elseif (state(ih,jh).eq.-1) then
                         tempd=6
                      else
                         write(6,*) 'empty horizontal subunit??'
                         stop
                      endif
                   elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
c                      write(6,*) 'marker1019'														!
                      if ((state(ih-1,jv+1).ne.0).and.(state(ih,jv+1).ne.0).and.
     @                   (state(ih+1,jv).ne.0).and.(state(ih+1,jv-1).ne.0)) then
                         tempd=8
                      elseif ((state(i,j+2).ne.0).and.(state(i+1,j+2).ne.0)) then					!
                         if ((state(ih,jv).eq.1).and.(state(ih,jh).eq.1)) then						!
                            tempd=10																!
                         elseif ((state(ih,jv).eq.-1).or.(state(ih,jh).eq.-1)) then					!
                            tempd=11																!
                         else
                            write(6,*) 'empty diagonal or horizontal subunit??'
                            stop
                         endif																		!
                      elseif ((state(i+2,j+1).ne.0).and.(state(i+2,j).ne.0)) then					!
                         if (dissocstate(ih,jv).eq.5) then											!
                            tempd=12																!
                         elseif (dissocstate(ih,jv).eq.6) then										!
                            tempd=13																!
                         endif																		!
                      endif																			!
                   else
c                      write(6,*) 'marker1020'														!
                      write(6,*) 'bad dissocstate',dissocstate(ih,jv),'for',ih,jv					!
                      stop																			!
                   endif
                else																				!Diagonal is not founder
                   if (dissocstate(ih,jv).lt.5) then
c                      write(6,*) 'diagonal stays less than 5'
                   elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
c                      write(6,*) 'marker1021'														!
                      if ((state(ih-1,jv+1).ne.0).and.(state(ih,jv+1).ne.0).and.
     @                   (state(ih+1,jv).ne.0).and.(state(ih+1,jv-1).ne.0)) then
                         tempd=8
                      elseif ((state(i,j+2).ne.0).and.(state(i+1,j+2).ne.0)) then					!
                         if ((state(ih,jv).eq.1).and.(state(ih,jh).eq.1)) then						!
                            tempd=10																!
                         elseif ((state(ih,jv).eq.-1).or.(state(ih,jh).eq.-1)) then					!
                            tempd=11																!
                         else
                            write(6,*) 'empty diagonal or horizontal subunit??'
                            stop
                         endif																		!
                      elseif ((state(i+2,j+1).ne.0).and.(state(i+2,j).ne.0)) then					!
                         if (dissocstate(ih,jv).eq.5) then											!
                            tempd=12																!
                         elseif (dissocstate(ih,jv).eq.6) then										!
                            tempd=13																!
                         endif																		!
                      endif																			!
                   else
c                      write(6,*) 'marker1022'														!
                      write(6,*) 'bad dissocstate',dissocstate(ih,jv),'for',ih,jv					!
                      stop																			!
                   endif
                endif
             else
                write(6,*) 'no special subunit?'
                stop
             endif
          elseif ((ih.lt.i).and.(jv.lt.j)) then														!Adding to upper right
             write(6,*) 'Adding to upper right, assume special is diagonal'
c                write(6,*) 'diagonal is special/founder'
                dep(i,j)=8
                dep(ih,jh)=7
                
                if (dissocstate(ih,jh).eq.2) then
                   write(6,*) 'bad dissocstate 2 for horizontal'
                   stop                
                elseif (dissocstate(ih,jh).eq.3) then
                   temph=5
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                elseif (dissocstate(ih,jh).eq.5) then												!
c                   write(6,*) 'marker1054'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker1055'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker1056'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker1057'															!
                   write(6,*) 'bad dissocstate',dissocstate(ih,jh),'for',ih,jh						!
                   stop																				!
                endif
                
                if (dissocstate(iv,jv).eq.2) then
                   if (state(iv,jv).eq.1) then
                      tempv=5
                   elseif (dissocstate(iv,jv).eq.-1) then
                      tempv=6
                   else
                      write(6,*) 'empty vertical subunit?'
                      stop
                   endif
                elseif ((dissocstate(iv,jv).eq.3).or.(dissocstate(iv,jv).eq.4)) then
                   write(6,*) 'bad dissocstate 3/4 for vertical'
                   stop
                elseif (dissocstate(iv,jv).eq.5) then												!
c                   write(6,*) 'marker1058'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then
c                   write(6,*) 'marker2496'
                   tempv=11
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker2497'
                   tempv=8																			!
                else
c                   write(6,*) 'marker1060'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                
                if (dissocstate(ih,jv).lt.5) then
c                      write(6,*) 'diagonal stays less than 5'
                elseif (dissocstate(ih,jv).eq.5) then
                   tempd=10
                elseif (dissocstate(ih,jv).eq.6) then
                   tempd=11
                else
                   write(6,*) 'dstate(ih,jv) out of bounds?',dissocstate(ih,jv)
                   stop
                endif
          elseif ((ih.gt.i).and.(jv.lt.j)) then														!Adding to upper left
             write(6,*) 'Adding to upper left'
             write(6,*) 'Make the diagonal one the special one here'
c                write(6,*) 'diagonal is special/founder'
                dep(i,j)=7
                if (dissocstate(ih,jh).eq.3) then
                   temph=5
                   dep(ih,jh)=8
                elseif (dissocstate(ih,jh).eq.4) then
                   temph=6
                   dep(ih,jh)=8
                elseif (dissocstate(ih,jh).eq.5) then												!
c                   write(6,*) 'marker1096'															!
                   temph=12																			!
                elseif (dissocstate(ih,jh).eq.6) then												!
c                   write(6,*) 'marker1097'															!
                   temph=13																			!
                elseif ((dissocstate(ih,jh).eq.10).or.(dissocstate(ih,jh).eq.11)) then				!
c                   write(6,*) 'marker1098'															!
                   temph=8																			!
                else
c                   write(6,*) 'marker1099'															!
                   write(6,*) 'bad dissocstate 8/12/13 for ',ih,jh									!
                   stop																				!
                endif
                if (dissocstate(iv,jv).eq.2) then
                   tempv=5																			!no hydrolysis event yet
                elseif (dissocstate(iv,jv).eq.5) then												!
c                   write(6,*) 'marker1100'															!
                   tempv=10																			!
                elseif (dissocstate(iv,jv).eq.6) then
c                   write(6,*) 'marker2499'
                   tempv=11
                elseif (dissocstate(iv,jv).ge.12) then												!
c                   write(6,*) 'marker1102'															!
                   tempv=8																			!
                else
c                   write(6,*) 'marker1103'															!
                   write(6,*) 'bad dissocstate',dissocstate(iv,jv),'for',iv,jv						!
                   stop																				!
                endif
                if (dep(ih,jv).eq.0) then															!Diagonal is founder
                   if (dissocstate(ih,jv).lt.5) then
                      if (state(ih,jv).eq.1) then
                         tempd=5
                      elseif (state(ih,jv).eq.-1) then
                         tempd=6
                      else
                         write(6,*) 'empty diagonal subunit??'
                         stop
                      endif
                   elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
c                      write(6,*) 'marker1104'														!
                      if ((state(ih-1,jv-1).ne.0).and.(state(ih,jv-1).ne.0).and.
     @                   (state(ih+1,jv).ne.0).and.(state(ih+1,jv+1).ne.0)) then
                         tempd=8
                      elseif ((state(i,j-2).ne.0).and.(state(i+1,j-2).ne.0)) then					!
                         if ((state(ih,jv).eq.1).and.(state(ih,jv-1).eq.1)) then					!
                            tempd=10																!
                         elseif ((state(ih,jv).eq.-1).or.(state(ih,jv-1).eq.-1)) then				!
                            tempd=11																!
                         else
                            write(6,*) 'empty diagonal subunit or subunit below??'
                            stop
                         endif																		!
                      elseif ((state(i+2,j).ne.0).and.(state(i+2,j-1).ne.0)) then					!
                         if (dissocstate(ih,jv).eq.5) then											!
                            tempd=12																!
                         elseif (dissocstate(ih,jv).eq.6) then										!
                            tempd=13																!
                         endif																		!
                      endif																			!
                   else
c                      write(6,*) 'marker1105'														!
                      write(6,*) 'bad dissocstate',dissocstate(ih,jv),'for',ih,jv					!
                      stop																			!
                   endif
                else																				!Diagonal is not founder
                   if (dissocstate(ih,jv).lt.5) then
c                      write(6,*) 'diagonal stays less than 5'
                   elseif ((dissocstate(ih,jv).eq.5).or.(dissocstate(ih,jv).eq.6)) then
c                      write(6,*) 'marker1106'														!
                      if ((state(ih-1,jv-1).ne.0).and.(state(ih,jv-1).ne.0).and.
     @                   (state(ih+1,jv).ne.0).and.(state(ih+1,jv+1).ne.0)) then
                         tempd=8
                      elseif ((state(i,j-2).ne.0).and.(state(i+1,j-2).ne.0)) then					!
                         if ((state(ih,jv).eq.1).and.(state(ih,jv-1).eq.1)) then					!
                            tempd=10																!
                         elseif ((state(ih,jv).eq.-1).or.(state(ih,jv-1).eq.-1)) then				!
                            tempd=11																!
                         else
                            write(6,*) 'empty diagonal subunit or subunit below??'
                            stop
                         endif																		!
                      elseif ((state(i+2,j).ne.0).and.(state(i+2,j-1).ne.0)) then					!
                         if (dissocstate(ih,jv).eq.5) then											!
                            tempd=12																!
                         elseif (dissocstate(ih,jv).eq.6) then										!
                            tempd=13																!
                         endif																		!
                      endif																			!
                   else
c                      write(6,*) 'marker1107'														!
                      write(6,*) 'bad dissocstate',dissocstate(ih,jv),'for',ih,jv					!
                      stop																			!
                   endif
                endif
          endif
          
       return
       end
C
C
C +++++
C
C
      subroutine SubLefSurround (i,j,dep,dissocstate,state,temph1,temph2,temph3,tempv1,tempv2,times,
     @                         event,revmap,ev,totev,nev,nrecyc,recyc,index,temp,k_on,conc,
     @                         GDP,K_lat,K_long,K_both,K_hyd,K_thr_long,K_thr_lat,K_all,seammult,k_ne)

c i/o variables      
      integer i,j
      integer dep(13,*),dissocstate(13,*),state(13,*)
      integer temph1,temph2,temph3,tempv1,tempv2
      integer event(*),revmap(*),ev(13,2000,*)
      integer totev,nev(13,*),nrecyc,recyc(*),index,temp
      double precision times(*)
      double precision k_on,conc,conc_di,GDP,K_lat,K_long,K_both,K_hyd
      double precision K_thr_long,K_thr_lat,K_all,k_ne
      double precision seammult(13,*)
      
c local variables
      integer ir,jr,it,jt,ib,jb

c variable initializations...      
         ir=i+1
         jr=j
         it=i
         jt=j+1
         ib=i
         jb=j-1
         
         tempv1=dissocstate(it,jt)
         temph1=dissocstate(ir,jt)
         temph2=dissocstate(ir,jr)
         temph3=dissocstate(ir,jb)
         tempv2=dissocstate(ib,jb)
         
c         write(6,*) 'Starting SubLefSurround'

c Special subunit should always be bottom/bottom right unless special case...
         if (((dep(ib,jb).eq.7).or.(dep(ib,jb).eq.8)).or.((dep(ir,jb).eq.7).or.(dep(ir,jb).eq.8))) then
c            write(6,*) 'special subunit should always be bottom/bottom right unless special case'
            
c            write(6,*) 'only deps that should change are ',it,jt,', ',ir,jt,'and ',ir,jr
            if ((state(it,jt+1).ne.0).and.(state(it+1,jt+1).ne.0)) then								!added conditions for dependencies
c               write(6,*) 'dep for ',it,jt,'goes to 6'
               dep(it,jt)=6
            elseif ((state(it-1,jt).ne.0).and.(state(it-1,jt+1).ne.0).and.
     @             (state(it,jt+1).ne.0)) then
c               write(6,*) 'dep for ',it,jt,'goes to 5'
               dep(it,jt)=5
            else
c               write(6,*) 'dep for ',it,jt,'goes to 4'
               dep(it,jt)=4
            endif
            if (dep(ir,jt).eq.8) then
               if ((state(ir+1,jt).ne.0).and.(state(ir+1,jt-1).ne.0)) then
c                  write(6,*) 'make a dep switch for ',ir,jt
c                  write(6,*) 'dep 8 -> 7'
                  dep(ir,jt)=7
               else
c                  write(6,*) 'no dep switch, go to dep=2 for ',ir,jt
                  dep(ir,jt)=2
               endif
            elseif (dep(ir,jt).eq.7) then
c               write(6,*) 'dep for ',ir,jt,'is 7, no change'
            else
               write(6,*) 'bad dep for ',ir,jt,':',dep(ir,jt)
               stop
            endif
            
            if (dep(ir,jr).eq.8) then
               if ((state(ir+1,jr).ne.0).and.(state(ir+1,jr-1).ne.0)) then
c                  write(6,*) 'make a dep switch for ',ir,jr
c                  write(6,*) 'dep 8 -> 7'
                  dep(ir,jr)=7
               else
c                  write(6,*) 'no dep switch, go to dep=2 for ',ir,jr
                  dep(ir,jr)=2
               endif
            elseif (dep(ir,jr).eq.7) then
c               write(6,*) 'dep for ',ir,jr,'is 7, no change'
            else
               write(6,*) 'bad dep for ',ir,jr,': ',dep(ir,jr)
               stop
            endif

            if (dissocstate(it,jt).eq.8) then														!top subunit
               if (state(it,jt).eq.1) then
c                  write(6,*) 'dstate 8 -> 12 for ',it,jt
                  tempv1=12
               elseif (state(it,jt).eq.-1) then
c                 write(6,*) 'dstate 8 -> 13 for ',it,jt
                  tempv1=13
               else
                  write(6,*) 'empty top subunit??'
                  stop
               endif
            elseif (dissocstate(it,jt).eq.11) then
               if (state(it,jt).eq.1) then
c                  write(6,*) 'dstate 11 -> 5 for ',it,jt
                  tempv1=5
               elseif (state(it,jt).eq.-1) then
c                  write(6,*) 'dstate 11 -> 6 for ',it,jt
                  tempv1=6
               else
                  write(6,*) 'empty top subunit??'
                  stop
               endif
            elseif (dissocstate(it,jt).eq.10) then
c               write(6,*) 'dstate 10 -> 5 for ',it,jt
               tempv1=5
            elseif ((dissocstate(it,jt).eq.5).or.(dissocstate(it,jt).eq.6)) then
c               write(6,*) 'dstate 5/6 -> 2 for ',it,jt
               tempv1=2
            else
               write(6,*) 'bad dissocstate',dissocstate(it,jt),'for',it,jt
               stop
            endif
            
            if (dissocstate(ir,jt).eq.8) then														!top right subunit
               if (ir.eq.13) then																	!add conditions for seam column
c                  write(6,*) 'looking at seam column ',ir
                  if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0).and.
     @               (state(1,jt).ne.0).and.(state(1,jt-1).ne.0).and.
     @               (state(1,jt-2).ne.0)) then
c                     write(6,*) 'dissocstate stays 8 for ',ir,jt
                  elseif (state(ir-1,jt+1).eq.0) then
                     if ((state(ir,jt).eq.1).and.(state(ir,jr).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',ir,jt
                        temph1=10
                     elseif ((state(ir,jt).eq.-1).or.(state(ir,jr).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',ir,jt
                        temph1=11
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',ir,jt,'or ',ir,jr,'?'
                        stop
                     endif
                  elseif (state(1,jt).eq.0) then
                     if (state(ir,jr).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',ir,jt
                        temph1=5
                     elseif (state(ir,jr).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',ir,jt
                        temph1=6
                     else
                        write(6,*) 'empty subunit: ',ir,jr,'?'
                        stop
                     endif
                  elseif (state(1,jt-2).eq.0) then
                     if (state(ir,jr).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',ir,jt
                        temph1=3
                     elseif (state(ir,jr).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',ir,jt
                        temph1=4
                     else
                        write(6,*) 'empty subunit: ',ir,jt,'?'
                        stop
                     endif
                  endif
               else
                  if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0).and.
     @               (state(ir+1,jt+1).ne.0).and.(state(ir+1,jt).ne.0).and.
     @               (state(ir+1,jt-1).ne.0)) then
c                     write(6,*) 'dissocstate stays 8 for ',ir,jt
                  elseif (state(ir-1,jt+1).eq.0) then
                     if ((state(ir,jt).eq.1).and.(state(ir,jr).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',ir,jt
                        temph1=10
                     elseif ((state(ir,jt).eq.-1).or.(state(ir,jr).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',ir,jt
                        temph1=11
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',ir,jt,'or ',ir,jr,'?'
                        stop
                     endif
                  elseif (state(ir+1,jt+1).eq.0) then
                     if (state(ir,jr).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',ir,jt
                        temph1=5
                     elseif (state(ir,jr).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',ir,jt
                        temph1=6
                     else
                        write(6,*) 'empty subunit: ',ir,jr,'?'
                        stop
                     endif
                  elseif (state(ir+1,jt-1).eq.0) then
                     if (state(ir,jr).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',ir,jt
                        temph1=3
                     elseif (state(ir,jr).eq.-1) then
c                       write(6,*) 'dstate 8 -> 4 for ',ir,jt
                        temph1=4
                     else
                        write(6,*) 'empty subunit: ',ir,jt,'?'
                        stop
                     endif
                  endif
               endif
            elseif (dissocstate(ir,jt).eq.13) then
c               write(6,*) 'dstate 13 -> 6 for ',ir,jt
               temph1=6
            elseif (dissocstate(ir,jt).eq.12) then
c               write(6,*) 'dstate 12 -> 5 for ',ir,jt
               temph1=5
            elseif (dissocstate(ir,jt).eq.11) then
               if (state(ir,jr).eq.1) then
c                  write(6,*) 'dstate 11 -> 3 for ',ir,jt
                  temph1=3
               elseif (state(ir,jr).eq.-1) then
c                  write(6,*) 'dstate 11 -> 4 for ',ir,jt
                  temph1=4
               else
                  write(6,*) 'empty subunit: ',ir,jr
                  stop
               endif
            elseif (dissocstate(ir,jt).eq.6) then
c               write(6,*) 'dstate 6 -> 4 for ',ir,jt
               temph1=4
            elseif ((dissocstate(ir,jt).eq.5).or.(dissocstate(ir,jt).eq.10)) then
c               write(6,*) 'dstate 5/10 -> 3 for ',ir,jt
               temph1=3
            else
               write(6,*) 'bad dissocstate',dissocstate(ir,jt),'for',ir,jt
               stop
            endif
            if (dissocstate(ir,jr).eq.8) then														!right subunit
               if (ir.eq.13) then																	!add conditions for seam column
c                  write(6,*) 'looking at seam column ',ir
                  if ((state(1,jr).ne.0).and.(state(1,jr-1).ne.0).and.
     @               (state(1,jr-2).ne.0)) then
                     if ((state(ir,jr).eq.1).and.(state(ir,jb).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',ir,jr
                        temph2=10
                     elseif ((state(ir,jr).eq.-1).or.(state(ir,jb).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',ir,jr
                        temph2=11
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',ir,jr,'or ',ir,jb,'?'
                        stop
                     endif
                  elseif (state(1,jr).eq.0) then
                     if (state(ir,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',ir,jr
                       temph2=5
                     elseif (state(ir,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',ir,jr
                        temph2=6
                     else
                        write(6,*) 'empty subunit: ',ir,jb,'?'
                        stop
                     endif
                  elseif (state(1,jr-2).eq.0) then
                     if (state(ir,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',ir,jr
                        temph2=3
                     elseif (state(ir,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',ir,jr
                        temph2=4
                     else
                        write(6,*) 'empty subunit: ',ir,jb,'?'
                        stop
                     endif
                  endif
               else
                  if ((state(ir+1,jr+1).ne.0).and.(state(ir+1,jr).ne.0).and.
     @               (state(ir+1,jr-1).ne.0)) then
                     if ((state(ir,jr).eq.1).and.(state(ir,jb).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',ir,jr
                        temph2=10
                     elseif ((state(ir,jr).eq.-1).or.(state(ir,jb).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',ir,jr
                        temph2=11
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',ir,jr,'or ',ir,jb,'?'
                        stop
                     endif
                  elseif (state(ir+1,jr+1).eq.0) then
                     if (state(ir,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',ir,jr
                       temph2=5
                     elseif (state(ir,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',ir,jr
                        temph2=6
                     else
                        write(6,*) 'empty subunit: ',ir,jb,'?'
                        stop
                     endif
                  elseif (state(ir+1,jr-1).eq.0) then
                     if (state(ir,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',ir,jr
                        temph2=3
                     elseif (state(ir,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',ir,jr
                        temph2=4
                     else
                        write(6,*) 'empty subunit: ',ir,jb,'?'
                        stop
                     endif
                  endif
               endif
            elseif (dissocstate(ir,jr).eq.11) then
               if (state(ir,jb).eq.1) then
c                  write(6,*) 'dstate 11 -> 3 for ',ir,jr
                  temph2=3
               elseif (state(ir,jb).eq.-1) then
c                  write(6,*) 'dstate 11 -> 4 for ',ir,jr
                  temph2=4
               else
                  write(6,*) 'empty subunit: ',ir,jb,'?'
                  stop
               endif
            elseif (dissocstate(ir,jr).eq.10) then
c               write(6,*) 'dstate 10 -> 3 for ',ir,jr
               temph2=3
            else
               write(6,*) 'bad dissocstate',dissocstate(ir,jr),'for',ir,jr
               stop
            endif
            if (dissocstate(ir,jb).eq.8) then														!bottom right subunit
               if (ir.eq.13) then																	!add conditions for seam column
c                  write(6,*) 'looking at seam column ',ir
                  if (state(1,jb).ne.0) then
c                     write(6,*) 'dstate should stay 8 for ',ir,jb
                  else
                     if (state(ir,jb-1).eq.1) then
c                        write(6,*) 'dstate 8 -> 12 for ',ir,jb
                        temph3=12
                     elseif (state(ir,jb-1).eq.-1) then
c                        write(6,*) 'dstate 8 -> 13 for ',ir,jb
                        temph3=13
                     else
                        write(6,*) 'bad state for ',ir,jb-1,'?'
                        stop
                     endif
                  endif
               else
                  if (state(ir+1,jb+1).ne.0) then
c                     write(6,*) 'dstate should stay 8 for ',ir,jb
                  else
                     if (state(ir,jb-1).eq.1) then
c                        write(6,*) 'dstate 8 -> 12 for ',ir,jb
                        temph3=12
                     elseif (state(ir,jb-1).eq.-1) then
c                        write(6,*) 'dstate 8 -> 13 for ',ir,jb
                        temph3=13
                     else
                        write(6,*) 'bad state for ',ir,jb-1,'?'
                        stop
                     endif
                  endif
               endif
            elseif (dissocstate(ir,jb).eq.11) then
               if (state(ir,jb-1).eq.1) then
c                  write(6,*) 'dstate 11 -> 5 for ',ir,jb
                  temph3=5
               elseif (state(ir,jb-1).eq.-1) then
c                  write(6,*) 'dstate 11 -> 6 for ',ir,jb
                  temph3=6
               else
                  write(6,*) 'empty subunit: ',ir,jb-1,'?'
                  stop
               endif
            elseif (dissocstate(ir,jb).eq.10) then
c               write(6,*) 'dstate 10 -> 5 for ',ir,jb
               temph3=5
            elseif ((dissocstate(ir,jb).eq.5).or.(dissocstate(ir,jb).eq.6)) then
c               write(6,*) 'dstate 5/6, very special circumstance for ',ib,jb
               if (ir.eq.13) then																	!add conditions for seam column
c                  write(6,*) 'looking at seam column ',ir
                  if ((dep(ir,jb).ne.7).or.(dep(ir,jb).ne.8)) then
                     if (dep(ir,jb).eq.3) then
                        if ((state(1,jb-1).eq.0).and.(state(1,jb-1).eq.0).and.(state(ir,jb-1).eq.0)) then
                           temph3=2
                        else
                           write(6,*) 'bad states around for dep of ',ir,jb,': ',dep(ir,jb)
                           stop
                        endif
                     else
                        write(6,*) 'bad dep for ',ir,jb,': ',dep(ir,jb),'?'
                        stop
                     endif
                  else
                     if (dep(ir,jb).eq.7) then
c                        write(6,*) 'dep has to be 7'
                        if (((state(1,jb).eq.0).and.(state(ir-1,jb-1).eq.0)).and.((state(1,jb-1).ne.0)
     @                     .and.(state(1,jb-2).ne.0).and.(state(ir,jb-1).ne.0))) then
c                           write(6,*) 'if dstate 5/6, then stays 5/6 for ',ir,jb
                        else
                           write(6,*) 'bad dstate 5/6 for ',ir,jb
                           stop
                        endif
                     else
                        write(6,*) 'bad dep for ',ir,jb,': ',dep(ir,jb)
                        stop
                     endif
                  endif
               else
                  if ((dep(ir,jb).ne.7).or.(dep(ir,jb).ne.8)) then
                     if (dep(ir,jb).eq.3) then
                        if ((state(ir+1,jb).eq.0).and.(state(ir+1,jb-1).eq.0).and.(state(ir,jb-1).eq.0)) then
                           temph3=2
                        else
                           write(6,*) 'bad states around for dep of ',ir,jb,': ',dep(ir,jb)
                           stop
                        endif
                     else
                        write(6,*) 'bad dep for ',ir,jb,': ',dep(ir,jb),'?'
                        stop
                     endif
                  else
                     if (dep(ir,jb).eq.7) then
c                        write(6,*) 'dep has to be 7'
                        if (((state(ir+1,jb+1).eq.0).and.(state(ir-1,jb-1).eq.0)).and.((state(ir+1,jb).ne.0)
     @                     .and.(state(ir+1,jb-1).ne.0).and.(state(ir,jb-1).ne.0))) then
c                           write(6,*) 'if dstate 5/6, then stays 5/6 for ',ir,jb
                        else
                           write(6,*) 'bad dstate 5/6 for ',ir,jb
                           stop
                        endif
                     else
                        write(6,*) 'bad dep for ',ir,jb,': ',dep(ir,jb)
                        stop
                     endif
                  endif
               endif
            else
               write(6,*) 'bad dissocstate ',dissocstate(ir,jb),'for ',ir,jb
               stop
            endif
            if (dissocstate(ib,jb).eq.8) then														!bottom subunit
               if (state(ib,jb-1).eq.1) then
c                  write(6,*) 'dstate 8 -> 12 for ',ib,jb
                  tempv2=12
               elseif (state(ib,jb-1).eq.-1) then
c                  write(6,*) 'dstate 8 -> 13 for ',ib,jb
                  tempv2=13
               else
                  write(6,*) 'empty subunit: ',ib,jb-1,'?'
                  stop
               endif
            elseif (dissocstate(ib,jb).eq.11) then
               if (state(ib,jb-1).eq.1) then
c                  write(6,*) 'dstate 11 -> 5 for ',ib,jb
                  tempv2=5
               elseif (state(ib,jb-1).eq.-1) then
c                  write(6,*) 'dstate 11 -> 6 for ',ib,jb
                  tempv2=6
               else
                  write(6,*) 'empty subunit: ',ib,jb-1,'?'
                  stop
               endif
            elseif (dissocstate(ib,jb).eq.10) then
c               write(6,*) 'dstate 10 -> 5 for ',ib,jb
               tempv2=5
            elseif ((dissocstate(ib,jb).eq.5).or.(dissocstate(ib,jb).eq.6)) then
c               write(6,*) 'dstate 5/6, very special circumstance for ',ib,jb
               if ((dep(ib,jb).ne.7).or.(dep(ib,jb).ne.8)) then
                  if (dep(ib,jb).eq.4) then
                     if ((state(ib-1,jb).eq.0).and.(state(ib-1,jb-1).eq.0).and.(state(ib,jb-1).eq.0)) then
                        tempv2=2
                     else
                        write(6,*) 'bad states around for dep of ',ib,jb,': ',dep(ib,jb)
                        stop
                     endif
                  else
                     write(6,*) 'bad dep for ',ib,jb,': ',dep(ib,jb),'?'
                     stop
                  endif
               else
                  if (dep(ib,jb).eq.8) then
c                     write(6,*) 'dep has to be 8'
                     if (((state(ib-1,jb+1).eq.0).and.(state(ib+2,jb-1).eq.0)).and.((state(ib-1,jb).ne.0)
     @                  .and.(state(ib-1,jb-1).ne.0).and.(state(ib,jb-1).ne.0))) then
c                        write(6,*) 'if dstate 5/6, then stays 5/6 for ',ib,jb
                     else
                        write(6,*) 'bad dstate 5/6 for ',ib,jb
                        stop
                     endif
                  else
                     write(6,*) 'bad dep for ',ib,jb,': ',dep(ib,jb)
                     stop
                  endif
               endif
            else
               write(6,*) 'bad dissocstate',dissocstate(ib,jb),'for',ib,jb
               stop
            endif
c Added case where bottom subunits are in template.         
         elseif ((dep(ib,jb).eq.0).and.(dep(ir,jb).eq.0)) then
c            write(6,*) 'bottom/bottom right subunits are in template'
c            write(6,*) 'dont change'
            if (dissocstate(it,jt).eq.8) then														!top subunit
               if (state(it,jt).eq.1) then
c                  write(6,*) 'dstate 8 -> 12 for ',it,jt
                  tempv1=12
               elseif (state(it,jt).eq.-1) then
c                  write(6,*) 'dstate 8 -> 13 for ',it,jt
                  tempv1=13
               else
                  write(6,*) 'empty top subunit??'
                  stop
               endif
            elseif (dissocstate(it,jt).eq.11) then
               if (state(it,jt).eq.1) then
c                  write(6,*) 'dstate 11 -> 5 for ',it,jt
                  tempv1=5
               elseif (state(it,jt).eq.-1) then
c                  write(6,*) 'dstate 11 -> 6 for ',it,jt
                  tempv1=6
               else
                  write(6,*) 'empty top subunit??'
                  stop
               endif
            elseif (dissocstate(it,jt).eq.10) then
c               write(6,*) 'dstate 10 -> 5 for ',it,jt
               tempv1=5
            elseif ((dissocstate(it,jt).eq.5).or.(dissocstate(it,jt).eq.6)) then
c               write(6,*) 'dstate 5/6 -> 2 for ',it,jt
               tempv1=2
            else
               write(6,*) 'bad dissocstate',dissocstate(it,jt),'for',it,jt
               stop
            endif
            
            if (dissocstate(ir,jt).eq.8) then														!top right subunit
               if (ir.eq.13) then																	!add conditions for seam column
c                  write(6,*) 'looking at seam column ',ir
                  if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0).and.
     @               (state(1,jt).ne.0).and.(state(1,jt-1).ne.0).and.
     @               (state(1,jt-2).ne.0)) then
c                     write(6,*) 'dissocstate stays 8 for ',ir,jt
                  elseif (state(ir-1,jt+1).eq.0) then
                     if ((state(ir,jt).eq.1).and.(state(ir,jr).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',ir,jt
                        temph1=10
                     elseif ((state(ir,jt).eq.-1).or.(state(ir,jr).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',ir,jt
                        temph1=11
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',ir,jt,'or ',ir,jr,'?'
                        stop
                     endif
                  elseif (state(1,jt).eq.0) then
                     if (state(ir,jr).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',ir,jt
                        temph1=5
                     elseif (state(ir,jr).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',ir,jt
                        temph1=6
                     else
                        write(6,*) 'empty subunit: ',ir,jr,'?'
                        stop
                     endif
                  elseif (state(1,jt-2).eq.0) then
                     if (state(ir,jr).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',ir,jt
                        temph1=3
                     elseif (state(ir,jr).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',ir,jt
                        temph1=4
                     else
                        write(6,*) 'empty subunit: ',ir,jt,'?'
                        stop
                     endif
                  endif
               else
                  if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0).and.
     @               (state(ir+1,jt+1).ne.0).and.(state(ir+1,jt).ne.0).and.
     @               (state(ir+1,jt-1).ne.0)) then
c                     write(6,*) 'dissocstate stays 8 for ',ir,jt
                  elseif (state(ir-1,jt+1).eq.0) then
                     if ((state(ir,jt).eq.1).and.(state(ir,jr).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',ir,jt
                        temph1=10
                     elseif ((state(ir,jt).eq.-1).or.(state(ir,jr).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',ir,jt
                        temph1=11
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',ir,jt,'or ',ir,jr,'?'
                        stop
                     endif
                  elseif (state(ir+1,jt+1).eq.0) then
                     if (state(ir,jr).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',ir,jt
                        temph1=5
                     elseif (state(ir,jr).eq.-1) then
c                       write(6,*) 'dstate 8 -> 6 for ',ir,jt
                        temph1=6
                     else
                        write(6,*) 'empty subunit: ',ir,jr,'?'
                        stop
                     endif
                  elseif (state(ir+1,jt-1).eq.0) then
                     if (state(ir,jr).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',ir,jt
                        temph1=3
                     elseif (state(ir,jr).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',ir,jt
                        temph1=4
                     else
                        write(6,*) 'empty subunit: ',ir,jt,'?'
                        stop
                     endif
                  endif
               endif
            elseif (dissocstate(ir,jt).eq.13) then
c               write(6,*) 'dstate 13 -> 6 for ',ir,jt
               temph1=6
            elseif (dissocstate(ir,jt).eq.12) then
c               write(6,*) 'dstate 12 -> 5 for ',ir,jt
               temph1=5
            elseif (dissocstate(ir,jt).eq.11) then
               if (state(ir,jr).eq.1) then
c                  write(6,*) 'dstate 11 -> 3 for ',ir,jt
                  temph1=3
               elseif (state(ir,jr).eq.-1) then
c                  write(6,*) 'dstate 11 -> 4 for ',ir,jt
                  temph1=4
               else
                  write(6,*) 'empty subunit: ',ir,jr
                  stop
               endif
            elseif (dissocstate(ir,jt).eq.6) then
c               write(6,*) 'dstate 6 -> 4 for ',ir,jt
               temph1=4
            elseif ((dissocstate(ir,jt).eq.5).or.(dissocstate(ir,jt).eq.10)) then
c               write(6,*) 'dstate 5/10 -> 3 for ',ir,jt
               temph1=3
            else
               write(6,*) 'bad dissocstate',dissocstate(ir,jt),'for',ir,jt
               stop
            endif
            if (dissocstate(ir,jr).eq.8) then														!right subunit
               if (ir.eq.13) then																	!add conditions for seam column
c                  write(6,*) 'looking at seam column ',ir
                  if ((state(1,jr).ne.0).and.(state(1,jr-1).ne.0).and.
     @               (state(1,jr-2).ne.0)) then
                     if ((state(ir,jr).eq.1).and.(state(ir,jb).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',ir,jr
                        temph2=10
                     elseif ((state(ir,jr).eq.-1).or.(state(ir,jb).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',ir,jr
                        temph2=11
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',ir,jr,'or ',ir,jb,'?'
                        stop
                     endif
                  elseif (state(1,jr).eq.0) then
                     if (state(ir,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',ir,jr
                       temph2=5
                     elseif (state(ir,jb).eq.-1) then
c                       write(6,*) 'dstate 8 -> 6 for ',ir,jr
                        temph2=6
                     else
                        write(6,*) 'empty subunit: ',ir,jb,'?'
                        stop
                     endif
                  elseif (state(1,jr-2).eq.0) then
                     if (state(ir,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',ir,jr
                        temph2=3
                     elseif (state(ir,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',ir,jr
                        temph2=4
                     else
                        write(6,*) 'empty subunit: ',ir,jb,'?'
                        stop
                     endif
                  endif
               else
                  if ((state(ir+1,jr+1).ne.0).and.(state(ir+1,jr).ne.0).and.
     @               (state(ir+1,jr-1).ne.0)) then
                     if ((state(ir,jr).eq.1).and.(state(ir,jb).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',ir,jr
                        temph2=10
                     elseif ((state(ir,jr).eq.-1).or.(state(ir,jb).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',ir,jr
                        temph2=11
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',ir,jr,'or ',ir,jb,'?'
                        stop
                     endif
                  elseif (state(ir+1,jr+1).eq.0) then
                     if (state(ir,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',ir,jr
                       temph2=5
                     elseif (state(ir,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',ir,jr
                        temph2=6
                     else
                        write(6,*) 'empty subunit: ',ir,jb,'?'
                        stop
                     endif
                  elseif (state(ir+1,jr-1).eq.0) then
                     if (state(ir,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',ir,jr
                        temph2=3
                     elseif (state(ir,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',ir,jr
                        temph2=4
                     else
                        write(6,*) 'empty subunit: ',ir,jb,'?'
                        stop
                     endif
                  endif
               endif
            elseif (dissocstate(ir,jr).eq.11) then
               if (state(ir,jb).eq.1) then
c                  write(6,*) 'dstate 11 -> 3 for ',ir,jr
                  temph2=3
               elseif (state(ir,jb).eq.-1) then
c                  write(6,*) 'dstate 11 -> 4 for ',ir,jr
                  temph2=4
               else
                  write(6,*) 'empty subunit: ',ir,jb,'?'
                  stop
               endif
            elseif (dissocstate(ir,jr).eq.10) then
c               write(6,*) 'dstate 10 -> 3 for ',ir,jr
               temph2=3
            else
               write(6,*) 'bad dissocstate',dissocstate(ir,jr),'for',ir,jr
               stop
            endif
         else
            write(6,*) 'bad dep/special case?'
            stop
         endif

c Update...         
         if (tempv1.ne.dissocstate(it,jt)) then
            dissocstate(it,jt)=tempv1
c            write(6,*) 'resetting dissocstate of',it,jt,'to',dissocstate(it,jt)
            if (dissocstate(it,jt).eq.2) then
c               write(6,*) 'dstate now 2 for ',it,jt
c               write(6,*) 'before update'
c               write(6,*) 'times: ',times(ev(it,jt,2))
            endif
            times(ev(it,jt,2))=get_evtime(dissocstate(it,jt),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(it,jt))
            call update(event,revmap,ev(it,jt,2),times(ev(it,jt,2)),times,totev)
            if (dissocstate(it,jt).eq.2) then
c               write(6,*) 'dstate now 2 for ',it,jt
c               write(6,*) 'after update'
c               write(6,*) 'times: ',times(ev(it,jt,2))
            endif
         endif
         if (temph1.ne.dissocstate(ir,jt)) then
            dissocstate(ir,jt)=temph1
c            write(6,*) 'resetting dissocstate of',ir,jt,'to',dissocstate(ir,jt)
            times(ev(ir,jt,2))=get_evtime(dissocstate(ir,jt),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(ir,jt))
c Need to add test for double GDP if dstate=11.
            if (temph1.eq.11) then
               if ((state(ir,jt).eq.-1).and.(state(ir,jt-1).eq.-1)) then
c                  write(6,*) 'double GDP, recalculate times'
                  times(ev(ir,jt,2))=times(ev(ir,jt,2))*GDP
               else
c                  write(6,*) 'single GDP, do nothing'
               endif
            endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
            call update(event,revmap,ev(ir,jt,2),times(ev(ir,jt,2)),times,totev)
         endif
         if (temph2.ne.dissocstate(ir,jr)) then
            dissocstate(ir,jr)=temph2
c            write(6,*) 'resetting dissocstate of',ir,jr,'to',dissocstate(ir,jr)
            times(ev(ir,jr,2))=get_evtime(dissocstate(ir,jr),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(ir,jr))
c Need to add test for double GDP if dstate=11.
            if (temph2.eq.11) then
               if ((state(ir,jr).eq.-1).and.(state(ir,jr-1).eq.-1)) then
c                  write(6,*) 'double GDP, recalculate times'
                  times(ev(ir,jr,2))=times(ev(ir,jr,2))*GDP
               else
c                  write(6,*) 'single GDP, do nothing'
               endif
            endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
            call update(event,revmap,ev(ir,jr,2),times(ev(ir,jr,2)),times,totev)
         endif
         if (temph3.ne.dissocstate(ir,jb)) then
            dissocstate(ir,jb)=temph3
c            write(6,*) 'resetting dissocstate of',ir,jb,'to',dissocstate(ir,jb)
            times(ev(ir,jb,2))=get_evtime(dissocstate(ir,jb),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(ir,jb))
c Need to add test for double GDP if dstate=11.
            if (temph3.eq.11) then
               if ((state(ir,jb).eq.-1).and.(state(ir,jb-1).eq.-1)) then
c                  write(6,*) 'double GDP, recalculate times'
                  times(ev(ir,jb,2))=times(ev(ir,jb,2))*GDP
               else
c                  write(6,*) 'single GDP, do nothing'
               endif
            endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
            call update(event,revmap,ev(ir,jb,2),times(ev(ir,jb,2)),times,totev)
         endif
         if (tempv2.ne.dissocstate(ib,jb)) then
            dissocstate(ib,jb)=tempv2
c            write(6,*) 'resetting dissocstate of',ib,jb,'to',dissocstate(ib,jb)
            times(ev(ib,jb,2))=get_evtime(dissocstate(ib,jb),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(ib,jb))
            call update(event,revmap,ev(ib,jb,2),times(ev(ib,jb,2)),times,totev)
         endif
         
      return
      end
      
      
      
      subroutine SubRigSurround (i,j,dep,dissocstate,state,temph1,temph2,temph3,tempv1,tempv2,times,
     @                         event,revmap,ev,totev,nev,nrecyc,recyc,index,temp,k_on,conc,
     @                         GDP,K_lat,K_long,K_both,K_hyd,K_thr_long,K_thr_lat,K_all,seammult,k_ne)
      
c i/o variables      
      integer i,j
      integer dep(13,*),dissocstate(13,*),state(13,*)
      integer temph1,temph2,temph3,tempv1,tempv2
      integer event(*),revmap(*),ev(13,2000,*)
      integer totev,nev(13,*),nrecyc,recyc(*),index,temp
      double precision times(*)
      double precision k_on,conc,conc_di,GDP,K_lat,K_long,K_both,K_hyd
      double precision K_thr_long,K_thr_lat,K_all,k_ne
      double precision seammult(13,*)
      
c local variables
      integer il,jl,it,jt,ib,jb
      
         il=i-1
         jl=j
         it=i
         jt=j+1
         ib=i
         jb=j-1
         
         tempv1=dissocstate(it,jt)
         temph1=dissocstate(il,jt)
         temph2=dissocstate(il,jl)
         temph3=dissocstate(il,jb)
         tempv2=dissocstate(ib,jb)
         
c Special subunit should always be bottom/bottom left unless special case...
         if (((dep(ib,jb).eq.7).or.(dep(ib,jb).eq.8)).or.((dep(il,jb).eq.7).or.(dep(il,jb).eq.8))) then
c            write(6,*) 'special subunit should always be bottom/bottom left unless special case'
            
c            write(6,*) 'only deps that should change are ',it,jt,'and ',il,jt
            if ((state(it-1,jt+1).ne.0).and.(state(it,jt+1).ne.0)) then								!added conditions for dependencies
c               write(6,*) 'dep for ',it,jt,'goes to 5'
               dep(it,jt)=5
            elseif ((state(it,jt+1).ne.0).and.(state(it+1,jt+1).ne.0).and.
     @             (state(it+1,jt).ne.0)) then
c               write(6,*) 'dep for ',it,jt,'goes to 6'
               dep(it,jt)=6
            else
c               write(6,*) 'dep for ',it,jt,'goes to 3'
               dep(it,jt)=3
            endif
            if (dep(il,jt).eq.7) then
               if ((state(il-1,jt).ne.0).and.(state(il-1,jt-1).ne.0)) then
c                  write(6,*) 'make a dep switch for ',il,jt
c                  write(6,*) 'dep 7 -> 8'
                  dep(il,jt)=8
               else
c                  write(6,*) 'no dep switch, go to dep=2 for ',il,jt
                  dep(il,jt)=2
               endif
            elseif (dep(il,jt).eq.8) then
c               write(6,*) 'dep for ',il,jt,'is 8, no change'
            else
               write(6,*) 'bad dep for ',il,jt,':',dep(il,jt)
               stop
            endif
            
c Added dep change for il,jl coordinate.            
            if (dep(il,jl).eq.7) then
               if ((state(il-1,jl).ne.0).and.(state(il-1,jl-1).ne.0)) then
c                  write(6,*) 'make a dep switch for ',il,jl
c                  write(6,*) 'dep 7 -> 8'
                  dep(il,jl)=8
               else
c                  write(6,*) 'no dep switch, go to dep=2 for ',il,jl
                  dep(il,jl)=2
               endif
            elseif (dep(il,jl).eq.8) then
c               write(6,*) 'dep for ',il,jl,'is 8, no change'
            else
               write(6,*) 'bad dep for ',il,jl,': ',dep(il,jl)
               stop
            endif

            if (dissocstate(it,jt).eq.8) then														!top subunit
               if (state(it,jt).eq.1) then
c                  write(6,*) 'dstate 8 -> 12 for ',it,jt
                  tempv1=12
               elseif (state(it,jt).eq.-1) then
c                  write(6,*) 'dstate 3 -> 13 for ',it,jt
                  tempv1=13
               else
                  write(6,*) 'empty subunit: ',it,jt,'?'
                  stop
               endif
            elseif (dissocstate(it,jt).eq.11) then
               if (state(it,jt).eq.1) then
c                  write(6,*) 'dstate 11 -> 5 for ',it,jt
                  tempv1=5
               elseif (state(it,jt).eq.-1) then
c                  write(6,*) 'dstate 11 -> 6 for ',it,jt
                  tempv1=6
               else
                  write(6,*) 'empty subunit: ',it,jt,'?'
                  stop
               endif
            elseif (dissocstate(it,jt).eq.10) then
c               write(6,*) 'dstate 10 -> 5 for ',it,jt
               tempv1=5
            elseif ((dissocstate(it,jt).eq.5).or.(dissocstate(it,jt).eq.6)) then
c               write(6,*) 'dstate 5/6 -> 2 for ',it,jt
               tempv1=2
            else
               write(6,*) 'bad dissocstate',dissocstate(it,jt),'for',it,jt
               stop
            endif
            if (dissocstate(il,jt).eq.8) then														!top left subunit
               if (il.eq.1) then																	!need to add conditions if in seam column
c                  write(6,*) 'we are looking at seam column ',il
                  if ((state(13,jt+1).ne.0).and.(state(13,jt+2).ne.0).and.							
     @               (state(13,jt+3).ne.0).and.(state(il,jt+1).ne.0).and.
     @               (state(il+1,jt+1).ne.0)) then
c                     write(6,*) 'dissocstate stays 8 for ',il,jt
                  elseif (state(il+1,jt+1).eq.0) then
                     if ((state(il,jt).eq.1).and.(state(il,jl).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',il,jt
                        temph1=10
                     elseif ((state(il,jt).eq.-1).or.(state(il,jl).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',il,jt
                        temph1=11
c                        write(6,*) 'need to check for double GDP'
                     else
c                        write(6,*) 'empty subunit: ',il,jl,'or ',il,jt,'?'
                        stop
                     endif
                  elseif (state(13,jt+3).eq.0) then
                     if (state(il,jl).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',il,jt
                        temph1=5
                     elseif (state(il,jl).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',il,jt
                        temph1=6
                     else
                        write(6,*) 'empty subunit: ',il,jl,'?'
                        stop
                     endif
                  elseif (state(13,jt+1).eq.0) then
                     if (state(il,jl).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',il,jt
                        temph1=3
                     elseif (state(il,jl).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',il,jt
                        temph1=4
                     else
                        write(6,*) 'empty subunit: ',il,jl
                        stop
                     endif
                  endif
               else
                  if ((state(il-1,jt-1).ne.0).and.(state(il-1,jt).ne.0).and.
     @               (state(il-1,jt+1).ne.0).and.(state(il,jt+1).ne.0).and.
     @               (state(il+1,jt+1).ne.0)) then
c                     write(6,*) 'dissocstate stays 8 for ',il,jt
                  elseif (state(il+1,jt+1).eq.0) then
                     if ((state(il,jt).eq.1).and.(state(il,jl).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',il,jt
                        temph1=10
                     elseif ((state(il,jt).eq.-1).or.(state(il,jl).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',il,jt
                        temph1=11
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',il,jl,'or ',il,jt,'?'
                        stop
                     endif
                  elseif (state(il-1,jt+1).eq.0) then
                     if (state(il,jl).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',il,jt
                        temph1=5
                     elseif (state(il,jl).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',il,jt
                        temph1=6
                     else
                        write(6,*) 'empty subunit: ',il,jl,'?'
                        stop
                     endif
                  elseif (state(il-1,jt-1).eq.0) then
                     if (state(il,jl).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',il,jt
                        temph1=3
                     elseif (state(il,jl).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',il,jt
                        temph1=4
                     else
                        write(6,*) 'empty subunit: ',il,jl
                        stop
                     endif
                  endif
               endif
            elseif (dissocstate(il,jt).eq.13) then
c               write(6,*) 'dstate 13 -> 6 for ',il,jt
               temph1=6
            elseif (dissocstate(il,jt).eq.12) then
c               write(6,*) 'dstate 12 -> 5 for ',il,jt
               temph1=5
            elseif (dissocstate(il,jt).eq.11) then
               if (state(il,jl).eq.1) then
c                  write(6,*) 'dstate 11 -> 3 for ',il,jt
                  temph1=3
               elseif (state(il,jl).eq.-1) then
c                  write(6,*) 'dstate 11 -> 4 for ',il,jt
                  temph1=4
               else
                  write(6,*) 'empty subunit: ',il,jl,'?'
                  stop
               endif
            elseif (dissocstate(il,jt).eq.6) then
c               write(6,*) 'dstate 6 -> 4 for ',il,jt
               temph1=4
            elseif ((dissocstate(il,jt).eq.5).or.(dissocstate(il,jt).eq.10)) then
c               write(6,*) 'dstate 5/10 -> 3 for ',il,jt
               temph1=3
            else
               write(6,*) 'bad dissocstate',dissocstate(il,jt),'for',il,jt
               stop
            endif
            if (dissocstate(il,jl).eq.8) then														!left subunit
               if (il.eq.1) then																	!add conditions for seam column
c                  write(6,*) 'we are looking at seam column: ',il
                  if ((state(13,jl+1).ne.0).and.(state(13,jl+2).ne.0).and.
     @               (state(13,jl+3).ne.0)) then
                     if ((state(il,jl).eq.1).and.(state(il,jb).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',il,jl
                        temph2=10
                     elseif ((state(il,jl).eq.-1).or.(state(il,jb).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',il,jl
                        temph2=11
c                        write(6,*) 'need to check for double GDP'
                     else
c                        write(6,*) 'empty subunit: ',il,jl,'or ',il,jb,'?'
                        stop
                     endif
                  elseif (state(13,jl+3).eq.0) then
                     if (state(il,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',il,jl
                        temph2=5
                     elseif (state(il,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',il,jl
                        temph2=6
                     else
                        write(6,*) 'empty subunit: ',il,jb,'?'
                        stop
                     endif
                  elseif (state(13,jl+1).eq.0) then
                     if (state(il,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',il,jl
                        temph2=3
                     elseif (state(il,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',il,jl
                        temph2=4
                     else
                        write(6,*) 'empty subunit: ',il,jb,'?'
                        stop
                     endif
                  endif
               else
                  if ((state(il-1,jl-1).ne.0).and.(state(il-1,jl).ne.0).and.
     @               (state(il-1,jl+1).ne.0)) then
                     if ((state(il,jl).eq.1).and.(state(il,jb).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',il,jl
                        temph2=10
                     elseif ((state(il,jl).eq.-1).or.(state(il,jb).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',il,jl
                        temph2=11
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',il,jl,'or ',il,jb,'?'
                        stop
                     endif
                  elseif (state(il-1,jl+1).eq.0) then
                     if (state(il,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',il,jl
                        temph2=5
                     elseif (state(il,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',il,jl
                        temph2=6
                     else
                        write(6,*) 'empty subunit: ',il,jb,'?'
                        stop
                     endif
                  elseif (state(il-1,jl-1).eq.0) then
                     if (state(il,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',il,jl
                        temph2=3
                     elseif (state(il,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',il,jl
                        temph2=4
                     else
                        write(6,*) 'empty subunit: ',il,jb,'?'
                        stop
                     endif
                  endif
               endif
            elseif (dissocstate(il,jl).eq.11) then
               if (state(il,jb).eq.1) then
c                  write(6,*) 'dstate 11 -> 3 for ',il,jl
                  temph2=3
               elseif (state(il,jb).eq.-1) then
c                  write(6,*) 'dstate 11 -> 4 for ',il,jl
                  temph2=4
               else
                  write(6,*) 'empty subunit: ',il,jb,'?'
                  stop
               endif
            elseif (dissocstate(il,jl).eq.10) then
c               write(6,*) 'dstate 10 -> 3 for ',il,jl
               temph2=3
            else
               write(6,*) 'bad dissocstate',dissocstate(il,jl),'for',il,jl
               stop
            endif
            if (dissocstate(il,jb).eq.8) then														!bottom left subunit
               if (il.eq.1) then																	!add conditions for seam column
c                  write(6,*) 'we are looking at seam column ',il
                  if (state(13,jb+3).ne.0) then
c                     write(6,*) 'dissocstate stays 8 for ',il,jb
                  else
                     if (state(il,jb-1).eq.1) then
c                        write(6,*) 'dstate 8 -> 12 for ',il,jb
                        temph3=12
                     elseif (state(il,jb-1).eq.-1) then
c                        write(6,*) 'dstate 8 -> 13 for ',il,jb
                        temph3=13
                     else
                        write(6,*) 'empty subunit: ',il,jb-1,'?'
                        stop
                     endif
                  endif
               else
                  if (state(il-1,jb+1).ne.0) then
c                     write(6,*) 'dissocstate stays 8 for ',il,jb
                  else
                     if (state(il,jb-1).eq.1) then
c                        write(6,*) 'dstate 8 -> 12 for ',il,jb
                        temph3=12
                     elseif (state(il,jb-1).eq.-1) then
c                        write(6,*) 'dstate 8 -> 13 for ',il,jb
                        temph3=13
                     else
                        write(6,*) 'empty subunit: ',il,jb-1,'?'
                        stop
                     endif
                  endif
               endif
            elseif (dissocstate(il,jb).eq.11) then
               if (state(il,jb-1).eq.1) then
c                  write(6,*) 'dstate 11 -> 5 for ',il,jb
                  temph3=5
               elseif (state(il,jb-1).eq.-1) then
c                  write(6,*) 'dstate 11 -> 6 for ',il,jb
                  temph3=6
               else
                  write(6,*) 'empty subunit: ',il,jb-1,'?'
                  stop
               endif
            elseif (dissocstate(il,jb).eq.10) then
c               write(6,*) 'dstate 10 -> 5 for ',il,jb
               temph3=5
            elseif ((dissocstate(il,jb).eq.5).or.(dissocstate(il,jb).eq.6)) then
c               write(6,*) 'dstate 5/6, very special circumstance for ',il,jb
               if (il.eq.1) then																	!add conditions for seam column
c                  write(6,*) 'we are looking at seam column ',il
                  if ((dep(il,jb).ne.7).or.(dep(il,jb).ne.8)) then
                     if (dep(il,jb).eq.4) then
                        if ((state(13,jb+1).eq.0).and.(state(13,jb+2).eq.0).and.(state(il,jb-1).eq.0)) then
                           temph3=2
                        else
                           write(6,*) 'bad states around for dep of ',il,jb,': ',dep(il,jb)
                           stop
                        endif
                     else
                        write(6,*) 'bad dep for ',il,jb,': ',dep(il,jb)
                        stop
                     endif
                  else
                     if (dep(il,jb).eq.8) then
c                        write(6,*) 'dep has to be 8'
                        if (((state(13,jb+3).eq.0).and.(state(il+1,jb-1).eq.0)).and.((state(13,jb+1).ne.0)
     @                     .and.(state(13,jb+2).ne.0).and.(state(il,jb-1).ne.0))) then
c                           write(6,*) 'if dstate 5/6, then stays 5/6 for ',il,jb
                        else
                           write(6,*) 'bad dstate 5/6 for ',il,jb,'?'
                           stop
                        endif
                     else
                        write(6,*) 'bad dep for ',il,jb,': ',dep(il,jb),'?'
                        stop
                     endif
                  endif
               else
                  if ((dep(il,jb).ne.7).or.(dep(il,jb).ne.8)) then
                     if (dep(il,jb).eq.4) then
                        if ((state(il-1,jb).eq.0).and.(state(il-1,jb-1).eq.0).and.(state(il,jb-1).eq.0)) then
                           temph3=2
                        else
                           write(6,*) 'bad states around for dep of ',il,jb,': ',dep(il,jb)
                           stop
                        endif
                     else
                        write(6,*) 'bad dep for ',il,jb,': ',dep(il,jb)
                        stop
                     endif
                  else
                     if (dep(il,jb).eq.8) then
c                        write(6,*) 'dep has to be 8'
                        if (((state(il-1,jb+1).eq.0).and.(state(il+1,jb-1).eq.0)).and.((state(il-1,jb).ne.0)
     @                     .and.(state(il-1,jb-1).ne.0).and.(state(il,jb-1).ne.0))) then
c                           write(6,*) 'if dstate 5/6, then stays 5/6 for ',il,jb
                        else
                           write(6,*) 'bad dstate 5/6 for ',il,jb,'?'
                           stop
                        endif
                     else
                        write(6,*) 'bad dep for ',il,jb,': ',dep(il,jb),'?'
                        stop
                     endif
                  endif
               endif
            else
               write(6,*) 'bad dissocstate ',dissocstate(il,jb),'for ',il,jb
               stop
            endif
            if (dissocstate(ib,jb).eq.8) then														!bottom subunit
               if (state(ib,jb-1).eq.1) then
c                  write(6,*) 'dstate 8 -> 12 for ',ib,jb
                  tempv2=12
               elseif (state(ib,jb-1).eq.-1) then
c                  write(6,*) 'dstate 8 -> 13 for ',ib,jb
                  tempv2=13
               else
                  write(6,*) 'empty subunit: ',ib,jb-1,'?'
                  stop
               endif
            elseif (dissocstate(ib,jb).eq.11) then
               if (state(ib,jb-1).eq.1) then
c                  write(6,*) 'dstate 11 -> 5 for ',ib,jb
                  tempv2=5
               elseif (state(ib,jb-1).eq.-1) then
c                  write(6,*) 'dstate 11 -> 6 for ',ib,jb
                  tempv2=6
               else
                  write(6,*) 'empty subunit: ',ib,jb-1,'?'
                  stop
               endif
            elseif (dissocstate(ib,jb).eq.10) then
c               write(6,*) 'dstate 10 -> 5 for ',ib,jb
               tempv2=5
            elseif ((dissocstate(ib,jb).eq.5).or.(dissocstate(ib,jb).eq.6)) then
c               write(6,*) 'dstate 5/6, very special circumstance for ',ib,jb
               if ((dep(ib,jb).ne.7).or.(dep(ib,jb).ne.8)) then
                  if (dep(ib,jb).eq.3) then
                     if ((state(ib+1,jb).eq.0).and.(state(ib+1,jb-1).eq.0).and.(state(ib,jb-1).eq.0)) then
                        tempv2=2
                     else
                        write(6,*) 'bad states around for dep of ',ib,jb,': ',dep(ib,jb)
                        stop
                     endif
                  else
                     write(6,*) 'bad dep for ',ib,jb,': ',dep(ib,jb),'?'
                     stop
                  endif
               else
                  if (dep(ib,jb).eq.7) then
c                     write(6,*) 'dep has to be 7'
                     if (((state(ib+1,jb+1).eq.0).and.(state(ib-1,jb-1).eq.0)).and.((state(ib+1,jb).ne.0)
     @                  .and.(state(ib+1,jb-1).ne.0).and.(state(ib,jb-1).ne.0))) then
c                        write(6,*) 'if dstate 5/6, then stays 5/6 for ',ib,jb
                     else
                        write(6,*) 'bad dstate 5/6 for ',ib,jb
                        stop
                     endif
                  else
                     write(6,*) 'bad dep for ',ib,jb,': ',dep(ib,jb)
                     stop
                  endif
               endif
            else
               write(6,*) 'bad dissocstate',dissocstate(ib,jb),'for',ib,jb
               stop
            endif
c Added special case for if bottom subunits are in template.            
         elseif ((dep(ib,jb).eq.0).and.(dep(il,jb).eq.0)) then
c            write(6,*) 'bottom/bottom left are in template'
c            write(6,*) 'dont change'
            if (dissocstate(it,jt).eq.8) then														!top subunit
               if (state(it,jt).eq.1) then
c                  write(6,*) 'dstate 8 -> 12 for ',it,jt
                  tempv1=12
               elseif (state(it,jt).eq.-1) then
c                  write(6,*) 'dstate 3 -> 13 for ',it,jt
                  tempv1=13
               else
                  write(6,*) 'empty subunit: ',it,jt,'?'
                  stop
               endif
            elseif (dissocstate(it,jt).eq.11) then
               if (state(it,jt).eq.1) then
c                  write(6,*) 'dstate 11 -> 5 for ',it,jt
                  tempv1=5
               elseif (state(it,jt).eq.-1) then
c                  write(6,*) 'dstate 11 -> 6 for ',it,jt
                  tempv1=6
               else
                  write(6,*) 'empty subunit: ',it,jt,'?'
                  stop
               endif
            elseif (dissocstate(it,jt).eq.10) then
c               write(6,*) 'dstate 10 -> 5 for ',it,jt
               tempv1=5
            elseif ((dissocstate(it,jt).eq.5).or.(dissocstate(it,jt).eq.6)) then
c               write(6,*) 'dstate 5/6 -> 2 for ',it,jt
               tempv1=2
            else
               write(6,*) 'bad dissocstate',dissocstate(it,jt),'for',it,jt
               stop
            endif
            if (dissocstate(il,jt).eq.8) then														!top left subunit
               if (il.eq.1) then																	!need to add conditions if in seam column
c                  write(6,*) 'we are looking at seam column ',il
                  if ((state(13,jt+1).ne.0).and.(state(13,jt+2).ne.0).and.							
     @               (state(13,jt+3).ne.0).and.(state(il,jt+1).ne.0).and.
     @               (state(il+1,jt+1).ne.0)) then
c                     write(6,*) 'dissocstate stays 8 for ',il,jt
                  elseif (state(il+1,jt+1).eq.0) then
                     if ((state(il,jt).eq.1).and.(state(il,jl).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',il,jt
                        temph1=10
                     elseif ((state(il,jt).eq.-1).or.(state(il,jl).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',il,jt
                        temph1=11
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',il,jl,'or ',il,jt,'?'
                        stop
                     endif
                  elseif (state(13,jt+3).eq.0) then
                     if (state(il,jl).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',il,jt
                        temph1=5
                     elseif (state(il,jl).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',il,jt
                        temph1=6
                     else
                        write(6,*) 'empty subunit: ',il,jl,'?'
                        stop
                     endif
                  elseif (state(13,jt+1).eq.0) then
                     if (state(il,jl).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',il,jt
                        temph1=3
                     elseif (state(il,jl).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',il,jt
                        temph1=4
                     else
                        write(6,*) 'empty subunit: ',il,jl
                        stop
                     endif
                  endif
               else
                  if ((state(il-1,jt-1).ne.0).and.(state(il-1,jt).ne.0).and.
     @               (state(il-1,jt+1).ne.0).and.(state(il,jt+1).ne.0).and.
     @               (state(il+1,jt+1).ne.0)) then
c                     write(6,*) 'dissocstate stays 8 for ',il,jt
                  elseif (state(il+1,jt+1).eq.0) then
                     if ((state(il,jt).eq.1).and.(state(il,jl).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',il,jt
                        temph1=10
                     elseif ((state(il,jt).eq.-1).or.(state(il,jl).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',il,jt
                        temph1=11
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',il,jl,'or ',il,jt,'?'
                        stop
                     endif
                  elseif (state(il-1,jt+1).eq.0) then
                     if (state(il,jl).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',il,jt
                        temph1=5
                     elseif (state(il,jl).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',il,jt
                        temph1=6
                     else
                        write(6,*) 'empty subunit: ',il,jl,'?'
                        stop
                     endif
                  elseif (state(il-1,jt-1).eq.0) then
                     if (state(il,jl).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',il,jt
                        temph1=3
                     elseif (state(il,jl).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',il,jt
                        temph1=4
                     else
                        write(6,*) 'empty subunit: ',il,jl
                        stop
                     endif
                  endif
               endif
            elseif (dissocstate(il,jt).eq.13) then
c               write(6,*) 'dstate 13 -> 6 for ',il,jt
               temph1=6
            elseif (dissocstate(il,jt).eq.12) then
c               write(6,*) 'dstate 12 -> 5 for ',il,jt
               temph1=5
            elseif (dissocstate(il,jt).eq.11) then
               if (state(il,jl).eq.1) then
c                  write(6,*) 'dstate 11 -> 3 for ',il,jt
                  temph1=3
               elseif (state(il,jl).eq.-1) then
c                  write(6,*) 'dstate 11 -> 4 for ',il,jt
                  temph1=4
               else
                  write(6,*) 'empty subunit: ',il,jl,'?'
                  stop
               endif
            elseif (dissocstate(il,jt).eq.6) then
c               write(6,*) 'dstate 6 -> 4 for ',il,jt
               temph1=4
            elseif ((dissocstate(il,jt).eq.5).or.(dissocstate(il,jt).eq.10)) then
c               write(6,*) 'dstate 5/10 -> 3 for ',il,jt
               temph1=3
            else
               write(6,*) 'bad dissocstate',dissocstate(il,jt),'for',il,jt
               stop
            endif
            if (dissocstate(il,jl).eq.8) then														!left subunit
               if (il.eq.1) then																	!add conditions for seam column
c                  write(6,*) 'we are looking at seam column: ',il
                  if ((state(13,jl+1).ne.0).and.(state(13,jl+2).ne.0).and.
     @               (state(13,jl+3).ne.0)) then
                     if ((state(il,jl).eq.1).and.(state(il,jb).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',il,jl
                        temph2=10
                     elseif ((state(il,jl).eq.-1).or.(state(il,jb).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',il,jl
                        temph2=11
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',il,jl,'or ',il,jb,'?'
                        stop
                     endif
                  elseif (state(13,jl+3).eq.0) then
                     if (state(il,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',il,jl
                        temph2=5
                     elseif (state(il,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',il,jl
                        temph2=6
                     else
                        write(6,*) 'empty subunit: ',il,jb,'?'
                        stop
                     endif
                  elseif (state(13,jl+1).eq.0) then
                     if (state(il,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',il,jl
                        temph2=3
                     elseif (state(il,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',il,jl
                        temph2=4
                     else
                        write(6,*) 'empty subunit: ',il,jb,'?'
                        stop
                     endif
                  endif
               else
                  if ((state(il-1,jl-1).ne.0).and.(state(il-1,jl).ne.0).and.
     @               (state(il-1,jl+1).ne.0)) then
                     if ((state(il,jl).eq.1).and.(state(il,jb).eq.1)) then
c                        write(6,*) 'dstate 8 -> 10 for ',il,jl
                        temph2=10
                     elseif ((state(il,jl).eq.-1).or.(state(il,jb).eq.-1)) then
c                        write(6,*) 'dstate 8 -> 11 for ',il,jl
                        temph2=11
c                        write(6,*) 'need to check for double GDP'
                     else
                        write(6,*) 'empty subunit: ',il,jl,'or ',il,jb,'?'
                        stop
                     endif
                  elseif (state(il-1,jl+1).eq.0) then
                     if (state(il,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 5 for ',il,jl
                        temph2=5
                     elseif (state(il,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 6 for ',il,jl
                        temph2=6
                     else
                        write(6,*) 'empty subunit: ',il,jb,'?'
                        stop
                     endif
                  elseif (state(il-1,jl-1).eq.0) then
                     if (state(il,jb).eq.1) then
c                        write(6,*) 'dstate 8 -> 3 for ',il,jl
                        temph2=3
                     elseif (state(il,jb).eq.-1) then
c                        write(6,*) 'dstate 8 -> 4 for ',il,jl
                        temph2=4
                     else
                        write(6,*) 'empty subunit: ',il,jb,'?'
                        stop
                     endif
                  endif
               endif
            elseif (dissocstate(il,jl).eq.11) then
               if (state(il,jb).eq.1) then
c                  write(6,*) 'dstate 11 -> 3 for ',il,jl
                  temph2=3
               elseif (state(il,jb).eq.-1) then
c                  write(6,*) 'dstate 11 -> 4 for ',il,jl
                  temph2=4
               else
                  write(6,*) 'empty subunit: ',il,jb,'?'
                  stop
               endif
            elseif (dissocstate(il,jl).eq.10) then
c               write(6,*) 'dstate 10 -> 3 for ',il,jl
               temph2=3
            else
               write(6,*) 'bad dissocstate',dissocstate(il,jl),'for',il,jl
               stop
            endif
         else
            write(6,*) 'bad dep/special case?'
            stop
         endif
c Update...
         if (tempv1.ne.dissocstate(it,jt)) then
            dissocstate(it,jt)=tempv1
c            write(6,*) 'resetting dissocstate of',it,jt,'to',dissocstate(it,jt)
            if (dissocstate(it,jt).eq.2) then
c               write(6,*) 'dstate now 2 for ',it,jt
c               write(6,*) 'before update'
c               write(6,*) 'times: ',times(ev(it,jt,2))
            endif
            times(ev(it,jt,2))=get_evtime(dissocstate(it,jt),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(it,jt))
            call update(event,revmap,ev(it,jt,2),times(ev(it,jt,2)),times,totev)
            if (dissocstate(it,jt).eq.2) then
c               write(6,*) 'dstate now 2 for ',it,jt
c               write(6,*) 'after update'
c               write(6,*) 'times: ',times(ev(it,jt,2))
            endif
         endif
         if (temph1.ne.dissocstate(il,jt)) then
            dissocstate(il,jt)=temph1
c            write(6,*) 'resetting dissocstate of',il,jt,'to',dissocstate(il,jt)
            times(ev(il,jt,2))=get_evtime(dissocstate(il,jt),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(il,jt))
c Need to add test for double GDP if dstate=11.
            if (temph1.eq.11) then
               if ((state(il,jt).eq.-1).and.(state(il,jt-1).eq.-1)) then
c                  write(6,*) 'double GDP, recalculate times'
                  times(ev(il,jt,2))=times(ev(il,jt,2))*GDP
               else
c                  write(6,*) 'single GDP, do nothing'
               endif
            endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
            call update(event,revmap,ev(il,jt,2),times(ev(il,jt,2)),times,totev)
         endif
         if (temph2.ne.dissocstate(il,jl)) then
            dissocstate(il,jl)=temph2
c            write(6,*) 'resetting dissocstate of',il,jl,'to',dissocstate(il,jl)
            times(ev(il,jl,2))=get_evtime(dissocstate(il,jl),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(il,jl))
c Need to add test for double GDP if dstate=11.
            if (temph2.eq.11) then
               if ((state(il,jl).eq.-1).and.(state(il,jl-1).eq.-1)) then
c                  write(6,*) 'double GDP, recalculate times'
                  times(ev(il,jl,2))=times(ev(il,jl,2))*GDP
               else
c                  write(6,*) 'single GDP, do nothing'
               endif
            endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
            call update(event,revmap,ev(il,jl,2),times(ev(il,jl,2)),times,totev)
         endif
         if (temph3.ne.dissocstate(il,jb)) then
            dissocstate(il,jb)=temph3
c            write(6,*) 'resetting dissocstate of',il,jb,'to',dissocstate(il,jb)
            times(ev(il,jb,2))=get_evtime(dissocstate(il,jb),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(il,jb))
c Need to add test for double GDP if dstate=11.
            if (temph3.eq.11) then
               if ((state(il,jb).eq.-1).and.(state(il,jb-1).eq.-1)) then
c                  write(6,*) 'double GDP, recalculate times'
                  times(ev(il,jb,2))=times(ev(il,jb,2))*GDP
               else
c                  write(6,*) 'single GDP, do nothing'
               endif
            endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
            call update(event,revmap,ev(il,jb,2),times(ev(il,jb,2)),times,totev)
         endif
         if (tempv2.ne.dissocstate(ib,jb)) then
            dissocstate(ib,jb)=tempv2
c            write(6,*) 'resetting dissocstate of',ib,jb,'to',dissocstate(ib,jb)
            times(ev(ib,jb,2))=get_evtime(dissocstate(ib,jb),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(ib,jb))
            call update(event,revmap,ev(ib,jb,2),times(ev(ib,jb,2)),times,totev)
         endif
      
      return
      end
      
      
      
      subroutine SubTopSurround (i,j,dep,dissocstate,state,temph1,temph2,tempv1,tempv2,tempv3,times,
     @                         event,revmap,ev,totev,nev,nrecyc,recyc,index,temp,k_on,conc,
     @                         GDP,K_lat,K_long,K_both,K_hyd,K_thr_long,K_thr_lat,K_all,seammult,k_ne)

      implicit none
      
c i/o variables      
      integer i,j
      integer dep(13,*),dissocstate(13,*),state(13,*)
      integer temph1,temph2,tempv1,tempv2,tempv3
      integer event(*),revmap(*),ev(13,2000,*)
      integer totev,nev(13,*),nrecyc,recyc(*),index,temp
      double precision times(*)
      double precision k_on,conc,conc_di,GDP,K_lat,K_long,K_both,K_hyd
      double precision K_thr_long,K_thr_lat,K_all,k_ne
      double precision seammult(13,*)
      
c local variables
      integer il,jl,ir,jr,ib,jb
      double precision get_evtime
         il=i-1
         jl=j
         ir=i+1
         jr=j
         ib=i
         jb=j-1
         
         temph1=dissocstate(il,jl)
         tempv1=dissocstate(il,jb)
         tempv2=dissocstate(ib,jb)
         tempv3=dissocstate(ir,jb)
         temph2=dissocstate(ir,jr)

c            write(6,*) 'bottom subunit is special'													!bottom subunit special
c change deps
            if (dissocstate(il,jl).lt.8) then
               dep(il,jl)=2
            else
               dep(il,jl)=8
            endif
            if (dissocstate(ir,jr).lt.8) then
               dep(ir,jr)=2
            else
               dep(ir,jr)=7
            endif
c change dissocstates
            if (dissocstate(il,jl).eq.8) then														!left subunit
c               write(6,*) 'marker2256'
               if ((state(il,jl).eq.1).and.(state(il,jb).eq.1)) then
                  temph1=10
               elseif ((state(il,jl).eq.-1).or.(state(il,jb).eq.-1)) then
                  temph1=11
               else
                  write(6,*) 'empty bottom left or left subunit??'
                  stop
               endif
            elseif (dissocstate(il,jl).eq.13) then
c               write(6,*) 'marker2257'
               temph1=6
            elseif (dissocstate(il,jl).eq.12) then
c               write(6,*) 'marker2258'
               temph1=5
            elseif (dissocstate(il,jl).eq.6) then
c               write(6,*) 'marker2259'
               temph1=4
            elseif (dissocstate(il,jl).eq.5) then
c               write(6,*) 'marker2260'
               temph1=3
            else
c               write(6,*) 'marker2261'
               write(6,*) 'bad dissocstate',dissocstate(il,jl),'for',il,jl
               stop
            endif
            
            if (j.gt.103) then
            if (dissocstate(il,jb).eq.8) then														!bottom left subunit
c               write(6,*) 'marker2262'

                  if (dissocstate(il,jl).gt.6) then !we stay an 8 if the old upper left was not a 5/6
                     tempv1=8
                  else
                     if (state(il,jb-1).eq.1) then
                        tempv1=12
                     elseif (state(il,jb-1).eq.-1) then
                        tempv1=13
                     else
                        write(6,*) 'empty subunit below bottom left??'
                        stop
                     endif
                  endif
            elseif ((dissocstate(il,jb).eq.5).or.(dissocstate(il,jb).eq.6).or.
     @             (dissocstate(il,jb).ge.12)) then
c               write(6,*) 'marker2263'
               tempv1=2
            elseif (dissocstate(il,jb).eq.11) then
c               write(6,*) 'marker2264'
               if (state(il,jb-1).eq.1) then
                  tempv1=5
               elseif (state(il,jb-1).eq.-1) then
                  tempv1=6
               else
                  write(6,*) 'empty subunit below bottom left??'
                  stop
               endif
            elseif (dissocstate(il,jb).eq.10) then
c               write(6,*) 'marker2265'
               tempv1=5
            else
c               write(6,*) 'marker2266'
               write(6,*) 'bad dissocstate',dissocstate(il,jb),'for',il,jb
               stop
            endif
            if (dissocstate(ib,jb).eq.8) then														!bottom subunit
c               write(6,*) 'marker2267'
               if ((state(ib-1,jb-1).ne.0).and.(state(ib,jb-1).ne.0).and.
     @            (state(ib+1,jb-1).ne.0)) then
                  if (state(ib,jb-1).eq.1) then
                     tempv2=12
                  elseif (state(ib,jb-1).eq.-1) then
                     tempv2=13
                  else
                     write(6,*) 'empty subunit below bottom??'
                     stop
                  endif
               elseif ((state(ib-1,jb-1).eq.0).or.(state(ib+1,jb-1).eq.0)) then
                  if (state(ib,jb-1).eq.1) then
                     tempv2=5
                  elseif (state(ib,jb-1).eq.-1) then
                     tempv2=6
                  else
                     write(6,*) 'empty subunit below bottom??'
                     stop
                  endif
               endif
            elseif ((dissocstate(ib,jb).eq.12).or.(dissocstate(ib,jb).eq.13)) then
               if (dep(ib,jb).eq.0) then
c                  write(6,*) 'remove event for founder'
c                  write(6,*) 'marker2268'
                  tempv2=2
               else
c                  write(6,*) 'marker2269'
                  write(6,*) 'bad dissocstate',dissocstate(ib,jb),'for',ib,jb
                  stop
               endif
            elseif ((dissocstate(ib,jb).eq.5).or.(dissocstate(ib,jb).eq.6).or.
     @             (dissocstate(ib,jb).eq.10).or.(dissocstate(ib,jb).eq.11)) then
c               write(6,*) 'marker2270'
               write(6,*) 'bad dissocstate',dissocstate(ib,jb),'for',ib,jb
               stop
            endif
            if (dissocstate(ir,jb).eq.8) then														!bottom right subunit
                  if (dissocstate(ir,jr).gt.6) then !we stay an 8 if the old upper right was not a 5/6
                     tempv3=8
                  else
                     if (state(ir,jb-1).eq.1) then
                        tempv3=12
                     elseif (state(ir,jb-1).eq.-1) then
                        tempv3=13
                     else
                        write(6,*) 'empty subunit below bottom left??'
                        stop
                     endif
                  endif
            elseif ((dissocstate(ir,jb).eq.5).or.(dissocstate(ir,jb).eq.6).or.
     @             (dissocstate(ir,jb).ge.12)) then
c               write(6,*) 'marker2272'
               tempv3=2
            elseif (dissocstate(ir,jb).eq.11) then
c               write(6,*) 'marker2273'
               if (state(ir,jb-1).eq.1) then
                  tempv3=5
               elseif (state(ir,jb-1).eq.-1) then
                  tempv3=6
               else
                  write(6,*) 'empty subunit below bottom right??'
                  stop
               endif
            elseif (dissocstate(ir,jb).eq.10) then
c               write(6,*) 'marker2274'
               tempv3=5
            else
c               write(6,*) 'marker2275'
               write(6,*) 'bad dissocstate',dissocstate(ir,jb),'for',ir,jb
               stop
            endif
            endif
            if (dissocstate(ir,jr).eq.8) then														!right subunit
c               write(6,*) 'marker2276'
               if ((state(ir,jr).eq.1).and.(state(ir,jb).eq.1)) then
                  temph2=10
               elseif ((state(ir,jr).eq.-1).or.(state(ir,jb).eq.-1)) then
                  temph2=11
               else
                  write(6,*) 'empty bottom right subunit??'
                  stop
               endif
            elseif (dissocstate(ir,jr).eq.13) then
c               write(6,*) 'marker2277'
               temph2=6
            elseif (dissocstate(ir,jr).eq.12) then
c               write(6,*) 'marker2278'
               temph2=5
            elseif (dissocstate(ir,jr).eq.6) then
c               write(6,*) 'marker2279'
               temph2=4
            elseif (dissocstate(ir,jr).eq.5) then
c               write(6,*) 'marker2280'
               temph2=3
            else
c               write(6,*) 'marker2281'
               write(6,*) 'bad dissocstate',dissocstate(ir,jr),'for',ir,jr
               stop
            endif
c Update...
         if (temph1.ne.dissocstate(il,jl)) then
            dissocstate(il,jl)=temph1
c            write(6,*) 'resetting dissocstate of',il,jl,'to',dissocstate(il,jl)
            times(ev(il,jl,2))=get_evtime(dissocstate(il,jl),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(il,jl))
c Need to add test for double GDP if dstate=11.
            if (temph1.eq.11) then
               if ((state(il,jl).eq.-1).and.(state(il,jl-1).eq.-1)) then
c                  write(6,*) 'double GDP, recalculate times'
                  times(ev(il,jl,2))=times(ev(il,jl,2))*GDP
               else
c                  write(6,*) 'single GDP, do nothing'
               endif
            endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
            call update(event,revmap,ev(il,jl,2),times(ev(il,jl,2)),times,totev)
         endif
         if (j.gt.103) then
            if (tempv1.ne.dissocstate(il,jb)) then
               dissocstate(il,jb)=tempv1
c               write(6,*) 'resetting dissocstate of',il,jb,'to',dissocstate(il,jb)
               times(ev(il,jb,2))=get_evtime(dissocstate(il,jb),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(il,jb))
c Need to add test for double GDP if dstate=11.
               if (tempv1.eq.11) then
                  if ((state(il,jb).eq.-1).and.(state(il,jb-1).eq.-1)) then
c                     write(6,*) 'double GDP, recalculate times'
                     times(ev(il,jb,2))=times(ev(il,jb,2))*GDP
                  else
c                     write(6,*) 'single GDP, do nothing'
                  endif
               endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
               call update(event,revmap,ev(il,jb,2),times(ev(il,jb,2)),times,totev)
            endif
            if (tempv2.ne.dissocstate(ib,jb)) then
               dissocstate(ib,jb)=tempv2
c               write(6,*) 'resetting dissocstate of',ib,jb,'to',dissocstate(ib,jb)
               times(ev(ib,jb,2))=get_evtime(dissocstate(ib,jb),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(ib,jb))
               call update(event,revmap,ev(ib,jb,2),times(ev(ib,jb,2)),times,totev)
            endif
            if (tempv3.ne.dissocstate(ir,jb)) then
               dissocstate(ir,jb)=tempv3
c               write(6,*) 'resetting dissocstate of',ir,jb,'to',dissocstate(ir,jb)
               times(ev(ir,jb,2))=get_evtime(dissocstate(ir,jb),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(ir,jb))
c Need to add test for double GDP if dstate=11.
               if (tempv3.eq.11) then
                  if ((state(ir,jb).eq.-1).and.(state(ir,jb-1).eq.-1)) then
c                     write(6,*) 'double GDP, recalculate times'
                     times(ev(ir,jb,2))=times(ev(ir,jb,2))*GDP
                  else
c                     write(6,*) 'single GDP, do nothing'
                  endif
               endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
               call update(event,revmap,ev(ir,jb,2),times(ev(ir,jb,2)),times,totev)
            endif
         endif
         if (temph2.ne.dissocstate(ir,jr)) then
            dissocstate(ir,jr)=temph2
c            write(6,*) 'resetting dissocstate of',ir,jr,'to',dissocstate(ir,jr)
            times(ev(ir,jr,2))=get_evtime(dissocstate(ir,jr),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                            K_all,k_ne,seammult(ir,jr))
c Need to add test for double GDP if dstate=11.
            if (temph2.eq.11) then
               if ((state(ir,jr).eq.-1).and.(state(ir,jr-1).eq.-1)) then
c                  write(6,*) 'double GDP, recalculate times'
                  times(ev(ir,jr,2))=times(ev(ir,jr,2))*GDP
               else
c                  write(6,*) 'single GDP, do nothing'
               endif
            endif
ccccccccccccccccccccccccccccccccccccccccccccccc     
            call update(event,revmap,ev(ir,jr,2),times(ev(ir,jr,2)),times,totev)
         endif
      
      return
      end
      
      
      
      subroutine SubBotSurround (i,j,dep,dissocstate,state,temph1,temph2,tempv1,tempv2,tempv3,times,
     @                         event,revmap,ev,totev,nev,nrecyc,recyc,index,temp,k_on,conc,
     @                         GDP,K_lat,K_long,K_both,K_hyd,K_thr_long,K_thr_lat,K_all)

c i/o variables      
      integer i,j
      integer dep(13,*),dissocstate(13,*),state(13,*)
      integer temph1,temph2,tempv1,tempv2,tempv3
      integer event(*),revmap(*),ev(13,2000,*)
      integer totev,nev(13,*),nrecyc,recyc(*),index,temp
      double precision times(*)
      double precision k_on,conc,conc_di,GDP,K_lat,K_long,K_both,K_hyd
      double precision K_thr_long,K_thr_lat,K_all
      
c local variables
      integer il,jl,ir,jr,it,jt
      
         il=i-1
         jl=j
         ir=i+1
         jr=j
         it=i
         jt=j+1
         
         temph1=dissocstate(il,jl)
         tempv1=dissocstate(il,jt)
         tempv2=dissocstate(it,jt)
         tempv3=dissocstate(ir,jt)
         temph2=dissocstate(ir,jr)
         
         write(6,*) 'in SubBotSurround'
         write(6,*) 'stopping, have not implemented code for polymerization'
         stop
         
         if ((dep(il,jl).eq.0).or.(dep(il,jl).eq.2).or.(dep(il,jl).eq.3).or.(dep(il,jl).eq.8)) then
c            write(6,*) 'left subunit is special'													!left subunit special
c change deps
            dep(ir,jr)=1
            dep(ir,jt)=3
            dep(it,jt)=3
c change dissocstates
            if (dissocstate(il,jl).eq.8) then														!left subunit
c               write(6,*) 'marker2333'
               if ((state(il,jl).eq.1).and.(state(il,jl-1).eq.1)) then
                  temph1=10
               elseif ((state(il,jl).eq.-1).or.(state(il,jl-1).eq.-1)) then
                  temph1=11
               else
                  write(6,*) 'empty left subunit or subunit below??'
                  stop
               endif
            elseif (dissocstate(il,jl).eq.13) then
c               write(6,*) 'marker2334'
               temph1=6
            elseif (dissocstate(il,jl).eq.12) then
c               write(6,*) 'marker2335'
               temph1=5
            elseif ((dissocstate(il,jl).eq.5).or.(dissocstate(il,jl).eq.6)) then
c               write(6,*) 'marker2336'
               if (dep(il,jl).eq.0) then
                  if ((state(il-1,jl).ne.0).and.(state(il-1,jl-1).ne.0).and.
     @               (state(il,jl-1).ne.0)) then
                     if (state(il,jl-1).eq.1) then
                        temph1=5
                     elseif (state(il,jl-1).eq.-1) then
                        temph1=6
                     else
                        write(6,*) 'empty subunit below left??'
                        stop
                     endif
                  else
c                     write(6,*) 'remove event for founder'
                     temph1=2
                  endif
               else
c                  write(6,*) 'dissocstate stays 5/6 for left'
               endif
            elseif ((dissocstate(il,jl).eq.10).or.(dissocstate(il,jl).eq.11)) then
c               write(6,*) 'marker2337'
               write(6,*) 'bad dissocstate',dissocstate(il,jl),'for',il,jl
               stop
            endif
            if (dissocstate(il,jt).eq.8) then														!top left subunit
c               write(6,*) 'marker2338'
               if ((state(il-1,jt-1).ne.0).and.(state(il-1,jt).ne.0).and.
     @            (state(il-1,jt+1).ne.0).and.(state(il,jt+1).ne.0).and.
     @            (state(il+1,jt+1).ne.0)) then
c                  write(6,*) 'dissocstate stays 8 for top left'
               elseif (state(il-1,jt-1).eq.0) then
                  if (state(il,jl).eq.1) then
                     tempv1=3
                  elseif (state(il,jl).eq.-1) then
                     tempv1=4
                  else
                     write(6,*) 'empty left subunit??'
                     stop
                  endif
               elseif (state(il-1,jt+1).eq.0) then
                  if (state(il,jl).eq.1) then
                     tempv1=5
                  elseif (state(il,jl).eq.-1) then
                     tempv1=6
                  else
                     write(6,*) 'empty left subunit??'
                     stop
                  endif
               elseif (state(il+1,jt+1).eq.0) then
                  if ((state(il,jt).eq.1).and.(state(il,jl).eq.1)) then
                     tempv1=10
                  elseif ((state(il,jt).eq.-1).or.(state(il,jl).eq.-1)) then
                     tempv1=11
                  else
                     write(6,*) 'empty left or top left subunit??'
                     stop
                  endif
               endif
            elseif (dissocstate(il,jt).eq.13) then
c               write(6,*) 'marker2339'
               tempv1=6
            elseif (dissocstate(il,jt).eq.12) then
c               write(6,*) 'marker2340'
               tempv1=5
            elseif (dissocstate(il,jt).eq.11) then
c               write(6,*) 'marker2341'
               if (state(il,jl).eq.1) then
                  tempv1=3
               elseif (state(il,jl).eq.-1) then
                  tempv1=4
               else
                  write(6,*) 'empty left subunit??'
                  stop
               endif
            elseif (dissocstate(il,jt).eq.6) then
c               write(6,*) 'marker2342'
               tempv1=4
            elseif ((dissocstate(il,jt).eq.5).or.(dissocstate(il,jt).eq.10)) then
c               write(6,*) 'marker2343'
               tempv1=3
            else
c               write(6,*) 'marker2344'
               write(6,*) 'bad dissocstate',dissocstate(il,jt),'for',il,jt
               stop
            endif
            if (dissocstate(it,jt).eq.8) then														!top subunit
c               write(6,*) 'marker2345'
               if ((state(it-1,jt+1).ne.0).and.(state(it,jt+1).ne.0).and.
     @            (state(it+1,jt+1).ne.0)) then
                  if (state(it,jt).eq.1) then
                     tempv2=12
                  elseif (state(it,jt).eq.-1) then
                     tempv2=13
                  else
                     write(6,*) 'empty top subunit??'
                     stop
                  endif
               elseif (state(it-1,jt+1).eq.0) then
                  tempv2=2
               elseif (state(it+1,jt+1).eq.0) then
                  if (state(it,jt).eq.1) then
                     tempv2=5
                  elseif (state(it,jt).eq.-1) then
                     tempv2=6
                  else
                     write(6,*) 'empty top subunit??'
                     stop
                  endif
               endif
            elseif ((dissocstate(it,jt).eq.12).or.(dissocstate(it,jt).eq.13)) then
c               write(6,*) 'marker2346'
               tempv2=2
            else
c               write(6,*) 'marker2347'
               write(6,*) 'bad dissocstate',dissocstate(it,jt),'for',it,jt
               stop
            endif
            if (dissocstate(ir,jt).eq.8) then														!top right subunit
c               write(6,*) 'marker2348'
               if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0).and.
     @            (state(ir+1,jt+1).ne.0).and.(state(ir+1,jt).ne.0).and.
     @            (state(ir+1,jt-1).ne.0)) then
c                  write(6,*) 'dissocstate stays 8 for top right'
               elseif (state(ir-1,jt+1).eq.0) then
                  tempv3=2
               elseif (state(ir+1,jt+1).eq.0) then
                  if (state(ir,jt).eq.1) then
                     tempv3=5
                  elseif (state(ir,jt).eq.-1) then
                     tempv3=6
                  else
                     write(6,*) 'empty top right subunit??'
                     stop
                  endif
               elseif (state(ir+1,jt-1).eq.0) then
                  if (state(ir,jt).eq.1) then
                     tempv3=12
                  elseif (state(ir,jt).eq.-1) then
                     tempv3=13
                  else
                     write(6,*) 'empty top right subunit??'
                     stop
                  endif
               endif
            elseif ((dissocstate(ir,jt).eq.5).or.(dissocstate(ir,jt).eq.6).or.
     @             (dissocstate(ir,jt).ge.12)) then
c               write(6,*) 'marker2349'
               tempv3=2
            elseif (dissocstate(ir,jt).eq.11) then
c               write(6,*) 'marker2350'
               if (state(ir,jt).eq.1) then
                  tempv3=5
               elseif (state(ir,jt).eq.-1) then
                  tempv3=6
               else
                  write(6,*) 'empty top right subunit??'
                  stop
               endif
            elseif (dissocstate(ir,jt).eq.10) then
c               write(6,*) 'marker2351'
               tempv3=5
            else
c               write(6,*) 'marker2352'
               write(6,*) 'bad dissocstate',dissocstate(ir,jt),'for',ir,jt
               stop
            endif
            if (dissocstate(ir,jr).eq.8) then														!right subunit
c               write(6,*) 'marker2353'
               if ((state(ir,jr).eq.1).and.(state(ir,jr-1).eq.1)) then
                  temph2=10
               elseif ((state(ir,jr).eq.-1).or.(state(ir,jr-1).eq.-1)) then
                  temph2=11
               else
                  write(6,*) 'empty right subunit or subunit below??'
                  stop
               endif
            elseif (dissocstate(ir,jr).eq.13) then
c               write(6,*) 'marker2354'
               temph2=6
            elseif (dissocstate(ir,jr).eq.12) then
c               write(6,*) 'marker2355'
               temph2=5
            elseif (dissocstate(ir,jr).eq.6) then
c               write(6,*) 'marker2356'
               temph2=4
            elseif (dissocstate(ir,jr).eq.5) then
c               write(6,*) 'marker2357'
               temph2=3
            else
c               write(6,*) 'marker2358'
               write(6,*) 'bad dissocstate',dissocstate(ir,jr),'for',ir,jr
               stop
            endif
            !need to see if outside deps are correct...
            if ((state(ir+1,jr+1).ne.0).and.(state(ir+1,jr).ne.0)) then
               if ((dep(ir+1,jr+1).ne.3).and.(dep(ir+1,jr).ne.5)) then
                  write(6,*) 'need to change deps for subunits at',ir+1,jr+1,'and',ir+1,jr
                  write(6,*) 'deps =',dep(ir+1,jr+1),',',dep(ir+1,jr)
                  stop
               endif
            endif
         elseif ((dep(il,jt).eq.0).or.(dep(il,jt).eq.1).or.(dep(il,jt).eq.3).or.(dep(il,jt).eq.5)) then
c            write(6,*) 'top left subunit is special'												!top left subunit special
c change deps
            dep(ir,jr)=1
c change dissocstates
            if (dissocstate(il,jl).eq.8) then														!left subunit
c               write(6,*) 'marker2359'
               if ((state(il,jl).eq.1).and.(state(il,jl-1).eq.1)) then
                  temph1=10
               elseif ((state(il,jl).eq.-1).or.(state(il,jl-1).eq.-1)) then
                  temph1=11
               else
                  write(6,*) 'empty left subunit or subunit below??'
                  stop
               endif
            elseif (dissocstate(il,jl).eq.13) then
c               write(6,*) 'marker2360'
               temph1=6
            elseif (dissocstate(il,jl).eq.12) then
c               write(6,*) 'marker2361'
               temph1=5
            elseif (dissocstate(il,jl).eq.6) then
c               write(6,*) 'marker2362'
               temph1=4
            elseif (dissocstate(il,jl).eq.5) then
c               write(6,*) 'marker2363'
               temph1=3
            else
c               write(6,*) 'marker2364'
               write(6,*) 'bad dissocstate',dissocstate(il,jl),'for',il,jl
               stop
            endif
            if (dissocstate(il,jt).eq.8) then														!top left subunit
c               write(6,*) 'marker2365'
               if ((state(il-1,jt-1).ne.0).and.(state(il-1,jt).ne.0).and.
     @            (state(il-1,jt+1).ne.0).and.(state(il,jt+1).ne.0).and.
     @            (state(il+1,jt+1).ne.0)) then
c                  write(6,*) 'dissocstate stays 8 for top left'
               elseif (state(il-1,jt-1).eq.0) then
                  if (state(il,jt).eq.1) then
                     tempv1=12
                  elseif (state(il,jt).eq.-1) then
                     tempv1=13
                  else
                     write(6,*) 'empty top left subunit??'
                     stop
                  endif
               elseif (state(il-1,jt+1).eq.0) then
                  if (dep(il,jt).eq.0) then
                     if ((state(il,jt).eq.1).and.(state(il,jl).eq.1)) then
                        tempv1=5
                     elseif ((state(il,jt).eq.-1).or.(state(il,jl).eq.-1)) then
                        tempv1=6
                     else
                        write(6,*) 'empty top left or left subunit??'
                        stop
                     endif
                  elseif (dep(il,jt).eq.1) then
                     if (state(il,jt).eq.1) then
                        tempv1=5
                     elseif (state(il,jt).eq.-1) then
                        tempv1=6
                     else
                        write(6,*) 'empty top left subunit??'
                        stop
                     endif
                  elseif (dep(il,jt).eq.3) then
                     if (state(il,jl).eq.1) then
                        tempv1=5
                     elseif (state(il,jl).eq.-1) then
                        tempv1=6
                     else
                        write(6,*) 'empty left subunit??'
                        stop
                     endif
                  else
                     write(6,*) 'possible loop??'
                     stop
                  endif
               elseif (state(il+1,jt+1).eq.0) then
                  if ((state(il,jt).eq.1).and.(state(il,jl).eq.1)) then
                     tempv1=10
                  elseif ((state(il,jt).eq.-1).or.(state(il,jl).eq.-1)) then
                     tempv1=11
                  else
                     write(6,*) 'empty top left or left subunit??'
                     stop
                  endif
               endif
            elseif (dissocstate(il,jt).eq.13) then
c               write(6,*) 'marker2366'
               tempv1=6
            elseif ((dissocstate(il,jt).eq.10).or.(dissocstate(il,jt).eq.12)) then
c               write(6,*) 'marker2367'
               tempv1=5
            elseif (dissocstate(il,jt).eq.11) then
c               write(6,*) 'marker2368'
               if (state(il,jt).eq.1) then
                  tempv1=5
               elseif (state(il,jt).eq.-1) then
                  tempv1=6
               else
                  write(6,*) 'empty top left subunit??'
                  stop
               endif
            elseif ((dissocstate(il,jt).eq.5).or.(dissocstate(il,jt).eq.6)) then
c               write(6,*) 'marker2369'
               if (dep(il,jt).eq.0) then
                  if ((state(il-1,jt).ne.0).and.(state(il-1,jt+1).ne.0).and.
     @               (state(il,jt+1).ne.0)) then
                     if (state(il,jt).eq.1) then
                        tempv1=5
                     elseif (state(il,jt).eq.-1) then
                        tempv1=6
                     else
                        write(6,*) 'empty top left subunit??'
                        stop
                     endif
                  else
c                     write(6,*) 'remove event for founder'
                     tempv1=2
                  endif
               else
c                  write(6,*) 'dissocstate stays 5/6 for top left'
               endif
            endif
            if (dissocstate(it,jt).eq.8) then														!top subunit
c               write(6,*) 'marker2370'
               if ((state(it-1,jt+1).ne.0).and.(state(it,jt+1).ne.0).and.
     @            (state(it+1,jt+1).ne.0)) then
                  if (state(it,jt).eq.1) then
                     tempv2=12
                  elseif (state(it,jt).eq.-1) then
                     tempv2=13
                  else
                     write(6,*) 'empty top subunit??'
                     stop
                  endif
               elseif (state(it-1,jt+1).eq.0) then
                  tempv2=2
               elseif (state(it+1,jt+1).eq.0) then
                  if (state(it,jt).eq.1) then
                     tempv2=5
                  elseif (state(it,jt).eq.-1) then
                     tempv2=6
                  else
                     write(6,*) 'empty top subunit??'
                     stop
                  endif
               endif
            elseif ((dissocstate(it,jt).eq.12).or.(dissocstate(it,jt).eq.13)) then
c               write(6,*) 'marker2371'
               tempv2=2
            else
c               write(6,*) 'marker2372'
               write(6,*) 'bad dissocstate',dissocstate(it,jt),'for',it,jt
               stop
            endif
            if (dissocstate(ir,jt).eq.8) then														!top right subunit
c               write(6,*) 'marker2373'
               if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0).and.
     @            (state(ir+1,jt+1).ne.0).and.(state(ir+1,jt).ne.0).and.
     @            (state(ir+1,jt-1).ne.0)) then
c                  write(6,*) 'dissocstate stays 8 for top right'
               elseif (state(ir-1,jt+1).eq.0) then
                  tempv3=2
               elseif (state(ir+1,jt+1).eq.0) then
                  if (state(ir,jt).eq.1) then
                     tempv3=5
                  elseif (state(ir,jt).eq.-1) then
                     tempv3=6
                  else
                     write(6,*) 'empty top right subunit??'
                     stop
                  endif
               elseif (state(ir+1,jt-1).eq.0) then
                  if (state(ir,jt).eq.1) then
                     tempv3=12
                  elseif (state(ir,jt).eq.-1) then
                     tempv3=13
                  else
                     write(6,*) 'empty top right subunit??'
                     stop
                  endif
               endif
            elseif ((dissocstate(ir,jt).eq.5).or.(dissocstate(ir,jt).eq.6).or.
     @             (dissocstate(ir,jt).ge.12)) then
c               write(6,*) 'marker2374'
               tempv3=2
            elseif (dissocstate(ir,jt).eq.10) then
c               write(6,*) 'marker2375'
               tempv3=5
            elseif (dissocstate(ir,jt).eq.11) then
c               write(6,*) 'marker2376'
               if (state(ir,jt).eq.1) then
                  tempv3=5
               elseif (state(ir,jt).eq.-1) then
                  tempv3=6
               else
                  write(6,*) 'empty top right subunit??'
                  stop
               endif
            else
c               write(6,*) 'marker2377'
               write(6,*) 'bad dissocstate',dissocstate(ir,jt),'for',ir,jt
               stop
            endif
            if (dissocstate(ir,jr).eq.8) then														!right subunit
c               write(6,*) 'marker2378'
               if ((state(ir,jr).eq.1).and.(state(ir,jr-1).eq.1)) then
                  temph2=10
               elseif ((state(ir,jr).eq.-1).or.(state(ir,jr-1).eq.-1)) then
                  temph2=11
               else
                  write(6,*) 'empty right subunit??'
                  stop
               endif
            elseif (dissocstate(ir,jr).eq.13) then
c               write(6,*) 'marker2379'
               temph2=6
            elseif (dissocstate(ir,jr).eq.12) then
c               write(6,*) 'marker2380'
               temph2=5
            elseif (dissocstate(ir,jr).eq.6) then
c               write(6,*) 'marker2381'
               temph2=4
            elseif (dissocstate(ir,jr).eq.5) then
c               write(6,*) 'marker2382'
               temph2=3
            else
c               write(6,*) 'marker2383'
               write(6,*) 'bad dissocstate',dissocstate(ir,jr),'for',ir,jr
               stop
            endif
         elseif ((dep(it,jt).eq.0).or.(dep(it,jt).eq.1)) then
c            write(6,*) 'top subunit is special'														!top subunit special
c change deps
            dep(il,jl)=1
            dep(ir,jr)=1
c change dissocstates
            if (dissocstate(il,jl).eq.8) then														!left subunit
c               write(6,*) 'marker2384'
               if ((state(il,jl).eq.1).and.(state(il,jl-1).eq.1)) then
                  temph1=10
               elseif ((state(il,jl).eq.-1).or.(state(il,jl-1).eq.-1)) then
                  temph1=11
               else
                  write(6,*) 'empty left subunit or subunit below??'
                  stop
               endif
            elseif (dissocstate(il,jl).eq.13) then
c               write(6,*) 'marker2385'
               temph1=6
            elseif (dissocstate(il,jl).eq.12) then
c               write(6,*) 'marker2386'
               temph1=5
            elseif (dissocstate(il,jl).eq.6) then
c               write(6,*) 'marker2387'
               temph1=4
            elseif (dissocstate(il,jl).eq.5) then
c               write(6,*) 'marker2388'
               temph1=3
            else
c               write(6,*) 'marker2389'
               write(6,*) 'bad dissocstate',dissocstate(il,jl),'for',il,jl
               stop
            endif
            if (dissocstate(il,jt).eq.8) then														!top left subunit
c               write(6,*) 'marker2390'
               if ((state(il-1,jt-1).ne.0).and.(state(il-1,jt).ne.0).and.
     @            (state(il-1,jt+1).ne.0).and.(state(il,jt+1).ne.0).and.
     @            (state(il+1,jt+1).ne.0)) then
c                  write(6,*) 'dissocstate stays 8 for top left'
               elseif (state(il-1,jt-1).eq.0) then
                  if (state(il,jt).eq.1) then
                     tempv1=12
                  elseif (state(il,jt).eq.-1) then
                     tempv1=13
                  else
                     write(6,*) 'empty top left subunit??'
                     stop
                  endif
               elseif (state(il-1,jt+1).eq.0) then
                  if (state(il,jt).eq.1) then
                     tempv1=5
                  elseif (state(il,jt).eq.-1) then
                     tempv1=6
                  else
                     write(6,*) 'empty top left subunit??'
                     stop
                  endif
               elseif (state(il+1,jt+1).eq.0) then
                  tempv1=2
               endif
            elseif ((dissocstate(il,jt).eq.5).or.(dissocstate(il,jt).eq.6).or.
     @             (dissocstate(il,jt).ge.12)) then
c               write(6,*) 'marker2391'
               tempv1=2
            elseif (dissocstate(il,jt).eq.10) then
c               write(6,*) 'marker2392'
               tempv1=5
            elseif (dissocstate(il,jt).eq.11) then
c               write(6,*) 'marker2393'
               if (state(il,jt).eq.1) then
                  tempv1=5
               elseif (state(il,jt).eq.-1) then
                  tempv1=6
               else
                  write(6,*) 'empty top left subunit??'
                  stop
               endif
            else
c               write(6,*) 'marker2394'
               write(6,*) 'bad dissocstate',dissocstate(il,jt),'for',il,jt
               stop
            endif
            if (dissocstate(it,jt).eq.8) then														!top subunit
c               write(6,*) 'marker2395'
               if ((state(it-1,jt+1).ne.0).and.(state(it,jt+1).ne.0).and.
     @            (state(it+1,jt+1).ne.0)) then
                  if (state(it,jt).eq.1) then
                     tempv2=12
                  elseif (state(it,jt).eq.-1) then
                     tempv2=13
                  else
                     write(6,*) 'empty top subunit??'
                     stop
                  endif
               elseif ((state(it-1,jt+1).eq.0).or.(state(it+1,jt+1).eq.0)) then
                  if (state(it,jt).eq.1) then
                     tempv2=5
                  elseif (state(it,jt).eq.-1) then
                     tempv2=6
                  else
                     write(6,*) 'empty top subunit??'
                     stop
                  endif
               endif
            elseif ((dissocstate(it,jt).eq.12).or.(dissocstate(it,jt).eq.13)) then
c               write(6,*) 'marker2396'
               if (dep(it,jt).eq.0) then
c                  write(6,*) 'remove event for founder'
                  tempv2=2
               else
                  write(6,*) 'bad dissocstate',dissocstate(it,jt),'for',it,jt
                  stop
               endif
            elseif ((dissocstate(it,jt).eq.5).or.(dissocstate(it,jt).eq.6).or.
     @             (dissocstate(it,jt).eq.10).or.(dissocstate(it,jt).eq.11)) then
c               write(6,*) 'marker2397'
               write(6,*) 'bad dissocstate',dissocstate(it,jt),'for',it,jt
               stop
            endif
            if (dissocstate(ir,jt).eq.8) then														!top right subunit
c               write(6,*) 'marker2398'
               if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0).and.
     @            (state(ir+1,jt+1).ne.0).and.(state(ir+1,jt).ne.0).and.
     @            (state(ir+1,jt-1).ne.0)) then
c                  write(6,*) 'dissocstate stays 8 for top right'
               elseif (state(ir-1,jt+1).eq.0) then
                  tempv3=2
               elseif (state(ir+1,jt+1).eq.0) then
                  if (state(ir,jt).eq.1) then
                     tempv3=5
                  elseif (state(ir,jt).eq.-1) then
                     tempv3=6
                  else
                     write(6,*) 'empty top right subunit??'
                     stop
                  endif
               elseif (state(ir+1,jt-1).eq.0) then
                  if (state(ir,jt).eq.1) then
                     tempv3=12
                  elseif (state(ir,jt).eq.-1) then
                     tempv3=13
                  else
                     write(6,*) 'empty top right subunit??'
                     stop
                  endif
               endif
            elseif ((dissocstate(ir,jt).eq.5).or.(dissocstate(ir,jt).eq.6).or.
     @             (dissocstate(ir,jt).ge.12)) then
c               write(6,*) 'marker2399'
               tempv3=2
            elseif (dissocstate(ir,jt).eq.10) then
c               write(6,*) 'marker2400'
               tempv3=5
            elseif (dissocstate(ir,jt).eq.11) then
c               write(6,*) 'marker2401'
               if (state(ir,jt).eq.1) then
                  tempv3=5
               elseif (state(ir,jt).eq.-1) then
                  tempv3=6
               else
                  write(6,*) 'empty top right subunit??'
                  stop
               endif
            else
c               write(6,*) 'marker2402'
               write(6,*) 'bad dissocstate',dissocstate(ir,jt),'for',ir,jt
               stop
            endif
            if (dissocstate(ir,jr).eq.8) then														!right subunit
c               write(6,*) 'marker2403'
               if ((state(ir,jr).eq.1).and.(state(ir,jr-1).eq.1)) then
                  temph2=10
               elseif ((state(ir,jr).eq.-1).or.(state(ir,jr-1).eq.-1)) then
                  temph2=11
               else
                  write(6,*) 'empty right subunit or subunit below??'
                  stop
               endif
            elseif (dissocstate(ir,jr).eq.13) then
c               write(6,*) 'marker2404'
               temph2=6
            elseif (dissocstate(ir,jr).eq.12) then
c               write(6,*) 'marker2405'
               temph2=5
            elseif (dissocstate(ir,jr).eq.6) then
c               write(6,*) 'marker2406'
               temph2=4
            elseif (dissocstate(ir,jr).eq.5) then
c               write(6,*) 'marker2407'
               temph2=3
            else
c               write(6,*) 'marker2408'
               write(6,*) 'bad dissocstate',dissocstate(ir,jr),'for',ir,jr
               stop
            endif
         elseif ((dep(ir,jt).eq.0).or.(dep(ir,jt).eq.1).or.(dep(ir,jt).eq.4).or.(dep(ir,jt).eq.6)) then
c            write(6,*) 'top right subunit is special'												!top right subunit special
c change deps
            dep(il,jl)=1
c change dissocstates
            if (dissocstate(il,jl).eq.8) then														!left subunit
c               write(6,*) 'marker2409'
               if ((state(il,jl).eq.1).and.(state(il,jl-1).eq.1)) then
                  temph1=10
               elseif ((state(il,jl).eq.-1).or.(state(il,jl-1).eq.-1)) then
                  temph1=11
               else
                  write(6,*) 'empty left subunit or subunit below??'
                  stop
               endif
            elseif (dissocstate(il,jl).eq.13) then
c               write(6,*) 'marker2410'
               temph1=6
            elseif (dissocstate(il,jl).eq.12) then
c               write(6,*) 'marker2411'
               temph1=5
            elseif (dissocstate(il,jl).eq.6) then
c               write(6,*) 'marker2412'
               temph1=4
            elseif (dissocstate(il,jl).eq.5) then
c               write(6,*) 'marker2413'
               temph1=3
            else
c               write(6,*) 'marker2414'
               write(6,*) 'bad dissocstate',dissocstate(il,jl),'for',il,jl
               stop
            endif
            if (dissocstate(il,jt).eq.8) then														!top left subunit
c               write(6,*) 'marker2415'
               if ((state(il-1,jt-1).ne.0).and.(state(il-1,jt).ne.0).and.
     @            (state(il-1,jt+1).ne.0).and.(state(il,jt+1).ne.0).and.
     @            (state(il+1,jt+1).ne.0)) then
c                  write(6,*) 'dissocstate stays 8 for top left'
               elseif (state(il-1,jt-1).eq.0) then
                  if (state(il,jt).eq.1) then
                     tempv1=12
                  elseif (state(il,jt).eq.-1) then
                     tempv1=13
                  else
                     write(6,*) 'empty top left subunit??'
                     stop
                  endif
               elseif (state(il-1,jt+1).eq.0) then
                  if (state(il,jt).eq.1) then
                     tempv1=5
                  elseif (state(il,jt).eq.-1) then
                     tempv1=6
                  else
                     write(6,*) 'empty top left subunit??'
                     stop
                  endif
               elseif (state(il+1,jt+1).eq.0) then
                  tempv1=2
               endif
            elseif ((dissocstate(il,jt).eq.5).or.(dissocstate(il,jt).eq.6).or.
     @             (dissocstate(il,jt).ge.12)) then
c               write(6,*) 'marker2416'
               tempv1=2
            elseif (dissocstate(il,jt).eq.10) then
c               write(6,*) 'marker2417'
               tempv1=5
            elseif (dissocstate(il,jt).eq.11) then
c               write(6,*) 'marker2418'
               if (state(il,jt).eq.1) then
                  tempv1=5
               elseif (state(il,jt).eq.-1) then
                  tempv1=6
               else
                  write(6,*) 'empty top left subunit??'
                  stop
               endif
            else
c               write(6,*) 'marker2419'
               write(6,*) 'bad dissocstate',dissocstate(il,jt),'for',il,jt
               stop
            endif
            if (dissocstate(it,jt).eq.8) then														!top subunit
c               write(6,*) 'marker2420'
               if ((state(it-1,jt+1).ne.0).and.(state(it,jt+1).ne.0).and.
     @            (state(it+1,jt+1).ne.0)) then
                  if (state(it,jt).eq.1) then
                     tempv2=12
                  elseif (state(it,jt).eq.-1) then
                     tempv2=13
                  else
                     write(6,*) 'empty top subunit??'
                     stop
                  endif
               elseif (state(it-1,jt+1).eq.0) then
                  if (state(it,jt).eq.1) then
                     tempv2=5
                  elseif (state(it,jt).eq.-1) then
                     tempv2=6
                  else
                     write(6,*) 'empty top subunit??'
                     stop
                  endif
               elseif (state(it+1,jt+1).eq.0) then
                  tempv2=2
               endif
            elseif ((dissocstate(it,jt).eq.12).or.(dissocstate(it,jt).eq.13)) then
c               write(6,*) 'marker2421'
               tempv2=2
            else
c               write(6,*) 'marker2422'
               write(6,*) 'bad dissocstate',dissocstate(it,jt),'for',it,jt
               stop
            endif
            if (dissocstate(ir,jt).eq.8) then														!top right subunit
c               write(6,*) 'marker2423'
               if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0).and.
     @            (state(ir+1,jt+1).ne.0).and.(state(ir+1,jt).ne.0).and.
     @            (state(ir+1,jt-1).ne.0)) then
c                  write(6,*) 'dissocstate stays 8 for top right'
               elseif (state(ir-1,jt+1).eq.0) then
                  if ((state(ir,jt).eq.1).and.(state(ir,jr).eq.1)) then
                     tempv3=10
                  elseif ((state(ir,jt).eq.-1).or.(state(ir,jr).eq.-1)) then
                     tempv3=11
                  else
                     write(6,*) 'empty top right or right subunit??'
                     stop
                  endif
               elseif (state(ir+1,jt+1).eq.0) then
                  if (dep(ir,jt).eq.0) then
                     if ((state(ir,jt).eq.1).and.(state(ir,jr).eq.1)) then
                        tempv3=5
                     elseif ((state(ir,jt).eq.-1).or.(state(ir,jr).eq.-1)) then
                        tempv3=6
                     else
                        write(6,*) 'empty top right or right subunit??'
                        stop
                     endif
                  elseif (dep(ir,jt).eq.1) then
                     if (state(ir,jt).eq.1) then
                        tempv3=5
                     elseif (state(ir,jt).eq.-1) then
                        tempv3=6
                     else
                        write(6,*) 'empty top right subunit??'
                        stop
                     endif
                  elseif (dep(ir,jt).eq.4) then
                     if (state(ir,jr).eq.1) then
                        tempv3=5
                     elseif (state(ir,jr).eq.-1) then
                        tempv3=6
                     else
                        write(6,*) 'empty right subunit??'
                        stop
                     endif
                  endif
               elseif (state(ir+1,jt-1).eq.0) then
                  if (state(ir,jt).eq.1) then
                     tempv3=12
                  elseif (state(ir,jt).eq.-1) then
                     tempv3=13
                  else
                     write(6,*) 'empty top right subunit??'
                     stop
                  endif
               endif
            elseif (dissocstate(ir,jt).eq.13) then
c               write(6,*) 'marker2424'
               tempv3=6
            elseif ((dissocstate(ir,jt).eq.10).or.(dissocstate(ir,jt).eq.12)) then
c               write(6,*) 'marker2425'
               tempv3=5
            elseif (dissocstate(ir,jt).eq.11) then
c               write(6,*) 'marker2426'
               if (state(ir,jt).eq.1) then
                  tempv3=5
               elseif (state(ir,jt).eq.-1) then
                  tempv3=6
               else
                  write(6,*) 'empty top right subunit??'
                  stop
               endif
            elseif ((dissocstate(ir,jt).eq.5).or.(dissocstate(ir,jt).eq.6)) then
c               write(6,*) 'marker2427'
               if (dep(ir,jt).eq.0) then
                  if ((state(ir,jt+1).ne.0).and.(state(ir+1,jt+1).ne.0).and.
     @               (state(ir+1,jt).ne.0)) then
                     if (state(ir,jt).eq.1) then
                        tempv3=5
                     elseif (state(ir,jt).eq.-1) then
                        tempv3=6
                     else
                        write(6,*) 'empty top right subunit??'
                        stop
                     endif
                  else
c                     write(6,*) 'remove event for founder'
                     tempv3=2
                  endif
               else
c                  write(6,*) 'dissocstate stays 5/6 for top right'
               endif
            endif
            if (dissocstate(ir,jr).eq.8) then														!right subunit
c               write(6,*) 'marker2428'
               if ((state(ir,jr).eq.1).and.(state(ir,jr-1).eq.1)) then
                  temph2=10
               elseif ((state(ir,jr).eq.-1).or.(state(ir,jr-1).eq.-1)) then
                  temph2=11
               else
                  write(6,*) 'empty right subunit or subunit below??'
                  stop
               endif
            elseif (dissocstate(ir,jr).eq.13) then
c               write(6,*) 'marker2429'
               temph2=6
            elseif (dissocstate(ir,jr).eq.12) then
c               write(6,*) 'marker2430'
               temph2=5
            elseif (dissocstate(ir,jr).eq.6) then
c               write(6,*) 'marker2431'
               temph2=4
            elseif (dissocstate(ir,jr).eq.5) then
c               write(6,*) 'marker2432'
               temph2=3
            else
c               write(6,*) 'marker2433'
               write(6,*) 'bad dissocstate',dissocstate(ir,jr),'for',ir,jr
               stop
            endif
         elseif ((dep(ir,jr).eq.0).or.(dep(ir,jr).eq.2).or.(dep(ir,jr).eq.4).or.(dep(ir,jr).eq.7)) then
c            write(6,*) 'right subunit is special'													!right subunit is special
c change deps
            dep(il,jl)=1
            dep(il,jt)=4
            dep(it,jt)=4
c change dissocstates
            if (dissocstate(il,jl).eq.8) then														!left subunit
c               write(6,*) 'marker2434'
               if ((state(il,jl).eq.1).and.(state(il,jl-1).eq.1)) then
                  temph1=10
               elseif ((state(il,jl).eq.-1).or.(state(il,jl-1).eq.-1)) then
                  temph1=11
               else
                  write(6,*) 'empty left subunit or subunit below??'
                  stop
               endif
            elseif (dissocstate(il,jl).eq.13) then
c               write(6,*) 'marker2435'
               temph1=6
            elseif (dissocstate(il,jl).eq.12) then
c               write(6,*) 'marker2436'
               temph1=5
            elseif (dissocstate(il,jl).eq.6) then
c               write(6,*) 'marker2437'
               temph1=4
            elseif (dissocstate(il,jl).eq.5) then
c               write(6,*) 'marker2438'
               temph1=3
            else
c               write(6,*) 'marker2439'
               write(6,*) 'bad dissocstate',dissocstate(il,jl),'for',il,jl
               stop
            endif
            if (dissocstate(il,jt).eq.8) then														!top left subunit
c               write(6,*) 'marker2440'
               if ((state(il-1,jt-1).ne.0).and.(state(il-1,jt).ne.0).and.
     @            (state(il-1,jt+1).ne.0).and.(state(il,jt+1).ne.0).and.
     @            (state(il+1,jt+1).ne.0)) then
c                  write(6,*) 'dissocstate stays 8 for top left'
               elseif (state(il-1,jt-1).eq.0) then
                  if (state(il,jt).eq.1) then
                     tempv1=12
                  elseif (state(il,jt).eq.-1) then
                     tempv1=13
                  else
                     write(6,*) 'empty top left subunit??'
                     stop
                  endif
               elseif (state(il-1,jt+1).eq.0) then
                  if (state(il,jt).eq.1) then
                     tempv1=5
                  elseif (state(il,jt).eq.-1) then
                     tempv1=6
                  else
                     write(6,*) 'empty top left subunit??'
                     stop
                  endif
               elseif (state(il+1,jt+1).eq.0) then
                  tempv1=2
               endif
            elseif ((dissocstate(il,jt).eq.5).or.(dissocstate(il,jt).eq.6).or.
     @             (dissocstate(il,jt).ge.12)) then
c               write(6,*) 'marker2441'
               tempv1=2
            elseif (dissocstate(il,jt).eq.11) then
c               write(6,*) 'marker2442'
               if (state(il,jt).eq.1) then
                  tempv1=5
               elseif (state(il,jt).eq.-1) then
                  tempv1=6
               else
                  write(6,*) 'empty top left subunit??'
                  stop
               endif
            elseif (dissocstate(il,jt).eq.10) then
c               write(6,*) 'marker2443'
               tempv1=5
            else
c               write(6,*) 'marker2444'
               write(6,*) 'bad dissocstate',dissocstate(il,jt),'for',il,jt
               stop
            endif
            if (dissocstate(it,jt).eq.8) then														!top subunit
c               write(6,*) 'marker2445'
               if ((state(it-1,jt+1).ne.0).and.(state(it,jt+1).ne.0).and.
     @            (state(it+1,jt+1).ne.0)) then
                  if (state(it,jt).eq.1) then
                     tempv2=12
                  elseif (state(it,jt).eq.-1) then
                     tempv2=13
                  else
                     write(6,*) 'empty top subunit??'
                     stop
                  endif
               elseif (state(it-1,jt+1).eq.0) then
                  if (state(it,jt).eq.1) then
                     tempv2=5
                  elseif (state(it,jt).eq.-1) then
                     tempv2=6
                  else
                     write(6,*) 'empty top subunit??'
                     stop
                  endif
               elseif (state(it+1,jt+1).eq.0) then
                  tempv2=2
               endif
            elseif ((dissocstate(it,jt).eq.12).or.(dissocstate(it,jt).eq.13)) then
c               write(6,*) 'marker2446'
               tempv2=2
            else
c               write(6,*) 'marker2447'
               write(6,*) 'bad dissocstate',dissocstate(it,jt),'for',it,jt
               stop
            endif
            if (dissocstate(ir,jt).eq.8) then														!top right subunit
c               write(6,*) 'marker2448'
               if ((state(ir-1,jt+1).ne.0).and.(state(ir,jt+1).ne.0).and.
     @            (state(ir+1,jt+1).ne.0).and.(state(ir+1,jt).ne.0).and.
     @            (state(ir+1,jt-1).ne.0)) then
c                  write(6,*) 'dissocstate stays 8 for top right'
               elseif (state(ir-1,jt+1).eq.0) then
                  if ((state(ir,jt).eq.1).and.(state(ir,jr).eq.1)) then
                     tempv3=10
                  elseif ((state(ir,jt).eq.-1).or.(state(ir,jr).eq.-1)) then
                     tempv3=11
                  else
                     write(6,*) 'empty right or top right subunit??'
                     stop
                  endif
               elseif (state(ir+1,jt+1).eq.0) then
                  if (state(ir,jr).eq.1) then
                     tempv3=5
                  elseif (state(ir,jr).eq.-1) then
                     tempv3=6
                  else
                     write(6,*) 'empty right subunit??'
                     stop
                  endif
               elseif (state(ir+1,jt-1).eq.0) then
                  if (state(ir,jr).eq.1) then
                     tempv3=3
                  elseif (state(ir,jr).eq.-1) then
                     tempv3=4
                  else
                     write(6,*) 'empty right subunit??'
                     stop
                  endif
               endif
            elseif (dissocstate(ir,jt).eq.13) then
c               write(6,*) 'marker2449'
               tempv3=6
            elseif (dissocstate(ir,jt).eq.12) then
c               write(6,*) 'marker2450'
               tempv3=5
            elseif (dissocstate(ir,jt).eq.11) then
c               write(6,*) 'marker2451'
               if (state(ir,jr).eq.1) then
                  tempv3=3
               elseif (state(ir,jr).eq.-1) then
                  tempv3=4
               else
                  write(6,*) 'empty right subunit??'
                  stop
               endif
            elseif (dissocstate(ir,jt).eq.6) then
c               write(6,*) 'marker2452'
               tempv3=4
            elseif ((dissocstate(ir,jt).eq.5).or.(dissocstate(ir,jt).eq.10)) then
c               write(6,*) 'marker2453'
               tempv3=3
            else
c               write(6,*) 'marker2454'
               write(6,*) 'bad dissocstate',dissocstate(ir,jt),'for',ir,jt
               stop
            endif
            if (dissocstate(ir,jr).eq.8) then														!right subunit
c               write(6,*) 'marker2455'
               if ((state(ir,jr).eq.1).and.(state(ir,jr-1).eq.1)) then
                  temph2=10
               elseif ((state(ir,jr).eq.-1).or.(state(ir,jr-1).eq.-1)) then
                  temph2=11
               else
                  write(6,*) 'empty right subunit or subunit below??'
                  stop
               endif
            elseif (dissocstate(ir,jr).eq.13) then
c               write(6,*) 'marker2456'
               temph2=6
            elseif (dissocstate(ir,jr).eq.12) then
c               write(6,*) 'marker2457'
               temph2=5
            elseif ((dissocstate(ir,jr).eq.5).or.(dissocstate(ir,jr).eq.6)) then
c               write(6,*) 'marker2458'
               if (dep(ir,jr).eq.0) then
                  if ((state(ir,jr-1).ne.0).and.(state(ir+1,jr-1).ne.0).and.
     @               (state(ir+1,jr).ne.0)) then
                     if (state(ir,jr-1).eq.1) then
                        temph2=5
                     elseif (state(ir,jr-1).eq.-1) then
                        temph2=6
                     else
                        write(6,*) 'empty subunit below right??'
                        stop
                     endif
                  else
c                     write(6,*) 'remove event for founder'
                     temph2=2
                  endif
               else
c                  write(6,*) 'dissocstate stays 5/6 for right'
               endif
            elseif ((dissocstate(ir,jr).eq.10).or.(dissocstate(ir,jr).eq.11)) then
c               write(6,*) 'marker2459'
               write(6,*) 'bad dissocstate',dissocstate(ir,jr),'for',ir,jr
               stop
            endif
            !need to see if outside deps are correct...
            if ((state(il-1,jl+1).ne.0).and.(state(il-1,jl).ne.0)) then
               if ((dep(il-1,jl+1).ne.4).and.(dep(il-1,jl).ne.6)) then
                  write(6,*) 'need to change deps for subunits at',il-1,jl+1,'and',il-1,jl
                  write(6,*) 'deps =',dep(il-1,jl+1),',',dep(il-1,jl)
                  stop
               endif
            endif
         else
            write(6,*) 'no special subunit??'
            stop
         endif
c Update...
         if (temph1.ne.dissocstate(il,jl)) then
            dissocstate(il,jl)=temph1
c            write(6,*) 'new dissocstate for',il,jl
            if ((dissocstate(il,jl).eq.2).and.(dep(il,jl).eq.0)) then
c               write(6,*) 'removing dissociation'
         	   nrecyc = nrecyc+1
      		   recyc(nrecyc) = ev(il,jl,2)
      		   index=revmap(ev(il,jl,2))
               ev(il,jl,2)=0
      		   temp=event(index)
	  	       event(index)=event(totev)
	  	       event(totev)=temp
	  	       revmap(event(totev))=totev
	  	       revmap(event(index))=index
	   	       times(event(totev))=1d15
               totev=totev-1
	  	       call min_heapify(event,revmap,times,revmap(ev(il,jl,2)),totev)
               call hpsort(nrecyc,recyc)
      		else
c               write(6,*) 'resetting dissocstate of',il,jl,'to',dissocstate(il,jl)
               times(ev(il,jl,2))=get_evtime(dissocstate(il,jl),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all)
               call update(event,revmap,ev(il,jl,2),times(ev(il,jl,2)),times,totev)
            endif
         endif
         if (tempv1.ne.dissocstate(il,jt)) then
            dissocstate(il,jt)=tempv1
c            write(6,*) 'new dissocstate for',il,jt
            if ((dissocstate(il,jt).eq.2).and.(dep(il,jt).eq.0)) then
c               write(6,*) 'removing dissociation'
         	   nrecyc = nrecyc+1
      		   recyc(nrecyc) = ev(il,jt,2)
      		   index=revmap(ev(il,jt,2))
               ev(il,jt,2)=0
      		   temp=event(index)
	  	       event(index)=event(totev)
	  	       event(totev)=temp
	  	       revmap(event(totev))=totev
	  	       revmap(event(index))=index
	   	       times(event(totev))=1d15
               totev=totev-1
	  	       call min_heapify(event,revmap,times,revmap(ev(il,jt,2)),totev)
               call hpsort(nrecyc,recyc)
      		else
c               write(6,*) 'resetting dissocstate of',il,jt,'to',dissocstate(il,jt)
               times(ev(il,jt,2))=get_evtime(dissocstate(il,jt),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all)
               call update(event,revmap,ev(il,jt,2),times(ev(il,jt,2)),times,totev)
            endif
         endif
         if (tempv2.ne.dissocstate(it,jt)) then
            dissocstate(it,jt)=tempv2
c            write(6,*) 'new dissocstate for',it,jt
            if ((dissocstate(it,jt).eq.2).and.(dep(it,jt).eq.0)) then
c               write(6,*) 'removing dissociation'
         	   nrecyc = nrecyc+1
      		   recyc(nrecyc) = ev(it,jt,2)
      		   index=revmap(ev(it,jt,2))
               ev(it,jt,2)=0
      		   temp=event(index)
	  	       event(index)=event(totev)
	  	       event(totev)=temp
	  	       revmap(event(totev))=totev
	  	       revmap(event(index))=index
	   	       times(event(totev))=1d15
               totev=totev-1
	  	       call min_heapify(event,revmap,times,revmap(ev(it,jt,2)),totev)
               call hpsort(nrecyc,recyc)
      		else
c               write(6,*) 'resetting dissocstate of',it,jt,'to',dissocstate(it,jt)
               times(ev(it,jt,2))=get_evtime(dissocstate(it,jt),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all)
               call update(event,revmap,ev(it,jt,2),times(ev(it,jt,2)),times,totev)
            endif
         endif
         if (tempv3.ne.dissocstate(ir,jt)) then
            dissocstate(ir,jt)=tempv3
c            write(6,*) 'new dissocstate for',ir,jt
            if ((dissocstate(ir,jt).eq.2).and.(dep(ir,jt).eq.0)) then
c               write(6,*) 'removing dissociation'
         	   nrecyc = nrecyc+1
      		   recyc(nrecyc) = ev(ir,jt,2)
      		   index=revmap(ev(ir,jt,2))
               ev(ir,jt,2)=0
      		   temp=event(index)
	  	       event(index)=event(totev)
	  	       event(totev)=temp
	  	       revmap(event(totev))=totev
	  	       revmap(event(index))=index
	   	       times(event(totev))=1d15
               totev=totev-1
	  	       call min_heapify(event,revmap,times,revmap(ev(ir,jt,2)),totev)
               call hpsort(nrecyc,recyc)
      		else
c               write(6,*) 'resetting dissocstate of',ir,jt,'to',dissocstate(ir,jt)
               times(ev(ir,jt,2))=get_evtime(dissocstate(ir,jt),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all)
               call update(event,revmap,ev(ir,jt,2),times(ev(ir,jt,2)),times,totev)
            endif
         endif
         if (temph2.ne.dissocstate(ir,jr)) then
            dissocstate(ir,jr)=temph2
c            write(6,*) 'new dissocstate for',ir,jr
            if ((dissocstate(ir,jr).eq.2).and.(dep(ir,jr).eq.0)) then
c               write(6,*) 'removing dissociation'
         	   nrecyc = nrecyc+1
      		   recyc(nrecyc) = ev(ir,jr,2)
      		   index=revmap(ev(ir,jr,2))
               ev(ir,jr,2)=0
      		   temp=event(index)
	  	       event(index)=event(totev)
	  	       event(totev)=temp
	  	       revmap(event(totev))=totev
	  	       revmap(event(index))=index
	   	       times(event(totev))=1d15
               totev=totev-1
	  	       call min_heapify(event,revmap,times,revmap(ev(ir,jr,2)),totev)
               call hpsort(nrecyc,recyc)
      		else
c               write(6,*) 'resetting dissocstate of',ir,jr,'to',dissocstate(ir,jr)
               times(ev(ir,jr,2))=get_evtime(dissocstate(ir,jr),k_on,conc,
     @                            GDP,K_lat,K_long,K_both,k_hyd,K_thr_long,K_thr_lat,K_all)
               call update(event,revmap,ev(ir,jr,2),times(ev(ir,jr,2)),times,totev)
            endif
         endif
      
      return
      end
C
C
C +++++
C
C
      subroutine AddNewAdditionEvent(i,j,addstate,totev,nev,ev,nrecyc,recyc,
     @                               xloc,yloc,times,k_on,conc,GDP,K_lat,
     @                               K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                               K_all,event,revmap,seammult,k_ne)
      
      implicit none 
      
      integer i,j,addstate(13,*),totev,nev(13,*),ev(13,2000,*)
      integer nrecyc,recyc(*),xloc(*),yloc(*),event(*),revmap(*)
      
      double precision times(*),k_on,conc,GDP,K_lat,K_long,K_both,k_ne
      double precision k_hyd,K_thr_long,K_thr_lat,K_all,get_evtime
      double precision seammult(13,*)
C
C must set dissocstate outside this routine
C
c                  addstate(i,j)=addstate(i,j)+1 !already done in updateemptyX
                  totev=totev+1
                  nev(i,j)=nev(i,j)+1
                  if (nrecyc.eq.0) then
                     xloc(totev)=i
                     yloc(totev)=j
                     ev(i,j,1)=totev
                  else
                     ev(i,j,1)=recyc(1)
	                 xloc(recyc(1))=i
				     yloc(recyc(1))=j
			         if (nrecyc.gt.1) then
		                recyc(1)=recyc(nrecyc)
	   	                call hpsort(nrecyc-1,recyc)
	 	             endif
				     nrecyc=nrecyc-1
                  endif
                  
                  times(ev(i,j,1))=get_evtime(1,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(i,j))
    
    		      event(totev)=ev(i,j,1)
    		      revmap(ev(i,j,1))=totev
	              call build_min_heap(event,revmap,times,totev)
c	              write(6,*) 'totev after add new addition',totev
	  return
	  end
C
C
C +++++
C
C
      subroutine AddNewDissocEvent(i,j,addstate,totev,nev,ev,nrecyc,recyc,
     @                               xloc,yloc,times,k_on,conc,GDP,K_lat,
     @                               K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                               K_all,event,revmap,seammult,k_ne)
      
      implicit none
      
      integer i,j,addstate(13,*),totev,nev(13,*),ev(13,2000,*)
      integer nrecyc,recyc(*),xloc(*),yloc(*),event(*),revmap(*)
      
      double precision times(*),k_on,conc,GDP,K_lat,K_long,K_both,k_ne
      double precision k_hyd,K_thr_long,K_thr_lat,K_all,get_evtime
      double precision seammult(13,*)
C
C must set dissocstate outside this routine
C
c                  addstate(i,j)=addstate(i,j)+1 !already done in updateemptyX
                  totev=totev+1
                  nev(i,j)=nev(i,j)+1
                  if (nrecyc.eq.0) then
                     xloc(totev)=i
                     yloc(totev)=j
                     ev(i,j,2)=totev
                  else
                     ev(i,j,2)=recyc(1)
	                 xloc(recyc(1))=i
				     yloc(recyc(1))=j
			         if (nrecyc.gt.1) then
		                recyc(1)=recyc(nrecyc)
	   	                call hpsort(nrecyc-1,recyc)
	 	             endif
				     nrecyc=nrecyc-1
                  endif
                  
                  times(ev(i,j,2))=get_evtime(1,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(i,j))
    
    		      event(totev)=ev(i,j,2)
    		      revmap(ev(i,j,2))=totev
	              call build_min_heap(event,revmap,times,totev)
c	              write(6,*) 'totev after add new dissoc',totev
	              
	  return
	  end
C
C
C +++++
C
C
      subroutine AddNewHydroEvent(i,j,addstate,totev,nev,ev,nrecyc,recyc,
     @                               xloc,yloc,times,k_on,conc,GDP,K_lat,
     @                               K_long,K_both,k_hyd,K_thr_long,K_thr_lat,
     @                               K_all,event,revmap,seammult,k_ne)
      
      implicit none
      
      integer i,j,addstate(13,*),totev,nev(13,*),ev(13,2000,*)
      integer nrecyc,recyc(*),xloc(*),yloc(*),event(*),revmap(*)
      
      double precision times(*),k_on,conc,GDP,K_lat,K_long,K_both,k_ne
      double precision k_hyd,K_thr_long,K_thr_lat,K_all,get_evtime
      double precision seammult(13,*)
C
C must set dissocstate outside this routine
C
c                  addstate(i,j)=addstate(i,j)+1 !already done in updateemptyX
                  totev=totev+1
                  nev(i,j)=nev(i,j)+1
                  if (nrecyc.eq.0) then
                     xloc(totev)=i
                     yloc(totev)=j
                     ev(i,j,3)=totev
                  else
                     ev(i,j,3)=recyc(1)
	                 xloc(recyc(1))=i
				     yloc(recyc(1))=j
			         if (nrecyc.gt.1) then
		                recyc(1)=recyc(nrecyc)
	   	                call hpsort(nrecyc-1,recyc)
	 	             endif
				     nrecyc=nrecyc-1
                  endif
                  
                  times(ev(i,j,3))=get_evtime(7,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(i,j))
    
    		      event(totev)=ev(i,j,3)
    		      revmap(ev(i,j,3))=totev
	              call build_min_heap(event,revmap,times,totev)
	              
	  return
	  end
C
C
C +++++
C
C
      subroutine RemoveAdditionEvent(i,j,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
     
      implicit none
      
      integer i,j,addstate(13,*),totev,nev(13,*),ev(13,2000,*)
      integer nrecyc,recyc(*),event(*),revmap(*)
      
      double precision times(*)
      integer index, temp
      
c      write(6,*) 'Starting RemoveAdditionEvents',i,j
                  nrecyc = nrecyc+1
      			  recyc(nrecyc) = ev(i,j,1)
      			  index=revmap(ev(i,j,1))
      			  ev(i,j,1)=0
      			  nev(i,j)=nev(i,j)-1
c      write(6,*) 'Shuffle',i,j,index,nev(i,j), totev

      			  temp=event(index)
	  			  event(index)=event(totev)
	  			  event(totev)=temp
	  			  revmap(event(totev))=totev
	  			  revmap(event(index))=index
	  			  times(event(totev))=1d15

                  totev=totev-1
c      write(6,*) 'Before min_heapify',i,j

c	  			  call min_heapify(event,revmap,times,revmap(ev(i,j,1)),totev)
                  call min_heapify(event,revmap,times,1,totev)
 
      			  call hpsort(nrecyc,recyc)
c      write(6,*) 'Finishing RemoveAdditionEvents'
      			  
      return
      end
C
C
C +++++
C
C
      subroutine RemoveHydroEvent(i,j,nrecyc,recyc,revmap,ev,nev,
     @                               addstate,event,times,totev)
     
      implicit none
      
      integer i,j,addstate(13,*),totev,nev(13,*),ev(13,2000,*)
      integer nrecyc,recyc(*),event(*),revmap(*)
      integer index,temp
      double precision times(*)
       
c                  write(6,*) 'inside remhydro',i,j,ev(i,j,3),revmap(ev(i,j,3)),nev(i,j)
                  nrecyc = nrecyc+1
      			  recyc(nrecyc) = ev(i,j,3)
      			  index=revmap(ev(i,j,3))
      			  ev(i,j,3)=0
      			  nev(i,j)=nev(i,j)-1

      			  temp=event(index)
	  			  event(index)=event(totev)
	  			  event(totev)=temp
	  			  revmap(event(totev))=totev
	  			  revmap(event(index))=index
	  			  times(event(totev))=1d15

                  totev=totev-1

	  			  call min_heapify(event,revmap,times,index,totev)
 
      			  call hpsort(nrecyc,recyc)
      			  
      return
      end
C
C
C +++++
C
C
      subroutine CheckAbove(i,j,state,addstate,dissocstate,nev,ev,
     @                      nrecyc,recyc,event,revmap,totev,times)

      implicit none
      
      integer i,j,nrecyc,totev,nev(13,*),recyc(*),revmap(*),event(*)
      integer dissocstate(13,*),addstate(13,*),state(13,*)
      integer ev(13,2000,*)
      double precision times(*)
      
      integer index,temp
      
c            write(6,*) 'check above'
            if (state(i,j+1).eq.0) then
               if (addstate(i,j+1).ge.2) then
                  addstate(i,j+1)=addstate(i,j+1)-1
c                  write(6,*) 'empty above, more than 1 neighbor, how is this possible?'
                  stop
               elseif (addstate(i,j+1).eq.1) then
c                  write(6,*) 'empty above, 1 neighbor, remove event'
                  addstate(i,j+1) = addstate(i,j+1)-1
                  dissocstate(i,j+1)=0
                  if (ev(i,j+1,1).ne.0) then
c               if (qdebug) write(6,*) 'Lose Addition at : ',i,k
                     nrecyc = nrecyc+1
      		         recyc(nrecyc) = ev(i,j+1,1)
      		         index=revmap(ev(i,j+1,1))
      		         nev(i,j+1)=nev(i,j+1)-1
      		         ev(i,j+1,1)=0
      			  			
      		         temp=event(index)
	  		         event(index)=event(totev)
	  		         event(totev)=temp
	  		         revmap(event(totev))=totev
	  		         revmap(event(index))=index
	  		         times(event(totev))=1d15
                     totev=totev-1
	  		         call min_heapify(event,revmap,times,1,totev)
      		         call hpsort(nrecyc,recyc)
      		      endif
               else
                  write(6,*) 'pf#1 dissocstate= ',dissocstate(i,j),' bad addstate'
                  stop
               endif
            else
               write(6,*) 'something above, change addstate and remove gtp hydro'
               write(6,*) 'need to figure out the wiping'
               stop
               addstate(i,j+1) = addstate(i,j+1)-1
               if (ev(i,j,3).ne.0) then
c            if (qdebug) write(6,*) 'Lose Hydrolysis at : ',i,j,ev(i,j,3)
                  nrecyc = nrecyc+1
      	          recyc(nrecyc) = ev(i,j,3)
      	          index=revmap(ev(i,j,3))
      	          nev(i,j)=nev(i,j)-1
      	          ev(i,j,3)=0
      	          call hpsort(nrecyc,recyc)
      	          temp=event(index)
	  	          event(index)=event(totev)
	  	          event(totev)=temp
	  	          revmap(event(totev))=totev
	  	          revmap(event(index))=index
	  	          times(event(totev))=1d15
c	  				       				do kk=1,totev+5
c         			write(6,*) 'times ',kk,times(event(kk)),event(kk),revmap(kk)
c      				end do            

                  totev=totev-1
	  	          call min_heapify(event,revmap,times,1,totev)      			  			
      	       endif
      	    endif

      return
      end
C
C
C +++++
C
C
      subroutine WipeFromSeam(i,j,nremove,ntub,dep,state,addstate,nrecyc,recyc,
     @                        ev,nev,dissocstate,event,revmap,totev,times,seammult)
     
      implicit none
      
      integer i,j,nremove,state(13,*),addstate(13,*),nrecyc,recyc(*),totev,ntub
      integer dep(13,*),ev(13,2000,*),nev(13,*),dissocstate(13,*),event(*),revmap(*)
      double precision times(*)
      double precision seammult(13,*)
      
      integer index,temp,wipecount
      
      
c      write(6,*) 'Assume all wiping is purely vertical for now,nremove=',nremove
c      write(6,*) 'We come in ABOVE the one that triggered the wiping, so seam checks are difft'
      
c Helps keep track of how many subunits are being wiped.
      wipecount=1
c      write(6,*) 'wipecount at beginning is ',wipecount
      
      if (i.eq.1) then
c         write(6,*) 'wiping from 1',i,j
         do while (nremove.gt.0)
c            write(6,*) 'check right neighb of current'
            if (state(i+1,j).ne.0) then
               write(6,*) 'not empty to the right'
               stop
            else
               if (addstate(i+1,j).eq.1) then
c                  write(6,*) 'empty right, remove addition event'
								 index=ev(i+1,j,1)
								 nrecyc=nrecyc+1
								 recyc(nrecyc)=ev(i+1,j,1)
c		                         if (qdebug) write(6,*)'rec event at',ev(ii,yrem(icount),1),ii,yrem(icount)
								 index=revmap(ev(i+1,j,1))
            					 nev(i+1,j)=nev(i+1,j)-1
            					 ev(i+1,j,1)=0
            					 dissocstate(i+1,j)=0
								 addstate(i+1,j)=0
               		
      	    					 temp=event(index)
	  							 event(index)=event(totev)
	  							 event(totev)=temp
	  							 revmap(event(totev))=totev
	  							 revmap(event(index))=index
	  							 times(event(totev))=1d15
            					 totev=totev-1
  								 call build_min_heap(event,revmap,times,totev)
            					 call hpsort(nrecyc,recyc)
               
               else
c                  write(6,*) 'addstate # 1 to the right',i+1,j
                  if (state(i+1,j).eq.0) then
                     addstate(i+1,j)=addstate(i+1,j)-1
                     if (dissocstate(i+1,j).eq.2) then
c                        write(6,*) 'dstate right stays at 2',i+1,j
                     elseif (dissocstate(i+1,j).eq.5) then
c                        write(6,*) 'dstate right goes 5->3',i+1,j
                        dissocstate(i+1,j)=3
c Start nucleotide exchange fun here...
                     elseif (dissocstate(i+1,j).eq.6) then
c                        write(6,*) 'dstate right goes 6->4',i+1,j
                        dissocstate(i+1,j)=4
                     elseif (dissocstate(i+1,j).eq.12) then
c                        write(6,*) 'dstate right goes 12->5',i+1,j
                        dissocstate(i+1,j)=5
                     elseif (dissocstate(i+1,j).eq.13) then
c                        write(6,*) 'dstate right goes 13->6',i+1,j
                        dissocstate(i+1,j)=6   
                     else
                        write(6,*) 'need to treat more dstates',i+1,j,dissocstate(i+1,j)
                        stop
                     endif
c End nucleotide exchange fun here...                     
                  else
                     write(6,*) 'does it make sense not empty right?'
                     stop
                  endif
               endif
            endif
c            write(6,*) 'check across the seam, only worry about lower neighbor',13,j+1
            if (state(13,j+1).ne.0) then
c               write(6,*) 'not empty across seam'
               if ((dissocstate(13,j+1).eq.2).or.(dissocstate(13,j+1).eq.3)							!Code to fix dissocstate/addstate
     @            .or.(dissocstate(13,j+1).eq.4)) then												!across seam of "lower neighbor"
                  write(6,*) 'bad dissocstate 2/3/4 for ',13,j+1									!if occupied when wiping from
                  stop																				!column 1.
               elseif (dissocstate(13,j+1).eq.5) then												!
c                  write(6,*) 'dissocstate change, 5 -> 3'
                  dissocstate(13,j+1)=3																!
               elseif (dissocstate(13,j+1).eq.6) then												!
c                  write(6,*) 'dissocstate change, 6 -> 4'
                  dissocstate(13,j+1)=4																!
               elseif (dissocstate(13,j+1).eq.10) then												!
c                  write(6,*) 'dissocstate change, 10 -> 3'
                  dissocstate(13,j+1)=3																!
               elseif (dissocstate(13,j+1).eq.11) then												!
                  if (state(13,j).eq.1) then														!
c                     write(6,*) 'dissocstate change, 11 -> 3'
                     dissocstate(13,j+1)=3															!
                  elseif (state(13,j).eq.-1) then													!
c                     write(6,*) 'dissocstate change, 11 -> 4'
                     dissocstate(13,j+1)=4															!
                  else																				!
                     write(6,*) 'bad state for ',13,j												!
                     stop																			!
                  endif																				!
               elseif (dissocstate(13,j+1).eq.12) then												!
c                  write(6,*) 'dissocstate change, 12 -> 5'
                  dissocstate(13,j+1)=5																!
               elseif (dissocstate(13,j+1).eq.13) then												!
c                  write(6,*) 'dissocstate change, 13 -> 6'
                  dissocstate(13,j+1)=6																!
               elseif (dissocstate(13,j+1).eq.8) then												!
                  if ((state(13,j+2).ne.0).and.(state(13,j).ne.0)) then								!
                     if ((state(13,j+2).eq.1).and.(state(13,j).eq.1)) then							!
c                        write(6,*) 'dissocstate change, 8 -> 10'
                        dissocstate(13,j+1)=10														!
                     else																			!
c                        write(6,*) 'dissocstate change, 8 -> 11'
                        dissocstate(13,j+1)=11														!
                     endif																			!
                  else																				!
                     write(6,*) 'bad state for dissocstate 8 at ',13,j+2,'or',13,j,'?'				!
                     stop																			!
                  endif																				!
               endif																				!
c               write(6,*) 'dissocstate changed, now change addstate'								!
               addstate(13,j+1)=addstate(13,j+1)-1													!
c               stop            
            else
               if (addstate(13,j+1).eq.1) then
c                  write(6,*) 'empty across seam, one neighbor, remove addition event'
								 index=ev(13,j+1,1)
								 nrecyc=nrecyc+1
								 recyc(nrecyc)=ev(13,j+1,1)
c		                         if (qdebug) write(6,*)'rec event at',ev(ii,yrem(icount),1),ii,yrem(icount)
								 index=revmap(ev(13,j+1,1))
            					 nev(13,j+1)=nev(13,j+1)-1
            					 ev(13,j+1,1)=0
            					 dissocstate(13,j+1)=0
								 addstate(13,j+1)=0
               		
      	    					 temp=event(index)
	  							 event(index)=event(totev)
	  							 event(totev)=temp
	  							 revmap(event(totev))=totev
	  							 revmap(event(index))=index
	  							 times(event(totev))=1d15
            					 totev=totev-1
  								 call build_min_heap(event,revmap,times,totev)
            					 call hpsort(nrecyc,recyc)
               
               elseif (addstate(1,j+1).eq.0) then													!Added case where addstate=0.
c                  write(6,*) 'addstate=0, nothing to do'											!
               else
c                  write(6,*) 'addstate # 1 across seam',13,j+1
                  if (state(13,j+1).eq.0) then
                     addstate(13,j+1)=addstate(13,j+1)-1
                     if (dissocstate(13,j+1).eq.2) then
c                        write(6,*) 'dstate across seam stays 2',13,j+1
                     elseif (dissocstate(13,j+1).eq.5) then
c                        write(6,*) 'dstate across seam goes 5->3',13,j+1
                        dissocstate(13,j+1)=3
c Start nucleotide exchange fun here...
                     elseif (dissocstate(13,j+1).eq.6) then
c                        write(6,*) 'dstate across seam goes 6->4',13,j+1
                        dissocstate(13,j+1)=4
                     elseif (dissocstate(13,j+1).eq.12) then
c                        write(6,*) 'dstate across seam goes 12->5',13,j+1
                        dissocstate(13,j+1)=5
                     elseif (dissocstate(13,j+1).eq.13) then
c                        write(6,*) 'dstate across seam goes 13->6',13,j+1
                        dissocstate(13,j+1)=6
c End nucleotide exchange fun here...                        
                     else
                        write(6,*) 'need to treat more dstates',13,j+1,dissocstate(13,j+1)
                        stop
                     endif
                  else
                     write(6,*) 'does it make sense not empty right?'
                     stop
                  endif
               endif
            endif
c            write(6,*) 'now remove this guy'
	  	    state(i,j)=0
	  	    ntub=ntub-1
	  	    nremove=nremove-1
	  	    dissocstate(i,j)=0
	  	    addstate(i,j)=0 !New addition Aug 3
	  	    dep(i,j)=9
	  	    if (ev(i,j,2).ne.0) then
	  		   index=revmap(ev(i,j,2))
	  		   nrecyc=nrecyc+1
	  		
      		   recyc(nrecyc)=ev(i,j,2)
c      		if (qdebug) write(6,*)'rec event at',ev(xrem(icount),yrem(icount),2),xrem(icount),yrem(icount)

      		   index=revmap(ev(i,j,2))
      		   nev(i,j)=nev(i,j)-1
      		   ev(i,j,2)=0
               		
      		   temp=event(index)
	  		   event(index)=event(totev)
	  		   event(totev)=temp
	  		   revmap(event(totev))=totev
	  		   revmap(event(index))=index
	  		   times(event(totev))=1d15
      		   totev=totev-1
  	  		   call build_min_heap(event,revmap,times,totev)
      		   call hpsort(nrecyc,recyc)
      	    endif
   	  	    if (ev(i,j,3).ne.0) then
      		   index = revmap(ev(i,j,3))
c      	write(6,*) 'Lose Addition at : ',xrem(icount),yrem(icount),index,event(index),ev(xrem(icount),jj,1)

c dissocstate? addstate?
           
      		   nrecyc=nrecyc+1
      		   recyc(nrecyc)=ev(i,j,3)
c	  		if (qdebug) write(6,*)'rec event at',ev(xrem(icount),yrem(icount),3),xrem(icount),yrem(icount)

      		   index=revmap(ev(i,j,3))
      		   nev(i,j)=nev(i,j)-1
      		   ev(i,j,3)=0
               		
      		   temp=event(index)
	  		   event(index)=event(totev)
	  		   event(totev)=temp
	  		   revmap(event(totev))=totev
	  		   revmap(event(index))=index
	  		   times(event(totev))=1d15
      		   totev=totev-1
  	  		   call build_min_heap(event,revmap,times,totev)
      		   call hpsort(nrecyc,recyc)
   	  	    endif
c Check to see if NucEx event needs to be removed...												!new for nuc ex
            if (ev(i,j,4).ne.0) then
c               write(6,*) 'NucEx to be removed at ',i,j,ev(i,j,4)
               call RemoveNucExEvent(i,j,nrecyc,recyc,revmap,
     @                               ev,nev,event,times,totev)
            endif   	  	    
            
c            write(6,*) 'now look above to see if there are more subunits to remove'
            if (state(i,j+1).ne.0) then
c               write(6,*) 'subunit above, add to list'
               nremove=nremove+1
               j=j+1
            else
c               write(6,*) 'nothing above, done wiping from seam@1, remove this last addition event',i,j+1,addstate(i,j+1)

								 index=ev(i,j+1,1)
								 nrecyc=nrecyc+1
								 recyc(nrecyc)=ev(i,j+1,1)
c		                         if (qdebug) write(6,*)'rec event at',ev(ii,yrem(icount),1),ii,yrem(icount)
								 index=revmap(ev(i,j+1,1))
            					 nev(i+1,j)=nev(i,j+1)-1
            					 ev(i,j+1,1)=0
            					 dissocstate(i,j+1)=0
								 addstate(i,j+1)=0
               		
      	    					 temp=event(index)
	  							 event(index)=event(totev)
	  							 event(totev)=temp
	  							 revmap(event(totev))=totev
	  							 revmap(event(index))=index
	  							 times(event(totev))=1d15
            					 totev=totev-1
  								 call build_min_heap(event,revmap,times,totev)
            					 call hpsort(nrecyc,recyc)


            endif
         enddo
      elseif (i.eq.13) then
c         write(6,*) 'wiping from 13',i,j
         do while (nremove.gt.0)
c            write(6,*) 'check left neighb of current'
            if (state(i-1,j).ne.0) then
               write(6,*) 'not empty to the left'
               stop
            else
               if (addstate(i-1,j).eq.1) then
c                  write(6,*) 'empty left, remove addition event'
								 index=ev(i-1,j,1)
								 nrecyc=nrecyc+1
								 recyc(nrecyc)=ev(i-1,j,1)
c		                         if (qdebug) write(6,*)'rec event at',ev(ii,yrem(icount),1),ii,yrem(icount)
								 index=revmap(ev(i-1,j,1))
            					 nev(i-1,j)=nev(i-1,j)-1
            					 ev(i-1,j,1)=0
            					 dissocstate(i-1,j)=0
								 addstate(i-1,j)=0
               		
      	    					 temp=event(index)
	  							 event(index)=event(totev)
	  							 event(totev)=temp
	  							 revmap(event(totev))=totev
	  							 revmap(event(index))=index
	  							 times(event(totev))=1d15
            					 totev=totev-1
  								 call build_min_heap(event,revmap,times,totev)
            					 call hpsort(nrecyc,recyc)
               
               else
c                  write(6,*) 'addstate # 1 to the left',i-1,j
                  if (state(i-1,j).eq.0) then
                     addstate(i-1,j)=addstate(i-1,j)-1
                     if (dissocstate(i-1,j).eq.2) then
c                        write(6,*) 'dstate left stays at 2',i-1,j
                     elseif (dissocstate(i-1,j).eq.5) then
c                        write(6,*) 'dstate left goes 5->3',i-1,j
                        dissocstate(i-1,j)=3
c Start nucleotide exchange fun here...                        
                     elseif (dissocstate(i-1,j).eq.6) then
c                        write(6,*) 'dstate left goes 6->4',i-1,j
                        dissocstate(i-1,j)=4
                     elseif (dissocstate(i-1,j).eq.12) then
c                        write(6,*) 'dstate left goes 12->5',i-1,j
                        dissocstate(i-1,j)=5
                     elseif (dissocstate(i-1,j).eq.13) then
c                        write(6,*) 'dstate left goes 13->6',i-1,j
                        dissocstate(i-1,j)=6   
                     else
                        write(6,*) 'need to treat more dstates',i-1,j,dissocstate(i-1,j)
                        stop
                     endif
c End nucleotide exchange fun here...                     
                  else
                     write(6,*) 'does it make sense not empty left?'
                     stop
                  endif
               endif
            endif
            
c            write(6,*) 'check across the seam'
c            if (state(i,j+1).ne.0) then															Not looking at upper neighbor
c               write(6,*) 'worry about upper neighbor, there is a subunit above us, ',1,j-1		anymore. Is checking coordinates
c               if (j.ge.105) then																	that have already been checked.
c                  if (state(1,j-1).ne.0) then														
c                     write(6,*) 'not empty across seam'											
c                     if ((dissocstate(1,j-1).eq.2).or.(dissocstate(1,j-1).eq.3)					
c     @                  .or.(dissocstate(1,j-1).eq.4)) then										
c                        write(6,*) 'bad dissocstate 2/3/4 for ',1,j-2								!
c                        stop																		!
c                     elseif (dissocstate(1,j-1).eq.5) then											!
c                        write(6,*) 'dissocstate change, 5 -> 3'
c                        dissocstate(1,j-1)=3														!
c                     elseif (dissocstate(1,j-1).eq.6) then											!
c                        write(6,*) 'dissocstate change, 6 -> 4'
c                        dissocstate(1,j-1)=4														!
c                     elseif (dissocstate(1,j-1).eq.10) then											!
c                        write(6,*) 'dissocstate change, 10 -> 3'
c                        dissocstate(1,j-1)=3														!
c                     elseif (dissocstate(1,j-1).eq.11) then											!
c                        if (state(1,j-2).eq.1) then													!
c                           write(6,*) 'dissocstate change, 11 -> 3'
c                           dissocstate(1,j-1)=3														!
c                        elseif (state(1,j-2).eq.-1) then											!
c                           write(6,*) 'dissocstate change, 11 -> 4'
c                           dissocstate(1,j-1)=4														!
c                        else																		!
c                           write(6,*) 'bad state for ',1,j-2										!
c                           stop																		!
c                        endif																		!
c                     elseif (dissocstate(1,j-1).eq.12) then											!
c                        write(6,*) 'dissocstate change, 12 -> 5'
c                        dissocstate(1,j-2)=5														!
c                     elseif (dissocstate(1,j-2).eq.13) then											!
c                        write(6,*) 'dissocstate change, 13 -> 6'
c                        dissocstate(1,j-2)=6														!
c                     elseif (dissocstate(1,j-2).eq.8) then											!
c                        if ((state(1,j-1).ne.0).and.(state(1,j-3).ne.0)) then						!
c                           if ((state(1,j-1).eq.1).and.(state(1,j-3).eq.1)) then					!
c                              write(6,*) 'dissocstate change, 8 -> 10'
c                              dissocstate(1,j-2)=10													!
c                           else																		!
c                              write(6,*) 'dissocstate change, 8 -> 11'
c                              dissocstate(1,j-2)=11													!
c                           endif																	!
c                        else																		!
c                           write(6,*) 'bad state for dissocstate 8 at ',1,j-1,'or',1,j-3,'?'		!
c                           stop																		!
c                        endif																		!
c                     endif																			!
c                     write(6,*) 'dissocstate changed, now change addstate'							!
c                     addstate(1,j-2)=addstate(1,j-2)-1												!
c                     stop
c                  else																				!
c                     if (addstate(1,j-1).eq.1) then													!
c                        write(6,*) 'empty across seam, one neighbor, remove addition event'			!
c					    index=ev(1,j-1,1)															!
c						nrecyc=nrecyc+1																!
c						recyc(nrecyc)=ev(1,j-1,1)													!
c		                if (qdebug) write(6,*)'rec event at',ev(ii,yrem(icount),1),ii,yrem(icount)
c						index=revmap(ev(1,j-1,1))													!
c              		    nev(1,j-1)=nev(1,j-1)-1														!
c            		    ev(1,j-1,1)=0																!
c            		    dissocstate(1,j-1)=0														!
c						addstate(1,j-1)=0															!
c               		    write(6,*) 'addstate of ',1,j-1,'is ',addstate(1,j-1)
c               		
c      	    			temp=event(index)															!
c	  					event(index)=event(totev)													!
c	  					event(totev)=temp															!
c	  					revmap(event(totev))=totev													!
c	  					revmap(event(index))=index													!
c	  					times(event(totev))=1d15													!
c            			totev=totev-1																!
c  						call build_min_heap(event,revmap,times,totev)								!
c            			call hpsort(nrecyc,recyc)													!
c               
c                     elseif (addstate(1,j-1).eq.0) then												!Added case where addstate=0.
c                        write(6,*) 'addstate=0, nothing to do'										!
c                     else																			!
c                        write(6,*) 'addstate # 1 to the right',1,j-1								!
c                        if (state(1,j-1).eq.0) then													!
c                           addstate(1,j-1)=addstate(1,j-1)-1										!
c                           if (dissocstate(1,j-1).eq.2) then										!
c                              write(6,*) 'dissociating from sandwich 2, leave dstate alone'			!
c                           elseif (dissocstate(1,j-1).eq.5) then									!
c                              write(6,*) 'dstate across seam goes 5->3',1,j-1						!
c                              dissocstate(1,j-1)=3													!
c                           elseif (dissocstate(1,j-1).eq.12) then									!
c                              write(6,*) 'dstate across seam goes 12->5',1,j-1						!
c                              dissocstate(1,j-1)=5													!
c                           else																		!
c                              write(6,*) 'need to treat more dstates',1,j-1,dissocstate(1,j-1)		!
c                              stop																	!
c                           endif																	!
c                        else																		!
c                           write(6,*) 'does it make sense not empty across seam?'					!
c                           stop																		!
c                        endif																		!
c                     endif																			!
c                  endif																				!
c               endif
c            endif																					!

c            write(6,*) 'check lower seam neighbor, ',1,j-2              							!Moved from SubFrom13.
            if (j.ge.105) then
               if (state(1,j-2).eq.0) then															!
c                  write(6,*) 'lower seam neighbor empty'
                  if (dissocstate(1,j-2).eq.0) then
c                     write(6,*) 'dissocstate=0 at ',1,j-2
                     if (addstate(1,j-2).eq.0) then													!Changed (i,j-2) to (1,j-2)
                        if (ev(1,j-2,1).eq.0) then
c                           write(6,*) 'nothing to do here'
                        else
                           write(6,*) 'too many events here at ',1,j-2,':',ev(1,j-2,1)
                           stop
                        endif
                     else
                        write(6,*) 'wrong addstate here at ',1,j-2,':',addstate(1,j-2)
                        stop
                     endif
                  elseif (dissocstate(1,j-2).eq.2) then												!
                     if (addstate(1,j-2).eq.1) then
c                        write(6,*) 'dissocstate=2, 1 neighbor, remove event'
                        dissocstate(1,j-2)=0														!
                        if (ev(1,j-2,1).ne.0) then													!
                           call RemoveAdditionEvent(1,j-2,nrecyc,recyc,revmap,ev,nev,				!
     @                               addstate,event,times,totev)									!
      		            endif
                     elseif (addstate(1,j-2).eq.2) then												!
c      		            write(6,*) 'funky dissocstate 2, 2 neighbors, change addstate only'			!
      		         else																			!
                        write(6,*) 'bad addstate for dissocstate 2'									!
      		            stop																		!
      		         endif																			!                     
                  elseif (dissocstate(1,j-2).eq.5) then												!
c                     write(6,*) 'dissocstate change, 5 -> 3'
                     dissocstate(1,j-2)=3															!
c Start nucleotide exchange fun here...
                  elseif (dissocstate(1,j-2).eq.6) then												!
c                     write(6,*) 'dissocstate change, 6 -> 4'
                     dissocstate(1,j-2)=4															!
                  elseif (dissocstate(1,j-2).eq.12) then											!
c                     write(6,*) 'dissocstate change, 12 -> 5'
                     dissocstate(1,j-2)=5															!
                  elseif (dissocstate(1,j-2).eq.13) then											!
c                     write(6,*) 'dissocstate change, 13 -> 6'
                     dissocstate(1,j-2)=6															! 
c End nucleotide exchange fun here...                     
                  else																				!
                     write(6,*) 'bad dissocstate/dissocstate has not been tested at ',1,j-2			!
                     stop																			!
                  endif																				!
                  if (addstate(1,j-2).gt.0) then
c                     write(6,*) 'dissocstate checked, now change addstate'
                     addstate(1,j-2)=addstate(1,j-2)-1												!
c                     write(6,*) 'addstate now is ',addstate(1,j-2)
                  endif
               else																					!New code to figure out what
c               write(6,*) 'does subunit need to be removed at ',1,j-2,'?'							!needs to be done when a subunit
c               stop																				!occupies the "lower neighbor"
c                  write(6,*) 'lower seam neighbor occupied ',1,j-2									!coordinate.
                  if ((dissocstate(1,j-2).eq.2).or.(dissocstate(1,j-2).eq.3)						!
     @               .or.(dissocstate(1,j-2).eq.4)) then											!
                     write(6,*) 'bad dissocstate 2/3/4 for ',1,j-2									!
                     stop																			!
                  elseif (dissocstate(1,j-2).eq.5) then												!
c                     write(6,*) 'dissocstate change, 5 -> 3'
                     dissocstate(1,j-2)=3															!
                  elseif (dissocstate(1,j-2).eq.6) then												!
c                     write(6,*) 'dissocstate change, 6 -> 4'
                     dissocstate(1,j-2)=4															!
                  elseif (dissocstate(1,j-2).eq.10) then											!
c                     write(6,*) 'dissocstate change, 10 -> 3'
                     dissocstate(1,j-2)=3															!
                  elseif (dissocstate(1,j-2).eq.11) then											!
                     if (state(1,j-3).eq.1) then													!
c                        write(6,*) 'dissocstate change, 11 -> 3'
                        dissocstate(1,j-2)=3														!
                     elseif (state(1,j-3).eq.-1) then												!
c                        write(6,*) 'dissocstate change, 11 -> 4'
                        dissocstate(1,j-2)=4														!
                     else																			!
                        write(6,*) 'bad state for ',1,j-3											!
                        stop																		!
                     endif																			!
                  elseif (dissocstate(1,j-2).eq.12) then											!
c                     write(6,*) 'dissocstate change, 12 -> 5'
                     dissocstate(1,j-2)=5															!
                  elseif (dissocstate(1,j-2).eq.13) then											!
c                     write(6,*) 'dissocstate change, 13 -> 6'
                     dissocstate(1,j-2)=6															!
                  elseif (dissocstate(1,j-2).eq.8) then												!
                     if ((state(1,j-1).ne.0).and.(state(1,j-3).ne.0)) then							!
                        if ((state(1,j-1).eq.1).and.(state(1,j-3).eq.1)) then						!
c                           write(6,*) 'dissocstate change, 8 -> 10'
                           dissocstate(1,j-2)=10													!
                        else																		!
c                           write(6,*) 'dissocstate change, 8 -> 11'
                           dissocstate(1,j-2)=11													!
                        endif																		!
                     else																			!
                        write(6,*) 'bad state for dissocstate 8 at ',1,j-1,'or',1,j-3,'?'			!
                        stop																		!
                     endif																			!
                  endif																				!
c                  write(6,*) 'dissocstate changed, now change addstate'								!
                  addstate(1,j-2)=addstate(1,j-2)-1													!
               endif																				!
            else
c               write(6,*) 'do not mess with template!'
            endif

c            write(6,*) 'now remove this guy'
	  	    state(i,j)=0
	  	    ntub=ntub-1
	  	    nremove=nremove-1
	  	    dissocstate(i,j)=0
	  	    addstate(i,j)=0 !New addition Aug 3
	  	    dep(i,j)=9
	  	    seammult(i,j)=1.0	!new addition for seammult stuff...
c	  	    write(6,*) 'seammult= ',seammult(i,j)
	  	    if (ev(i,j,2).ne.0) then
	  		   index=revmap(ev(i,j,2))
	  		   nrecyc=nrecyc+1
	  		
      		   recyc(nrecyc)=ev(i,j,2)
c      		if (qdebug) write(6,*)'rec event at',ev(xrem(icount),yrem(icount),2),xrem(icount),yrem(icount)

      		   index=revmap(ev(i,j,2))
      		   nev(i,j)=nev(i,j)-1
      		   ev(i,j,2)=0
               		
      		   temp=event(index)
	  		   event(index)=event(totev)
	  		   event(totev)=temp
	  		   revmap(event(totev))=totev
	  		   revmap(event(index))=index
	  		   times(event(totev))=1d15
      		   totev=totev-1
  	  		   call build_min_heap(event,revmap,times,totev)
      		   call hpsort(nrecyc,recyc)
      	    endif
   	  	    if (ev(i,j,3).ne.0) then
      		   index = revmap(ev(i,j,3))
c      	write(6,*) 'Lose Addition at : ',xrem(icount),yrem(icount),index,event(index),ev(xrem(icount),jj,1)

c dissocstate? addstate?
           
      		   nrecyc=nrecyc+1
      		   recyc(nrecyc)=ev(i,j,3)
c	  		if (qdebug) write(6,*)'rec event at',ev(xrem(icount),yrem(icount),3),xrem(icount),yrem(icount)

      		   index=revmap(ev(i,j,3))
      		   nev(i,j)=nev(i,j)-1
      		   ev(i,j,3)=0
               		
      		   temp=event(index)
	  		   event(index)=event(totev)
	  		   event(totev)=temp
	  		   revmap(event(totev))=totev
	  		   revmap(event(index))=index
	  		   times(event(totev))=1d15
      		   totev=totev-1
  	  		   call build_min_heap(event,revmap,times,totev)
      		   call hpsort(nrecyc,recyc)
   	  	    endif
c Check to see if NucEx event needs to be removed...												!new for nuc ex
            if (ev(i,j,4).ne.0) then
c               write(6,*) 'NucEx to be removed at ',i,j,ev(i,j,4)
               call RemoveNucExEvent(i,j,nrecyc,recyc,revmap,
     @                               ev,nev,event,times,totev)
            endif
            
c            write(6,*) 'now look above to see if there are more subunits to remove'
            if (state(i,j+1).ne.0) then
c               write(6,*) 'subunit above, add to list, beforehand nremove=',nremove
               nremove=nremove+1
               j=j+1
               
               wipecount=wipecount+1
c               write(6,*) 'wipecount is now ',wipecount
            else
c               write(6,*) 'nothing above, done wiping from seam@13, remove this last addition event',i,j+1,addstate(i,j+1)

								 index=ev(i,j+1,1)
								 nrecyc=nrecyc+1
								 recyc(nrecyc)=ev(i,j+1,1)
c		                         if (qdebug) write(6,*)'rec event at',ev(ii,yrem(icount),1),ii,yrem(icount)
								 index=revmap(ev(i,j+1,1))
            					 nev(i+1,j)=nev(i,j+1)-1
            					 ev(i,j+1,1)=0
            					 dissocstate(i,j+1)=0
								 addstate(i,j+1)=0
               		
      	    					 temp=event(index)
	  							 event(index)=event(totev)
	  							 event(totev)=temp
	  							 revmap(event(totev))=totev
	  							 revmap(event(index))=index
	  							 times(event(totev))=1d15
            					 totev=totev-1
  								 call build_min_heap(event,revmap,times,totev)
            					 call hpsort(nrecyc,recyc)

            endif
         
         enddo
      else
         write(6,*) 'seam wipe but i is not 1,13'
         stop
      endif

c Clear counter.      
      wipecount=0
c      write(6,*) 'wipecount at end is ',wipecount
      
      return
      end
      
C
C
C ++++++++++
C
C

      subroutine NucEx(evno,xloc,yloc,state,nrecyc,recyc,
     @				   totev,nev,ev,maxlen,dissocstate,
     @ 				   event,revmap,evtime)
      
      implicit none
c
c i/o variables
	  integer evno,xloc(*),yloc(*),state(13,*)
      integer nrecyc,recyc(*),totev,maxlen
      integer nev(13,*),ev(13,maxlen,4)
      integer dissocstate(13,maxlen)
      integer event(*)
      integer revmap(*)
      double precision evtime(*)
      integer index				!local variable
c
c local variables
      integer i,j,temp,temp2

c begin computation
	  i=xloc(evno)
	  j=yloc(evno)
	  nev(i,j)=nev(i,j)-1

c      write(6,*) 'Nucleotide exchange at ',i,j
	  
c	  write(6,*) 'First thing to do: exchange GDP for GTP, state goes from -1 to 1'
	  state(i,j)=1
c No need to update because not changing dstate	(i,j)  
	  
c	  write(6,*) 'Recycle old event number'
	  nrecyc=nrecyc+1
	  recyc(nrecyc)=evno
	  
	  index=revmap(ev(i,j,4))
	  ev(i,j,4)=0
	  temp=event(index)
	  event(index)=event(totev)
	  event(totev)=temp
	  revmap(event(totev))=totev
	  revmap(event(index))=index
	  evtime(event(totev))=1d15
	  totev=totev-1
	  call min_heapify(event,revmap,evtime,1,totev)
	  call hpsort(nrecyc,recyc)
	  
c      write(6,*) 'change dissocstate of space above'
c      write(6,*) 'original dissocstate= ',dissocstate(i,j+1)
      temp2=dissocstate(i,j+1)
      
      if (j.gt.102) then
         if (state(i,j+1).eq.0) then
            if (dissocstate(i,j+1).eq.4) then
               temp2=3
            elseif (dissocstate(i,j+1).eq.6) then
               temp2=5
            elseif (dissocstate(i,j+1).eq.11) then
               temp2=11
            elseif (dissocstate(i,j+1).eq.13) then
               temp2=12
            elseif (dissocstate(i,j+1).eq.8) then
            else
               write(6,*) 'bad dissocstate for ',i,j+1
               write(6,*) 'dissocstate= ',dissocstate(i,j+1)
               stop
            endif
         else
            write(6,*) 'site above is occupied?'
            stop
         endif
      elseif (j.lt.98) then
         write(6,*) 'whoops, minus end!'
         stop
      endif
      
      if (temp2.ne.dissocstate(i,j+1)) then
         dissocstate(i,j+1)=temp2
      endif
c No need to update because looking at empty site (i,j+1)     
      
c      write(6,*) 'final dissocstate=',dissocstate(i,j+1)
c      write(6,*) 'End nucleotide exchange'
c      write(6,*) 'List of all events at ',i,j,': add=',ev(i,j,1),', remove=',ev(i,j,2),', hydro=',
c     @           ev(i,j,3),', nucex=',ev(i,j,4) 
	  
	  return
	  end

C
C
C ++++++++++
C
C

      subroutine AddNewNucExEvent(i,j,totev,nev,ev,nrecyc,recyc,xloc,
     @                            yloc,times,k_on,conc,GDP,K_lat,K_long,
     @                            K_both,k_hyd,K_thr_long,K_thr_lat,K_all,
     @                            event,revmap,seammult,k_ne)
      
      implicit none
      
      integer i,j,totev,nev(13,*),ev(13,2000,*)
      integer nrecyc,recyc(*),xloc(*),yloc(*),event(*),revmap(*)
      
      double precision times(*),k_on,conc,GDP,K_lat,K_long,K_both,k_ne
      double precision k_hyd,K_thr_long,K_thr_lat,K_all,get_evtime
      double precision seammult(13,*)
C
C
C
c                  write(6,*) 'start AddNucEx ',i,j,ev(i,j,4),revmap(ev(i,j,4)),nev(i,j)
                  
                  totev=totev+1
                  nev(i,j)=nev(i,j)+1
                  if (nrecyc.eq.0) then
                     xloc(totev)=i
                     yloc(totev)=j
                     ev(i,j,4)=totev
                  else
                     ev(i,j,4)=recyc(1)
	                 xloc(recyc(1))=i
				     yloc(recyc(1))=j
			         if (nrecyc.gt.1) then
		                recyc(1)=recyc(nrecyc)
	   	                call hpsort(nrecyc-1,recyc)
	 	             endif
				     nrecyc=nrecyc-1
                  endif
                  
c                  write(6,*) 'updating times in AddNucEx'
                  times(ev(i,j,4))=get_evtime(9,k_on,conc,
     @                             GDP,K_lat,K_long,K_both,k_hyd,
     @                             K_thr_long,K_thr_lat,K_all,k_ne,seammult(i,j))				!"9" is available number
c                  write(6,*) 'done updating times'
    
    		      event(totev)=ev(i,j,4)
    		      revmap(ev(i,j,4))=totev
	              call build_min_heap(event,revmap,times,totev)
	              
c	              write(6,*) 'end AddNucEx ',i,j,ev(i,j,4),revmap(ev(i,j,4)),nev(i,j)
	              
	  return
	  end

C
C
C ++++++++++
C
C

      subroutine RemoveNucExEvent(i,j,nrecyc,recyc,revmap,
     @                            ev,nev,event,times,totev)
     
      implicit none
      
      integer i,j,totev,nev(13,*),ev(13,2000,*)
      integer nrecyc,recyc(*),event(*),revmap(*)
      integer index,temp							!local variables
      double precision times(*)
       
c                  write(6,*) 'start RemoveNucEx ',i,j,ev(i,j,4),revmap(ev(i,j,4)),nev(i,j)
                  
                  nrecyc = nrecyc+1
      			  recyc(nrecyc) = ev(i,j,4)
      			  index=revmap(ev(i,j,4))
      			  ev(i,j,4)=0
      			  nev(i,j)=nev(i,j)-1

      			  temp=event(index)
	  			  event(index)=event(totev)
	  			  event(totev)=temp
	  			  revmap(event(totev))=totev
	  			  revmap(event(index))=index
	  			  times(event(totev))=1d15

                  totev=totev-1

	  			  call min_heapify(event,revmap,times,index,totev)
 
      			  call hpsort(nrecyc,recyc)
      			  
c      			  write(6,*) 'end RemoveNucEx ',i,j,ev(i,j,4),revmap(ev(i,j,4)),nev(i,j)
      			  
      return
      end	  
      